<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL基础</title>
    <url>/2019/12/25/SQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>关系型数据库之MySQL</p>
<a id="more"></a>



<h1 id="SQL基础"><a href="#SQL基础" class="headerlink" title="SQL基础"></a>SQL基础</h1><p>SQL又叫结构化查询语言,分为三大类,分别是:DDL(数据定义语言),DML(数据操作语言),DCL(数据控制语言)<br>DDL:create(创建数据库和表)、drop(删除数据库和表)、alter(修改表)<br>DML:insert(增)、delete(删)、update(改)、select(查)<br>DCL:grant(授权)、revoke(召回授权)</p>
<p>sql的注释是在注释前加–<br>sql中sql的关键字不区分大小写<br>sq语句结束后需要加分号</p>
<h1 id="DDL-数据定义"><a href="#DDL-数据定义" class="headerlink" title="DDL(数据定义)"></a>DDL(数据定义)</h1><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h3><p>CREATE DATABASE 数据库名称;   —&gt; 创建指定数据库，如果这个数据库已经存在，会报错<br><strong>CREATE DATABASE IF NOT EXISTS 数据库名称;    —&gt; 当指定数据库不存在的时候创建对应的数据库</strong><br>CREATE DATABASE IF NOT EXISTS 数据库名称 DEFAULT CHARSET utf8;    —&gt; 创建数据库的时候指定数据文件编码方式<br>CREATE DATABASE school;</p>
<h3 id="2-删除数据库"><a href="#2-删除数据库" class="headerlink" title="2.删除数据库"></a>2.删除数据库</h3><p><strong>DROP DATABASE 数据库名称;</strong><br><strong>DROP DATABASE IF EXISTS 数据库名;</strong><br>DROP DATABASE school;<br>DROP DATABASE IF EXISTS school;</p>
<h3 id="3-切换-使用数据库"><a href="#3-切换-使用数据库" class="headerlink" title="3.切换/使用数据库"></a>3.切换/使用数据库</h3><p><strong>USE 数据库;  -&gt;   切换/使用指定数据库；切换后所有数据库相关操作都是针对这个数据库</strong><br>USE school;</p>
<h2 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h2><h3 id="1-创建表（数据库文件是通过表来存数据）"><a href="#1-创建表（数据库文件是通过表来存数据）" class="headerlink" title="1.创建表（数据库文件是通过表来存数据）"></a>1.创建表（数据库文件是通过表来存数据）</h3><p><strong>CREATE TABLE IF NOT EXISTS 表名(字段名1 类型1 约束1, 字段名2 类型2 约束2, …);</strong><br><strong>说明:</strong><br>①:表名:程序员自己命名,见名知义,一般需要加前缀t_/tb_示表<br>②:字段名:程序员自己命名,见名知义;注意:字段中一定要有一个字段来作为主键(可以表示唯一一条记录);主键要求不为空,并且是唯一的,而且数据类型是整型<br>③:类型名:必须是当前数据库支持的数据类型,mysql中常用的数据类型:int(整型),float(浮点型),varchar(字符串)/text(字符串),bit(布尔),date/datet ime(日期和时间)<br>④:约束:not null(非空约束)、unique(唯一约束)、default(默认值约束)、primary key(主键约束)、foreign key(外键约束)、auto_increment(自动增长)<br>      注意:约束可以没有,也可以有多个</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> tb_student</span><br><span class="line">(</span><br><span class="line">stuid <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> auto_increment,</span><br><span class="line">stuname <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">stubirth <span class="built_in">DATE</span>,</span><br><span class="line">stugender <span class="built_in">bit</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">stutel <span class="built_in">VARCHAR</span>(<span class="number">11</span>) <span class="keyword">UNIQUE</span></span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (stuid)  主键约束还可以单独设置</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="2-删除表"><a href="#2-删除表" class="headerlink" title="2.删除表"></a>2.删除表</h3><p><strong>DROP TABLE IF EXISTS 表名;</strong><br>DROP TABLE IF EXISTS tb_student;</p>
<h3 id="3-修改表"><a href="#3-修改表" class="headerlink" title="3.修改表"></a>3.修改表</h3><h4 id="3-1-添加字段"><a href="#3-1-添加字段" class="headerlink" title="3.1 添加字段"></a>3.1 添加字段</h4><p><strong>ALTER TABLE 表名 ADD COLUMN 字段名 类型 约束;</strong><br>ALTER TABLE tb_student ADD COLUMN stuaddr VARCHAR(200);  </p>
<h4 id="3-2-删除字段"><a href="#3-2-删除字段" class="headerlink" title="3.2 删除字段"></a>3.2 删除字段</h4><p><strong>ALTER TABLE 表明 DROP COLUMN 字段名;</strong><br>ALTER TABLE tb_student DROP COLUMN stuaddr;</p>
<h4 id="3-3-修改字段名"><a href="#3-3-修改字段名" class="headerlink" title="3.3 修改字段名"></a>3.3 修改字段名</h4><p><strong>ALTER TABLE 表名 CHANGE 原字段 新字段 新类型;</strong><br>ALTER TABLE tb_student CHANGE tel stutel VARCHAR(11);</p>
<h4 id="3-4-添加约束"><a href="#3-4-添加约束" class="headerlink" title="3.4 添加约束"></a>3.4 添加约束</h4><p><strong>3.4.1 创建表或添加字段的时候直接在字段后面添加约束</strong><br><strong>3.4.2 通过修改表的样式添加约束</strong><br><strong>ALTER TABLE 表名 ADD CONSTRAINT 约束索引名 约束名(字段);   -&gt;   给指定字段添加指定约束</strong><br><strong>ALTER TABLE 表1 ADD CONSTRAINT 约束索引名 FOREIGN KEY(字段1) REFERENCES 表2(字段2);   -&gt;   给表1中的字段1添加外键约束,并且字段1的值依赖表2中的字段2</strong></p>
<h4 id="3-5-删除约束"><a href="#3-5-删除约束" class="headerlink" title="3.5 删除约束"></a>3.5 删除约束</h4><p><strong>ALTER TABLE 表名 DROP INDEX 约束索引名;   -&gt;   删除指定约束</strong><br><strong>ALTER TABLE 表名 DROP FOREIGN KEY 外键索引;   -&gt;   删除外键约束</strong></p>
<h1 id="0ML-数据操作"><a href="#0ML-数据操作" class="headerlink" title="0ML(数据操作)"></a>0ML(数据操作)</h1><h2 id="1-INSERT-增"><a href="#1-INSERT-增" class="headerlink" title="1.INSERT(增)"></a>1.INSERT(增)</h2><p><strong>方法①:INSERT INTO 表名 VALUES(值1, 值2, 值3,…)  -&gt; 按表中字段的顺序依次给每个字段赋值,最终形成一条新的记录</strong><br>说明: 日期(DATE)  -&gt;  1)日期字符串:如: ‘2019-12-23’<br>                               2)DATE((NOW())-当前日期; YEAR(NOW())-当前年; MONTH(NOW())-当前月;</p>
<p>INSERT INTO tb_student VALUES(1, ‘天明’, ‘2000-10-2’, 1, ‘12345678901’);</p>
<p><strong>方法②:INSERT INTO 表名(字段名1,字段名2,…) VALUES(值1,值2,…);  -&gt;  按指定顺序给指定字段赋值,最终形成一条新的记录</strong></p>
<p>INSERT INTO tb_student(stuname, stubirth, stugender, stutel) VALUES(‘少羽’, ‘2000-8-21’, 1, ‘12345678902’);</p>
<p><strong>方法③:INSERT INTO 表名(字段名1,字段名2,…) VALUES(值1,值..…),(值11,值22,..),(值111,值2222,…),…;  -&gt;  同时插入多条记录</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_student(stuname, stubirth, stugender, stutel) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">'月儿'</span>, <span class="string">'2000-11-21'</span>, <span class="number">0</span>, <span class="string">'12345678903'</span>),</span><br><span class="line">(<span class="string">'卫庄'</span>, <span class="string">'1989-8-21'</span>, <span class="number">1</span>, <span class="string">'12345678904'</span>),</span><br><span class="line">(<span class="string">'盖聂'</span>, <span class="string">'1990-8-21'</span>, <span class="number">1</span>, <span class="string">'12345678905'</span>),</span><br><span class="line">(<span class="string">'胜七'</span>, <span class="string">'1977-8-21'</span>, <span class="number">1</span>, <span class="string">'12345678906'</span>),</span><br><span class="line">(<span class="string">'惊鲵'</span>, <span class="string">'1971-8-21'</span>, <span class="number">0</span>, <span class="string">'12345678907'</span>),</span><br><span class="line">(<span class="string">'掩日'</span>, <span class="string">'1972-8-21'</span>, <span class="number">1</span>, <span class="string">'12345678908'</span>),</span><br><span class="line">(<span class="string">'黑白玄鉴'</span>, <span class="string">'1970-8-21'</span>, <span class="number">1</span>, <span class="string">'12345678909'</span>),</span><br><span class="line">(<span class="string">'真刚'</span>, <span class="string">'1973-8-25'</span>, <span class="number">1</span>, <span class="string">'12345678910'</span>),</span><br><span class="line">(<span class="string">'断水'</span>, <span class="string">'1974-8-21'</span>, <span class="number">1</span>, <span class="string">'12345678911'</span>),</span><br><span class="line">(<span class="string">'赵高'</span>, <span class="string">'1976-8-31'</span>, <span class="number">1</span>, <span class="string">'12345678912'</span>),</span><br><span class="line">(<span class="string">'韩非'</span>, <span class="string">'1976-8-31'</span>, <span class="number">1</span>, <span class="string">'12345678913'</span>),</span><br><span class="line">(<span class="string">'韩信'</span>, <span class="string">'1976-8-31'</span>, <span class="number">1</span>, <span class="string">'12345678914'</span>),</span><br><span class="line">(<span class="string">'章邯'</span>, <span class="string">'1976-8-31'</span>, <span class="number">1</span>, <span class="string">'12345678915'</span>),</span><br><span class="line">(<span class="string">'鬼谷子'</span>, <span class="string">'1976-8-31'</span>, <span class="number">1</span>, <span class="string">'12345678916'</span>),</span><br><span class="line">(<span class="string">'东皇太一'</span>, <span class="string">'1976-8-31'</span>, <span class="number">1</span>, <span class="string">'12345678917'</span>),</span><br><span class="line">(<span class="string">'晓梦'</span>, <span class="string">'1976-8-31'</span>, <span class="number">0</span>, <span class="string">'12345678918'</span>),</span><br><span class="line">(<span class="string">'逍遥子'</span>, <span class="string">'1976-8-31'</span>, <span class="number">1</span>, <span class="string">'12345678919'</span>),</span><br><span class="line">(<span class="string">'赤炼'</span>, <span class="string">'1976-8-31'</span>, <span class="number">1</span>, <span class="string">'12345678920'</span>),</span><br><span class="line">(<span class="string">'高渐离'</span>, <span class="string">'1976-8-31'</span>, <span class="number">1</span>, <span class="string">'12345678921'</span>);</span><br></pre></td></tr></table></figure>


<h2 id="2-DELETE-删"><a href="#2-DELETE-删" class="headerlink" title="2.DELETE(删)"></a>2.DELETE(删)</h2><p><strong>方法①:DELETE FROM 表名;  -&gt;   删除当前表中所有的记录(清空表)</strong><br><strong>DELETE FROM tb_student;</strong></p>
<p><strong>方法②:DELETE FROM 表名 WHERE 条件;  -&gt;  删除所有满足条件的记录</strong></p>
<p><strong>补充:</strong><br>sq1条件语句的写法(筛选)(条件语句在写的时候可以通过加()改变运算顺序)</p>
<p><strong>比较运算:=(等于),&lt;&gt;(不等于),&gt;,&lt;,&gt;=,&lt;=</strong><br>DELETE FROM tb_student WHERE stuname=’真刚’;</p>
<p><strong>逻辑运算:and(逻辑与),or(逻辑或),not(逻辑非);</strong><br>DELETE FROM tb_student WHERE stuid&gt;=35 AND stugender&lt;&gt;1;</p>
<p><strong>集合包含:in</strong><br>DELETE FROM tb_student WHERE stuname in (‘逍遥子’, ‘韩信’, ‘断水’);</p>
<p><strong>范围:between…and</strong><br>DELETE FROM tb_student WHERE stubirth BETWEEN ‘1976-8-21’ AND ‘1976-8-31’;</p>
<p><strong>判断是否为空:is null,is not null</strong><br>DELETE FROM tb_student WHERE (stubirth IS NULL) AND (stutel IS NULL);</p>
<p><strong>筛选:like(% -&gt; 任意个任意字符; _  -&gt;  表示单个任意字符)</strong><br>DELETE FROM tb_student WHERE stuname LIKE ‘盖_ ‘;<br>DELETE FROM tb_student WHERE stutel LIKE ‘%2_’;</p>
<h2 id="3-UPDATE-改"><a href="#3-UPDATE-改" class="headerlink" title="3.UPDATE(改)"></a>3.UPDATE(改)</h2><p>ALTER TABLE tb_student ADD COLUMN stuaddr VARCHAR(200);</p>
<p><strong>UPDATE 表名 SET 字段1=新值1,字段2=新值2,…;  -&gt;  将指定表中所有记录中指定的字段修改成指定的值</strong></p>
<p>UPDATE tb_student SET stuaddr=’成都’;</p>
<p><strong>UPDATE 表名 SET 字段1=新值1,字段2=新值2,… WHERE 条件;  -&gt;  将满足条件的记录的指定字段设置为指定的值</strong></p>
<p>UPDATE tb_student SET stuaddr=’昆明’ WHERE stugender=0;</p>
<h2 id="4-SELECT-查"><a href="#4-SELECT-查" class="headerlink" title="4.SELECT(查)"></a>4.SELECT(查)</h2><p><strong>SELECT * FROM 表名;  -&gt;  获取指定表中所有的记录中所有字段的数据</strong></p>
<p>SELECT * FROM tb_student;</p>
<p><strong>映射</strong><br><strong>SELECT 字段1,字段2,字段3,… FROM 表名;  -&gt;  获取表中所有记录指定字段的数据</strong><br>SELECT stuname, stugender, stuaddr FROM tb_student;</p>
<p><strong>列重名</strong><br><strong>SELECT 字段名1 AS ‘新字段名1’, 字段名2,字段名3 AS ‘新字段名3’, … FROM 表名;</strong><br>SELECT stuname AS ‘姓名’, stugender AS ‘性别’, stuaddr AS ‘地址’ from tb_student</p>
<p><strong>结果重新赋值(主要针对布尔)</strong><br><strong>SELECT IF(字段名, 值1, 值2) FROM 表名;   -&gt;   一如果if中对应的字段的值是1,最后结果是值1,否则是值2(mysql特有写法)</strong></p>
<p>SELECT stuname AS ‘姓名’, IF(stugender, ‘男’, ‘女’) AS ‘性别’, stuaddr AS ‘地址’ from tb_student</p>
<p><strong>SELECT CASE 字段 WHEN 1或0 THEN 新值1 ELSE 新值2 END FROM 表名;</strong></p>
<p>SELECT stuname AS ‘姓名’, CASE stugender WHEN 1 THEN ‘男’ ELSE ‘女’ END AS ‘性别’, stuaddr AS ‘地址’ from tb_student</p>
<p><strong>列合并(查询的时候将多个字段合并成一个数据返回结果)</strong><br><strong>SELECT CONCAT(字段1,字段2,…) FROM 表名;</strong><br>SELECT CONCAT(stuname, stuid) as ‘姓名学号’ FROM tb_student;</p>
<p><strong>筛选</strong><br><strong>上面所有的查询语法的后面都可以加’where条件’对记录进行筛选</strong><br><strong>SELECT * FROM 表名 WHERE 条件;</strong><br>SELECT stuname, stutel FROM tb_student WHERE stugender=0;<br>SELECT * FROM tb_student WHERE stuname LIKE ‘月_’</p>
<p><strong>排序</strong><br><strong>SELECT * FROM 表名 ORDER BY 字段;   -&gt;   将查询结果按指定字段的值从小到大排序</strong></p>
<p>SELECT * FROM tb_student ORDER BY stuid;</p>
<p><strong>SELECT * FROM 表名 ORDER BY 字段 ASC;   -&gt;   将查询结果按指定字段的值从小到大排序</strong><br><strong>SELECT * FROM 表名 ORDER BY 字段 DESC;   -&gt;   将查询结果按指定字段的值从大到小排序</strong></p>
<p>SELECT * FROM tb_student ORDER BY stuid DESC;</p>
<p><strong>SELECT * FROM 表名 ORDER BY 字段1 DESC, 字段2 DESC;   -&gt;   将查询结果按指定字段的值从大到小排序</strong></p>
<p>SELECT * FROM tb_student ORDER BY stugender DESC, stubirth;   -&gt;   先按stugender从大到小排序;stugender相同再按stubirth从小到大排序</p>
<h2 id="5-外键约束"><a href="#5-外键约束" class="headerlink" title="5.外键约束"></a>5.外键约束</h2><p>让两个表之间产生联系</p>
<p><strong>添加外键约束的规范:</strong><br>一对一: 可以添加到任意一方;<br>一对多和多对一: 添加到多的一方;<br>多对多: 两张表没有办法直接建立多对多的对应关系,需要第三张表辅助</p>
<h2 id="6-查询中的高级查询"><a href="#6-查询中的高级查询" class="headerlink" title="6.查询中的高级查询"></a>6.查询中的高级查询</h2><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p><strong>SELECT DISTINCT 字段名 FROM 表名;    -&gt;   去除重复的项</strong><br><strong>SELECT DISTINCT redate FROM tb_record;</strong></p>
<h3 id="限制和分页"><a href="#限制和分页" class="headerlink" title="限制和分页"></a>限制和分页</h3><p><strong>限制: SELECT * FROM 表名 LIMIT N;   -&gt;   获取前N条数据</strong><br><strong>SELECT * FROM tb_record LIMIT 5;</strong><br><strong>偏移:</strong><br><strong>①:SELECT * FROM 表名 LIMIT M OFFSET N;   -&gt;   跳过前N条数据获取M条数据(从第N+1条数据开始,获取M条数据)</strong><br><strong>②:SELECT * FROM 表名 LIMIT N, M;   -&gt;   跳过前N条数据获取M条数据(从第N+1条数据开始,获取M条数据)</strong></p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p><strong>max(), min(), sum(), avg(), count()   -&gt;   MySQL专用</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(score) <span class="keyword">AS</span> <span class="string">'最高分'</span> <span class="keyword">FROM</span> tb_record;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(score) <span class="keyword">AS</span> <span class="string">'最低分'</span> <span class="keyword">FROM</span> tb_record;</span><br><span class="line">SELECT SUM(score) AS '总分' FROM tb_record;   -&gt;   -- 求和所有分数的和,如果某一个记录的分数是空,那么这条记录不存与运算</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(score) <span class="keyword">AS</span> <span class="string">'平均分'</span> <span class="keyword">FROM</span> tb_record;  </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(score) <span class="keyword">AS</span> <span class="string">'个数'</span> <span class="keyword">FROM</span> tb_record;</span><br></pre></td></tr></table></figure>

<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p><strong>SELECT 聚合操作 FROM 表名 GROUP BY (字段);   -&gt;   按指定字段的值对表进行分组,然后对每个分组进行聚合操作</strong><br><strong>注意:</strong><br><strong>①分组后,除了分组字段以外,其他字段只能聚合操作</strong><br><strong>②分组后要加条件,则用having代替where</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取每个学生所有学科的平局分</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>, <span class="keyword">AVG</span>(score) <span class="keyword">FROM</span> tb_record <span class="keyword">GROUP</span> <span class="keyword">BY</span> (<span class="keyword">sid</span>);</span><br><span class="line"><span class="comment">-- 获取每个学科的平局分</span></span><br><span class="line"><span class="keyword">SELECT</span> cid, <span class="keyword">AVG</span>(score) <span class="keyword">FROM</span> tb_record <span class="keyword">GROUP</span> <span class="keyword">BY</span> (cid);</span><br><span class="line"><span class="comment">-- 获取每个学生选的课程的数量</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>, <span class="keyword">COUNT</span>(cid) <span class="keyword">FROM</span> tb_record <span class="keyword">GROUP</span> <span class="keyword">BY</span> (<span class="keyword">sid</span>);</span><br></pre></td></tr></table></figure>

<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p><strong>①:将一个查询的结果作为另外一个查询的条件</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 例: 获取成绩是最高分的学生的id</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>, score <span class="keyword">FROM</span> tb_record <span class="keyword">WHERE</span> score=(<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(score) <span class="keyword">FROM</span> tb_record);</span><br><span class="line"><span class="comment">-- 例: 获取分数最高的三个学生</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span> <span class="keyword">FROM</span> tb_record <span class="keyword">WHERE</span> score <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(score) <span class="keyword">FROM</span> tb_record <span class="keyword">ORDER</span> <span class="keyword">BY</span> (score)<span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">3</span>);</span><br><span class="line"><span class="comment">-- 例: 获取选了两门以上的课程的学生id</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span> <span class="keyword">FROM</span> tb_record <span class="keyword">GROUP</span> <span class="keyword">BY</span> (<span class="keyword">sid</span>) <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(cid)&gt;<span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 例: 获取选了两门以上的课程的学生姓名</span></span><br><span class="line"><span class="keyword">SELECT</span> stuname <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> stuid <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">sid</span> <span class="keyword">FROM</span> tb_record <span class="keyword">GROUP</span> <span class="keyword">BY</span> (<span class="keyword">sid</span>) <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(cid)&gt;<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><strong>②:将一个查询的结果作为另外一个查询的对象</strong><br><strong>注: 若将查询结果作为查询对象,则必须在使用时用as重命名</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb_student <span class="keyword">LIMIT</span> <span class="number">4</span>,<span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> stuname <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb_student <span class="keyword">LIMIT</span> <span class="number">4</span>,<span class="number">5</span>) <span class="keyword">AS</span> t1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> stuname <span class="keyword">AS</span> sname, stuaddr <span class="keyword">AS</span> saddr <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> stusex=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> sname, saddr <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> stuname <span class="keyword">AS</span> sname, stuaddr <span class="keyword">AS</span> saddr <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> stusex=<span class="number">0</span>) <span class="keyword">AS</span> t2 <span class="keyword">WHERE</span> saddr <span class="keyword">LIKE</span> <span class="string">'%成都'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p><strong>①: SELECT * FROM 表名1, 表名2, … WHERE 连接条件 查询条件;</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询部门中薪水最高的人姓名、工资和所在部门名称</span></span><br><span class="line"><span class="keyword">SELECT</span> dno, <span class="keyword">MAX</span>(sal) <span class="keyword">FROM</span> tb_emp <span class="keyword">GROUP</span> <span class="keyword">BY</span>(dno);</span><br><span class="line"><span class="keyword">SELECT</span> ename, sal, dname <span class="keyword">FROM</span> tb_emp, tb_dept, (<span class="keyword">SELECT</span> dno <span class="keyword">AS</span> dno2, <span class="keyword">MAX</span>(sal) <span class="keyword">AS</span> max_sal <span class="keyword">FROM</span> tb_emp <span class="keyword">GROUP</span> <span class="keyword">BY</span>(dno)) <span class="keyword">AS</span> t2 <span class="keyword">WHERE</span> tb_emp.dno=tb_dept.dno <span class="keyword">AND</span> tb_emp.dno=t2.dno2 <span class="keyword">AND</span> sal=max_sal;</span><br></pre></td></tr></table></figure>

<p><strong>②: SELECT * FROM t1 INNER JOIN t2 ON 连接条件1 INNER JOIN t3 ON 连接条件2;(注意:如果有中间表,中间表放在最前面)</strong><br><strong>注意:如果既有连接条件又有查询条件,查询条件必须放在连接条件的后面</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询部门中薪水最高的人姓名、工资和所在部门名称</span></span><br><span class="line"><span class="keyword">SELECT</span> ename, sal, dname <span class="keyword">FROM</span> tb_emp <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tb_dept <span class="keyword">ON</span> tb_emp.dno=tb_dept.dno <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> dno <span class="keyword">AS</span> dno2, <span class="keyword">MAX</span>(sal) <span class="keyword">AS</span> max_sal <span class="keyword">FROM</span> tb_emp <span class="keyword">GROUP</span> <span class="keyword">BY</span>(dno)) <span class="keyword">AS</span> t2 <span class="keyword">ON</span> tb_emp.dno=t2.dno2 <span class="keyword">WHERE</span> sal=max_sal;</span><br></pre></td></tr></table></figure>

<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p><strong>在MySQL中只支持左外连接(LEFT JOIN)和右外连接(right join)</strong></p>
<p><strong>①: 左连接: SELECT * FROM 表1 LEFT JOIN 表2 : 先将表1中的记录全部取出来,按连接条件依次连接表2中的记录,表1中的记录找不到满足条件,则表2记录那么连接的内容就是空</strong></p>
<p><strong>②: 右连接: SELECT * FROM 表1 RIGHT JOIN 表2 : 先将表2中的记录全部取出来,按连接条件依次连接表1中的记录,表2中的记录找不到满足条件,则表1记录那么连接的内容就是空</strong></p>
<h1 id="DCL-数据控制"><a href="#DCL-数据控制" class="headerlink" title="DCL(数据控制)"></a>DCL(数据控制)</h1><p>DCL主要提供授权和授权召回以及视图, 索引等相关功能</p>
<h2 id="用户管理-一般只有root账号有此权限"><a href="#用户管理-一般只有root账号有此权限" class="headerlink" title="用户管理(一般只有root账号有此权限)"></a>用户管理(一般只有root账号有此权限)</h2><p><strong>创建用户</strong><br><strong>CREATE USER ‘用户名‘@’登陆地址’;  -&gt;   创建指定用户,用户登陆时不用输入密码</strong><br><strong>CREATE USER ‘用户名‘@’登陆地址’ identified by ‘密码’;   -&gt;   创建指定用户,用户登陆时需要输入密码</strong><br>说明:<br>登录地址   -&gt;   ip地址<br>                          localhost(本机)<br>                          %(任意位置)</p>
<p><strong>删除用户</strong><br><strong>DROP USER ‘用户名’;</strong></p>
<h2 id="授权管理"><a href="#授权管理" class="headerlink" title="授权管理"></a>授权管理</h2><p><strong>授权</strong><br><strong>GRANT 权限类型 ON 数据库.表 TO ‘用户名‘@’登陆地址’;</strong></p>
<blockquote>
<p>说明:<br>权限类型: insert, delete, update, select,  create, drop, all privilege(所有权限);</p>
</blockquote>
<p><strong>召回权限</strong><br><strong>REVOKE 权限类型 ON 数据库.表 FROM 用户名;</strong></p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>若完成一个任务需要多个操作,但只要有一个失败则任务不完成,数据回到任务开始前的状态;只有所有操作都成功了,数据库才更新;此时用事务语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;   <span class="comment">-- 开启事务环境 </span></span><br><span class="line"><span class="keyword">UPDATE</span> tb_student <span class="keyword">SET</span> stubirth=<span class="string">'1993-1-1'</span> <span class="keyword">WHERE</span> stusex=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> stuname <span class="keyword">LIKE</span> <span class="string">'杨%'</span></span><br><span class="line"><span class="keyword">COMMIT</span>;   <span class="comment">-- 提交事务环境中的操作结果</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p><strong>创建视图:</strong><br><strong>CREATE VIEW 视图名 AS sql查询语句;</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取学生学科的成绩</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> vw_stu_score <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> stuid, stuname, couid, couname, score <span class="keyword">FROM</span> tb_student, tb_record, tb_course <span class="keyword">WHERE</span> tb_student.stuid=tb_record.sid <span class="keyword">AND</span> tb_course.couid=tb_record.cid;</span><br></pre></td></tr></table></figure>
<p><strong>使用视图:</strong><br><strong>(视图查询操作和表的查询操作基本一致,一般不增删改)</strong></p>
<blockquote>
<p>应用:<br>方便查询,<br>给权限不够的用户查看表内的部分信息.</p>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引就像书的目录,记录了数据的位置, 可以提高查询速度;给使用频率高的字段添加索引,(主键自带唯一索引)</p>
<p><strong>添加索引:</strong><br><strong>①: CREATE INDEX 索引名 ON 表名(字段);   -&gt;   给指定字段添加索引</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> stuname=<span class="string">'岳不群'</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_stuname <span class="keyword">ON</span> tb_student(stuname);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_stuaddr <span class="keyword">ON</span> tb_student(stuaddr);</span><br></pre></td></tr></table></figure>
<p><strong>②: CREATE UNIQUE INDEX 索引名 ON 表名(字段);   -&gt;   给指定字段添加唯一索引</strong><br>注意:模糊查询的时候如果以%和_开头则索引无效</p>
<p><strong>删除索引:</strong><br><strong>ALTER TABLE 表名 DROP INDEX 索引名;   -&gt;   删除指定索引</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_student <span class="keyword">DROP</span> <span class="keyword">INDEX</span> idx_stuname;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_student <span class="keyword">DROP</span> <span class="keyword">INDEX</span> idx_stuaddr;</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>基础</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>浅浅浅谈数据库</title>
    <url>/2019/12/28/%E6%B5%85%E6%B5%85%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>数据库一周小结</p>
<a id="more"></a>

<p>数据库主要分为两大类,分别是关系型数据库(SQL)和非关系型数据库(NOSQL);在关系型数据库中Oracle和MySQL是最具有代表性的两个,在非关系型数据库中MongoDB和Redis也是榜上有名. 而本周的学习中,主要对MySQL和Redis进行了深入的学习.</p>
<p><img src="https://github.com/anjhon1994/some_image/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%9319%E5%B9%B412%E6%9C%88%E4%BD%BF%E7%94%A8%E6%8E%92%E8%A1%8C.png?raw=true" alt=""></p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>MySQL主要使用SQL语言进行增删查改操作;<br>SQL是一种结构化查询语言,SQL语言又分为DDL(数据定义语言), DML(数据操作语言), DCL(数据控制语言)</p>
<h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>1.创建数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> utf8;   <span class="comment">--若dbname不存在,则按编码方式为utf8来新建数据库</span></span><br></pre></td></tr></table></figure>
<p>2.删除数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> dbname;  <span class="comment">-- 若数据库dbname存在就删除该数据库</span></span><br></pre></td></tr></table></figure>
<p>3.切换/使用数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> dbname;  <span class="comment">-- 切换后执行的操作均只对当前数据库有效</span></span><br></pre></td></tr></table></figure>

<h3 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h3><p>1.创建数据表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> tablname(filed1 <span class="keyword">type</span> constraint1, filed2 <span class="keyword">type</span> constraint2, ...);   <span class="comment">-- 创建以field1,filed2..为表头的数据表</span></span><br><span class="line"><span class="comment">-- 在SQL中常见的type: int, float, varchar/text, bit, date   (varchar后通常需要限制字符串的长度)</span></span><br><span class="line"><span class="comment">-- 常见的constraint: not null, unique, default, primary key, foreign key, auto_increment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--注:外键约束的类型有一对一,一对多,多对多三种, 外键添加的方式各不相同</span></span><br><span class="line"><span class="comment">-- 一对一: 可以添加到任意一方;</span></span><br><span class="line"><span class="comment">-- 一对多和多对一: 添加到多的一方;</span></span><br><span class="line"><span class="comment">-- 多对多: 两张表没有办法直接建立多对多的对应关系,需要第三张表辅助</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例:</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> tb_student</span><br><span class="line">(</span><br><span class="line">stuid <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> auto_increment,</span><br><span class="line">stuname <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">stubirth <span class="built_in">DATE</span>,</span><br><span class="line">stugender <span class="built_in">bit</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">stutel <span class="built_in">VARCHAR</span>(<span class="number">11</span>) <span class="keyword">UNIQUE</span></span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (stuid)  主键约束还可以单独设置</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>2.删除表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> tablname;</span><br></pre></td></tr></table></figure>

<p>3.修改表</p>
<p>①:添加字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablname <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="keyword">field</span> <span class="keyword">type</span> <span class="keyword">constraint</span>;</span><br></pre></td></tr></table></figure>
<p>②:删除字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablname <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="keyword">field</span>;</span><br></pre></td></tr></table></figure>
<p>③:修改字段名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablname <span class="keyword">CHANGE</span> <span class="keyword">field</span> new_filed new_type;</span><br></pre></td></tr></table></figure>
<p>④:添加约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablname <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> consname <span class="keyword">constraint</span>(filed);</span><br></pre></td></tr></table></figure>
<p>⑤:删除约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablname <span class="keyword">DROP</span> <span class="keyword">INDEX</span> <span class="keyword">constraint</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablname <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> <span class="keyword">constraint</span>;</span><br></pre></td></tr></table></figure>

<h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><p>1.INSERT(增)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tablname(field1, field2, ...) <span class="keyword">VALUES</span>(value1, value2, ...),(value11, value22, ...), (value111, value222, ...), ...;</span><br></pre></td></tr></table></figure>
<p>2.DELETE(删)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> 条件语句;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 补充:</span></span><br><span class="line">sq1条件语句的写法(筛选)(条件语句在写的时候可以通过加()改变运算顺序)</span><br><span class="line"><span class="comment">-- 比较运算:=(等于),&lt;&gt;(不等于),&gt;,&lt;,&gt;=,&lt;=</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> stuname=<span class="string">'真刚'</span>;</span><br><span class="line"><span class="comment">-- 逻辑运算:and(逻辑与),or(逻辑或),not(逻辑非);</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> stuid&gt;=<span class="number">35</span> <span class="keyword">AND</span> stugender&lt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 集合包含:in</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> stuname <span class="keyword">in</span> (<span class="string">'逍遥子'</span>, <span class="string">'韩信'</span>, <span class="string">'断水'</span>);</span><br><span class="line"><span class="comment">-- 范围:between...and</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> stubirth <span class="keyword">BETWEEN</span> <span class="string">'1976-8-21'</span> <span class="keyword">AND</span> <span class="string">'1976-8-31'</span>;</span><br><span class="line"><span class="comment">-- 判断是否为空:is null,is not null</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> (stubirth <span class="keyword">IS</span> <span class="literal">NULL</span>) <span class="keyword">AND</span> (stutel <span class="keyword">IS</span> <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">-- 筛选:like(% -&gt; 任意个任意字符; _  -&gt;  表示单个任意字符)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> stuname <span class="keyword">LIKE</span> <span class="string">'盖_ '</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> stutel <span class="keyword">LIKE</span> <span class="string">'%2_'</span>;</span><br></pre></td></tr></table></figure>
<p>3.UPDATE(改)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> tablname <span class="keyword">SET</span> field1=value1, field1=value2, ... <span class="keyword">WHERE</span> 条件语句;</span><br></pre></td></tr></table></figure>
<p>4.SELECT(查)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tablname;  <span class="comment">--查询表内所有内容</span></span><br><span class="line"><span class="keyword">SELECT</span> field1, field2, field3, ... <span class="keyword">FROM</span> tablname;  <span class="comment">--获取表中所有记录指定字段的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> field1 <span class="keyword">AS</span> <span class="string">'new_filed1'</span>, field2, field3 <span class="keyword">AS</span> <span class="string">'new_field3'</span>, ... <span class="keyword">FROM</span> tablname;   <span class="comment">--列重名</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">IF</span>(field1, value1, value2) <span class="keyword">FROM</span> tablname;   <span class="comment">--如果if中对应的字段的值是1,最后结果是value1,否则是value2(mysql特有写法)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> <span class="keyword">field</span> <span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> new_value1 <span class="keyword">ELSE</span> new_value2 <span class="keyword">END</span> <span class="keyword">FROM</span> tablname;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(field1, field2, ...) <span class="keyword">FROM</span> tablname;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tablname <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">field</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tablname <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">field</span> <span class="keyword">DESC</span>;   <span class="comment">-- 倒序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">field</span> <span class="keyword">FROM</span> tablname;   <span class="comment">-- 去重</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tablname <span class="keyword">LIMIT</span> N;   <span class="comment">-- 限制(获取前N条数据)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 跳过前N条数据获取M条数据(从第N+1条数据开始,获取M条数据)</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tablname <span class="keyword">LIMIT</span> M <span class="keyword">OFFSET</span> N;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tablname <span class="keyword">LIMIT</span> N, M; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 聚合</span></span><br><span class="line"><span class="comment">-- MAX(), MIN(), SUM(), AVG(), COUNT()   -&gt;   MySQL专用</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(score) <span class="keyword">AS</span> <span class="string">'最高分'</span> <span class="keyword">FROM</span> tb_record;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(score) <span class="keyword">AS</span> <span class="string">'最低分'</span> <span class="keyword">FROM</span> tb_record;</span><br><span class="line">SELECT SUM(score) AS '总分' FROM tb_record;   -&gt;   -- 求和所有分数的和,如果某一个记录的分数是空,那么这条记录不存与运算</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(score) <span class="keyword">AS</span> <span class="string">'平均分'</span> <span class="keyword">FROM</span> tb_record;  </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(score) <span class="keyword">AS</span> <span class="string">'个数'</span> <span class="keyword">FROM</span> tb_record; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分组</span></span><br><span class="line"><span class="keyword">SELECT</span> 聚合操作 <span class="keyword">FROM</span> tablname <span class="keyword">GROUP</span> <span class="keyword">BY</span> (<span class="keyword">field</span>);   <span class="comment">-- 分组后要加条件,则用having代替where</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 子查询</span></span><br><span class="line"><span class="comment">-- ①:将一个查询的结果作为另外一个查询的条件</span></span><br><span class="line"><span class="comment">-- ②:将一个查询的结果作为另外一个查询的对象(注: 若将查询结果作为查询对象,则必须在使用时用as重命名)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 连接查询</span></span><br><span class="line"><span class="comment">--①:内连接</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tablname1, tablname2, ... <span class="keyword">WHERE</span> 连接条件 查询条件;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tablname1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tablname2 <span class="keyword">ON</span> 连接条件<span class="number">1</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tablname3 <span class="keyword">ON</span> 连接条件<span class="number">2</span>;(注意:如果有中间表,中间表放在最前面)</span><br><span class="line"><span class="comment">--注意:如果既有连接条件又有查询条件,查询条件必须放在连接条件的后面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--②:外连接</span></span><br><span class="line"><span class="comment">--在MySQL中只支持左外连接(LEFT JOIN)和右外连接(right join)</span></span><br><span class="line">左连接: <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> : 先将表<span class="number">1</span>中的记录全部取出来,按连接条件依次连接表<span class="number">2</span>中的记录,表<span class="number">1</span>中的记录找不到满足条件,则表<span class="number">2</span>记录那么连接的内容就是空</span><br><span class="line">右连接: <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> : 先将表<span class="number">2</span>中的记录全部取出来,按连接条件依次连接表<span class="number">1</span>中的记录,表<span class="number">2</span>中的记录找不到满足条件,则表<span class="number">1</span>记录那么连接的内容就是空</span><br></pre></td></tr></table></figure>

<h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>1.创建用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'username'</span>@<span class="string">'登陆地址'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'password'</span>;</span><br><span class="line"><span class="comment">-- 注:登录地址有三种写法:</span></span><br><span class="line"><span class="comment">-- ip地址</span></span><br><span class="line"><span class="comment">-- localhost(本机)</span></span><br><span class="line"><span class="comment">-- %(任意位置)</span></span><br></pre></td></tr></table></figure>
<p>2.删除用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">'username'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="授权管理"><a href="#授权管理" class="headerlink" title="授权管理"></a>授权管理</h3><p>1.授权</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限类型 <span class="keyword">ON</span> dataname.tablname <span class="keyword">TO</span> <span class="string">'username'</span>@<span class="string">'登陆地址'</span>;</span><br></pre></td></tr></table></figure>
<p>2.召回权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限类型 <span class="keyword">ON</span> dataname.tablname <span class="keyword">FROM</span> username;</span><br></pre></td></tr></table></figure>

<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>若完成一个任务需要多个操作,但只要有一个失败则任务不完成,数据回到任务开始前的状态;只有所有操作都成功了,数据库才更新;此时用事务语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;   <span class="comment">-- 开启事务环境 </span></span><br><span class="line"><span class="keyword">UPDATE</span> tb_student <span class="keyword">SET</span> stubirth=<span class="string">'1993-1-1'</span> <span class="keyword">WHERE</span> stusex=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> stuname <span class="keyword">LIKE</span> <span class="string">'杨%'</span></span><br><span class="line"><span class="keyword">COMMIT</span>;   <span class="comment">-- 提交事务环境中的操作结果</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名 <span class="keyword">AS</span> <span class="keyword">sql</span>查询语句;</span><br></pre></td></tr></table></figure>

<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--①:添加索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> 索引名 <span class="keyword">ON</span> 表名(字段);   <span class="comment">-- 给指定字段添加索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> 索引名 <span class="keyword">ON</span> 表名(字段);    <span class="comment">-- 给指定字段添加唯一索引</span></span><br><span class="line"><span class="comment">--②:删除索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablname <span class="keyword">DROP</span> <span class="keyword">INDEX</span> 索引名;</span><br></pre></td></tr></table></figure>



<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h2><p>ttl key ——&gt; 查看key的存活时间<br>set key value ex N ——&gt; 设置key的存活时间为N秒<br>set key value px N ——&gt; 设置key的存活时间为N毫秒<br>shutdown  ——&gt; 关闭redis服务器<br>shutdown save ——&gt; 保存并关闭redis服务器<br>save ——&gt; 保存<br>bgsave ——&gt; 后台保存<br>dbsize ——&gt; 查看数据库大小<br>keys *  ——&gt; 获取所有的key<br>keys ta*  ——&gt; 获取ta开头的key</p>
<p><strong>redis默认开启了16个数据库</strong><br>select 0-15 ——&gt; 切换数据库<br>flushdb ——&gt; 清空当前数据库<br>flushall ——&gt; 清空所有数据库</p>
<p>type keyp ——&gt; 判断key的类型</p>
<h2 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h2><h3 id="1-字符串-string"><a href="#1-字符串-string" class="headerlink" title="1.字符串 - string"></a>1.字符串 - string</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">key</span> <span class="keyword">value</span></span><br><span class="line"><span class="keyword">get</span> <span class="keyword">key</span></span><br><span class="line">strlen <span class="keyword">key</span></span><br><span class="line">append <span class="keyword">key</span> <span class="keyword">value</span> <span class="comment">------&gt; 追加</span></span><br><span class="line">mset key1 value1 key2 value2 ... <span class="comment">------&gt; 同时设置多组值</span></span><br><span class="line">mget key1 key2 ...</span><br><span class="line">incr <span class="keyword">key</span> <span class="comment">------&gt; 当key的值为数字时,数值加一</span></span><br><span class="line">incrby <span class="keyword">key</span> N <span class="comment">------&gt; 为key的值加N</span></span><br><span class="line">decr <span class="keyword">key</span> <span class="comment">------&gt; 减一</span></span><br><span class="line">decrby <span class="keyword">key</span> N <span class="comment">------&gt; 减N</span></span><br><span class="line">getrange <span class="keyword">key</span> m n <span class="comment">------&gt; 从m取到n</span></span><br><span class="line">setrange <span class="keyword">key</span> N <span class="keyword">value</span> <span class="comment">------&gt; 从n开始用value覆盖key的value值</span></span><br></pre></td></tr></table></figure>
<h3 id="2-哈希-hash"><a href="#2-哈希-hash" class="headerlink" title="2.哈希 - hash"></a>2.哈希 - hash</h3><figure class="highlight q"><table><tr><td class="code"><pre><span class="line">hset <span class="built_in">key</span> field <span class="built_in">value</span> 设置键和值</span><br><span class="line">hmset <span class="built_in">key</span> field1 value1 field2 value2 同时设置多个键和值</span><br><span class="line">hget <span class="built_in">key</span> field  查看指定的键对应的值</span><br><span class="line">hmget <span class="built_in">key</span> fieldl field2 同时查看多个键和值</span><br><span class="line">hgetall <span class="built_in">key</span> 获取所有的值和键</span><br><span class="line">hkeys <span class="built_in">key</span> 获取所有的键</span><br><span class="line">hvals <span class="built_in">key</span> 获取所有的值</span><br><span class="line">hexists <span class="built_in">key</span> filed 判断是否存在对应的值</span><br></pre></td></tr></table></figure>
<h3 id="3-列表-list"><a href="#3-列表-list" class="headerlink" title="3.列表 - list"></a>3.列表 - list</h3><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">lpush <span class="keyword">list</span> value1 value2 ... 插入到最左边</span><br><span class="line">rpush <span class="keyword">list</span> value1 value2 ... 插入到最右边</span><br><span class="line">lpop <span class="keyword">list</span> 取最左边</span><br><span class="line">rpop <span class="keyword">list</span> 取最右边</span><br><span class="line"><span class="keyword">lrange</span> <span class="keyword">list</span> start end 查看列表片段</span><br><span class="line"><span class="keyword">lindex</span> <span class="keyword">list</span> index 查看指定下标对应的元素</span><br><span class="line">llen <span class="keyword">list</span> 列表长度</span><br><span class="line">lrem <span class="keyword">list</span> count value 删除指定个数的元素</span><br></pre></td></tr></table></figure>
<h3 id="4-集合-set"><a href="#4-集合-set" class="headerlink" title="4.集合 - set"></a>4.集合 - set</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">sadd <span class="keyword">set</span> value1 value2 <span class="string">...</span> 添加元素</span><br><span class="line">srem <span class="keyword">set</span> value 移除元素</span><br><span class="line">spop <span class="keyword">set</span> 获取随机元素</span><br><span class="line">smembers <span class="keyword">set</span> 查看所有元素</span><br><span class="line">sismember <span class="keyword">set</span> value 查看元素是否在集合内</span><br><span class="line">scard <span class="keyword">set</span> 查看元素个数</span><br><span class="line">sinter <span class="keyword">set</span>1 <span class="keyword">set</span>2 交集</span><br><span class="line">sunion <span class="keyword">set</span>1 <span class="keyword">set</span>2 并集</span><br><span class="line">sdiff <span class="keyword">set</span>1 <span class="keyword">set</span>2 差集</span><br></pre></td></tr></table></figure>
<h3 id="5-有序集合-zset-元素自带一个值-可以修改"><a href="#5-有序集合-zset-元素自带一个值-可以修改" class="headerlink" title="5.有序集合 - zset(元素自带一个值,可以修改)"></a>5.有序集合 - zset(元素自带一个值,可以修改)</h3><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">zadd zset score1 mem1 score2 mem2 ... 添加</span><br><span class="line">zrem zset mem 移除</span><br><span class="line">zrange zset start <span class="keyword">end</span> 按<span class="symbol">score</span>升序查看</span><br><span class="line">zrevrange zset start <span class="keyword">end</span> 按<span class="symbol">score</span>降序查看</span><br><span class="line">zscore zset mem 查看<span class="symbol">score</span>值</span><br><span class="line">zincrby zset value mem 改变<span class="symbol">score</span>的值</span><br></pre></td></tr></table></figure>
<h3 id="6-地理位置-LBS应用-Location-Based-Service-基于位置的服务"><a href="#6-地理位置-LBS应用-Location-Based-Service-基于位置的服务" class="headerlink" title="6.地理位置(LBS应用-Location-Based Service - 基于位置的服务)"></a>6.地理位置(LBS应用-Location-Based Service - 基于位置的服务)</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">geoadd zset longitude1 latitude1 member1 longitude2 latitude2 member2 <span class="built_in">..</span>.   添加经纬度信息</span><br><span class="line">geopos zset member1 member2 <span class="built_in">..</span>. 获取指定的位置的经纬度</span><br><span class="line">geodist zset member1 member2 [unit] 计算两点间的距离,默认单位是米,[unit]是单位,可以修改为m,km,mi英里,ft英尺</span><br><span class="line">georadius zset longitude1 latitude1<span class="built_in"> radius </span>m/km/mi/ft 获取以点zset为圆心,radius为半径的圆的范围内的所有的坐标点;后面加withdist,可同时获取距离,加withcoord,可同时获取点的经纬度</span><br></pre></td></tr></table></figure>



<h1 id="Python中使用数据库"><a href="#Python中使用数据库" class="headerlink" title="Python中使用数据库"></a>Python中使用数据库</h1><h2 id="连接MySQL数据库"><a href="#连接MySQL数据库" class="headerlink" title="连接MySQL数据库"></a>连接MySQL数据库</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">连接对象 = pymysql.connect(host, port, user, password) - 和指定的数据库进行连接并返回一个连接对象</span></span><br><span class="line"><span class="string">参数说明:</span></span><br><span class="line"><span class="string">    host - MySQL主机地址: localhost表示当前设备上的MySQL,服务器的公网IP</span></span><br><span class="line"><span class="string">    port - MySQL服务端口,3306</span></span><br><span class="line"><span class="string">    user - MySQL用户</span></span><br><span class="line"><span class="string">    password - 用户对应的密码(如果创建用户的时候没有设置密码,这个参数可以不用赋值)</span></span><br><span class="line"><span class="string">    database - 建立连接后默认操作的数据库</span></span><br><span class="line"><span class="string">    charset - 设置连接的数据库文件的编码方式</span></span><br><span class="line"><span class="string">    autocommit - 是否自动提交(布尔值)  </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">with 连接对象.cursor(查询返回值类型(默认值是none)) as 游标对象:</span></span><br><span class="line"><span class="string">    数据库操作上下文</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">说明:</span></span><br><span class="line"><span class="string">    查询返回值类型   -   None: 查询结果以元组的形式返回;</span></span><br><span class="line"><span class="string">                      pymysql.cursors.dictcursor: 查询结果以字典的形式返回;</span></span><br><span class="line"><span class="string">    数据库操作上下文   -   游标对象(数据库操作)只有在数据库操作上下文才有效</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">con = pymysql.connect(</span><br><span class="line">    host=<span class="string">'localhost'</span>,</span><br><span class="line">    port=<span class="number">3306</span>,</span><br><span class="line">    user=<span class="string">'root'</span>,</span><br><span class="line">    password=<span class="string">'123456'</span>,</span><br><span class="line">    database=<span class="string">'school'</span>,</span><br><span class="line">    charset=<span class="string">'utf8'</span>,</span><br><span class="line">    autocommit=<span class="string">'True'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">with</span> con.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">    <span class="comment"># 数据库操作上下文</span></span><br><span class="line">    <span class="comment"># 3.执行sql语句: 游标对象.execute(sql语句)</span></span><br><span class="line">    cursor.execute(<span class="string">'create database if not exists pyschool;'</span>)</span><br><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>

<h2 id="连接Redis服务器"><a href="#连接Redis服务器" class="headerlink" title="连接Redis服务器"></a>连接Redis服务器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">redis.Redis(host=<span class="string">''</span>, password=<span class="string">''</span>, prot=<span class="string">''</span>)</span><br><span class="line">host : redis所在服务器公网地址;</span><br><span class="line">password : 登录口令;</span><br><span class="line">port : redis的服务端口</span><br><span class="line"></span><br><span class="line">连接时会返回一个连接对象:</span><br><span class="line">redis_cli = redis.Redis(host=<span class="string">''</span>, password=<span class="string">''</span>, prot=<span class="string">''</span>)</span><br><span class="line">使用redis完成相应的操作</span><br></pre></td></tr></table></figure>

<p><strong>扩展:</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">freeze</span> &gt; requirement.txt   将虚拟环境依赖项写入到文件</span><br><span class="line">pip install -r requirement.txt   按照文件安装依赖项</span><br><span class="line"></span><br><span class="line">序列化:  把一个对象变成字符串(str)或字节串(bytes)</span><br><span class="line">反序列化:  把字符串或者字节串还原成对象</span><br><span class="line"><span class="type">json</span>.dumps()   序列化(字符串转换成字节串)</span><br><span class="line"><span class="type">json</span>.loads()   反序列化(字节串转换成字符串)</span><br><span class="line">pickle.dumps()   序列化(字符串转换成字节串)</span><br><span class="line">pickle.loads()   反序列化(字节串转换成字符串)</span><br></pre></td></tr></table></figure>

<h2 id="将Redis作为用户请求和MySQL数据库之间的缓存介质"><a href="#将Redis作为用户请求和MySQL数据库之间的缓存介质" class="headerlink" title="将Redis作为用户请求和MySQL数据库之间的缓存介质"></a>将Redis作为用户请求和MySQL数据库之间的缓存介质</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_depts_from_db</span><span class="params">()</span>:</span></span><br><span class="line">    conn = pymysql.connect(</span><br><span class="line">        host=<span class="string">'localhost'</span>,</span><br><span class="line">        port=<span class="number">3306</span>,</span><br><span class="line">        user=<span class="string">'root'</span>,</span><br><span class="line">        password=<span class="string">'119148'</span>,</span><br><span class="line">        charset=<span class="string">'utf8'</span>,</span><br><span class="line">        autocommit=<span class="literal">True</span>,</span><br><span class="line">        database=<span class="string">'hrs'</span></span><br><span class="line">    )</span><br><span class="line">    depts = ()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">            cursor.execute(<span class="string">'select dno, dname, dloc from tb_dept'</span>)</span><br><span class="line">            depts = cursor.fetchall()</span><br><span class="line">    <span class="keyword">except</span> pymysql.MySQLError <span class="keyword">as</span> err:</span><br><span class="line">        print(err)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        conn.close()</span><br><span class="line">    <span class="keyword">return</span> depts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    redis_cli = redis.Redis(host=<span class="string">'49.233.152.190'</span>, port=<span class="number">6379</span>, password=<span class="string">'119148'</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    data = redis_cli.get(<span class="string">'depts'</span>)</span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        depts = pickle.loads(data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        depts = load_depts_from_db()</span><br><span class="line">        redis_cli.set(<span class="string">'depts'</span>, pickle.dumps(depts))</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    print(depts)</span><br><span class="line">    print(<span class="string">f'执行时间: <span class="subst">&#123;end - start&#125;</span>秒'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>手推维特比算法实现词性标注</title>
    <url>/2021/08/15/NLP/%E6%89%8B%E5%86%99%E7%BB%B4%E7%89%B9%E6%AF%94%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%AF%8D%E6%80%A7%E6%A0%87%E6%B3%A8/</url>
    <content><![CDATA[<h1 id="一、词性标注简单原理"><a href="#一、词性标注简单原理" class="headerlink" title="一、词性标注简单原理"></a>一、词性标注简单原理</h1><p>现有已经标注好的词和对应的词性，作为训练数据。</p>
<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmpmiooh8jj20s106f757.jpg" alt="维特比1.png"></p>
<p>假设给定一个句子，我们要通过构建一个维特比算法写的模型，来为这个句子标注出正确的词性。</p>
<br>


<h1 id="二、维特比算法"><a href="#二、维特比算法" class="headerlink" title="二、维特比算法"></a>二、维特比算法</h1><p><strong>维特比算法</strong>（英语：<strong>Viterbi algorithm</strong>）是一种<a href="https://zh.wikipedia.org/wiki/动态规划" target="_blank" rel="noopener">动态规划</a><a href="https://zh.wikipedia.org/wiki/算法" target="_blank" rel="noopener">算法</a>。它用于寻找最有可能产生观测事件序列的<strong>维特比路径</strong>——隐含状态序列，特别是在马尔可夫信息源上下文和隐马尔可夫模型中。术语“维特比路径”和“维特比算法”也被用于寻找观察结果最有可能解释相关的动态规划算法。例如在<a href="https://zh.wikipedia.org/w/index.php?title=统计句法分析&action=edit&redlink=1" target="_blank" rel="noopener">统计句法分析</a>中动态规划算法可以被用于发现最可能的上下文无关的派生（解析）的字符串，有时被称为“维特比分析”。</p>
<p>—— 维基百科</p>
<p>假设句子S：$S=w_1 w_2 w_3…w_n$，用 $Z$ 代表句子 $S$ 的词性，那么就可以写成：<br>$$<br>\hat Z = \underset{z}{\operatorname{argmax}} P(Z|S)<br>$$<br>解读为: 给定一个句子 $S$ , 求它最大概率的词性序列 $Z$<br>$$<br>\begin{aligned}<br>&amp; 根据贝叶斯定理可得: \\<br>&amp; \\<br>P(Z|S) &amp;= \frac{P(S|Z)·P(Z)}{P(S)}\\<br>&amp; \\<br>&amp; 又根据噪声信道模型(Noise Channel Model)可得: \\<br>&amp; \\<br>P(Z|S)<br>&amp; \propto P(S|Z)·P(Z)\\<br>&amp; = P(S_1,S_2,S_3…S_n|Z_1,Z_1,Z_3…Z_n)·P(Z_1,Z_1,Z_3…Z_n)\\<br>&amp; \\<br>&amp; 假设每个单词的 词与词性 是互相独立的, 那么:\\<br>&amp; \\<br>&amp; = P(S_1|Z_1)·P(S_2|Z_2),P(S_3|Z_3)…P(S_n|Z_n)·P(Z_1,Z_1,Z_3…Z_n)\\<br>&amp; = \prod_{i=1}^n P(S_i|Z_i)·P(Z_1,Z_1,Z_3…Z_n)\\<br>&amp; \\<br>&amp; 通过bigram模型来展开,那么:\\<br>&amp; \\<br>&amp; = \prod_{i=1}^n P(S_i|Z_i)·P(Z_1)·P(Z_2|Z_1)·P(Z_3|Z_2)…P(Z_n|Z_{n-1})\\<br>&amp; = \prod_{i=1}^n P(S_i|Z_i)·P(Z_1)·\prod_{t=2}^nP(Z_t|Z_{t-1})\\<br>&amp; \\<br>&amp; 在前面加log并展开:\\<br>&amp; \\<br>&amp; = log(\prod_{i=1}^n P(S_i|Z_i)·P(Z_1)·\prod_{t=2}^n P(Z_t|Z_{t-1}))\\<br>&amp; = \sum_{i=1}^n log(P(S_i|Z_i)) + log(P(Z_1)) + \sum_{t=2}^n log(P(Z_t|Z_{t-1}))\\<br>\end{aligned}<br>$$</p>
<p>最终得到:<br>$$<br>\hat Z = \underset{z}{\operatorname{argmax}} (\sum_{i=1}^n log(P(S_i|Z_i)) + log(P(Z_1)) + \sum_{t=2}^n log(P(Z_t|Z_{t-1})))<br>$$</p>
<p>这里的 $\hat Z$ 最终输出的是一个（概率最大的）词性序列，得到上面这个公式之后，我们就可以用维特比算法进行求解</p>
<p>由于篇幅原因，这里就不展开介绍维特比算法了。</p>
<p>这里有更好的文章：<a href="https://www.zhihu.com/question/20136144/answer/763021768" target="_blank" rel="noopener">如何通俗地讲解 viterbi 算法？</a> </p>
<blockquote>
<p>$A = P(S_i|Z_i)$ 表示给定一个词性, 出现某个单词的概率</p>
<p>$\pi = P(Z_1)$ 表示该词性出现在句首的概率</p>
<p>$B = P(Z_t|Z_{t-1})$ 表示句子中出现 $Z_{t-1}$ 之后出现 $Z_t$ 的概率(词性转移的概率)</p>
</blockquote>
<p>以上三个参数都可以在训练数据中可以统计出来</p>
<p>假设, 训练数据中单词的个数(词典的长度)为M, 词性的个数为N, 那么:</p>
<p>A 是一个 M*N的矩阵; $\pi$ 是一个长度为N的向量, B 是一个N*N的矩阵</p>
<p>接下来就是愉快的代码时间了</p>
<br>


<h1 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h1><h2 id="1-建立单词和词性的map"><a href="#1-建立单词和词性的map" class="headerlink" title="1: 建立单词和词性的map"></a>1: 建立单词和词性的map</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立map，以便后面在更新矩阵和向量时统计次数，并求出概率</span></span><br><span class="line">tag2id, id2tag = &#123;&#125;, &#123;&#125;</span><br><span class="line">word2id, id2word = &#123;&#125;, &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'traindata.txt'</span>):</span><br><span class="line">    items = line.split(<span class="string">'/'</span>)</span><br><span class="line">    word, tag = items[<span class="number">0</span>], items[<span class="number">1</span>].rstrip()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> word2id:</span><br><span class="line">        word2id[word] = len(word2id)</span><br><span class="line">        id2word[len(id2word)] = word</span><br><span class="line">    <span class="keyword">if</span> tag <span class="keyword">not</span> <span class="keyword">in</span> tag2id:</span><br><span class="line">        tag2id[tag] = len(tag2id)</span><br><span class="line">        id2tag[len(id2tag)] = tag</span><br><span class="line">        </span><br><span class="line">M = len(word2id)   <span class="comment"># 词典大小</span></span><br><span class="line">N = len(tag2id)   <span class="comment"># 词性个数</span></span><br><span class="line">print(M, N)</span><br></pre></td></tr></table></figure>



<h2 id="2-代码实现计算参数A-pi-B"><a href="#2-代码实现计算参数A-pi-B" class="headerlink" title="2: 代码实现计算参数A, $\pi$ , B"></a>2: 代码实现计算参数A, $\pi$ , B</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化参数</span></span><br><span class="line">pi = np.zeros(N)</span><br><span class="line">A = np.zeros((N, M))</span><br><span class="line">B = np.zeros((N, N))</span><br><span class="line"></span><br><span class="line">prev_tag = <span class="string">''</span>   <span class="comment"># 用来保存上一个词的词性</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'traindata.txt'</span>):</span><br><span class="line">    items = line.split(<span class="string">'/'</span>)</span><br><span class="line">    wordid, tagid = word2id[items[<span class="number">0</span>]], tag2id[items[<span class="number">1</span>].rstrip()]   <span class="comment"># 获取词和词性对应的id</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 先统计pi A B对应位置的次数</span></span><br><span class="line">    <span class="keyword">if</span> prev_tag == <span class="string">''</span>:   <span class="comment"># 判断当前单词是否为句子的开始</span></span><br><span class="line">        pi[tagid] += <span class="number">1</span>   </span><br><span class="line">        A[tagid][wordid] += <span class="number">1</span>   </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        A[tagid][wordid] += <span class="number">1</span></span><br><span class="line">        B[tag2id[prev_tag]][tagid] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> items[<span class="number">0</span>] == <span class="string">'.'</span>:   <span class="comment"># 如果当前单词为句号，那么更新prev_tag的状态，以便下次循环判断是否为句子的开始</span></span><br><span class="line">        prev_tag = <span class="string">''</span></span><br><span class="line">    <span class="keyword">else</span>:   <span class="comment"># 否则就记录当前词的词性</span></span><br><span class="line">        prev_tag = items[<span class="number">1</span>].rstrip()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment"># 将次数转换成概率</span></span><br><span class="line">pi = pi / sum(pi)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(N):   </span><br><span class="line">    A[i] = A[i] / sum(A[i])   <span class="comment"># 求矩阵中每个数在每一行的占比（概率）</span></span><br><span class="line">    B[i] = B[i] / sum(B[i])</span><br></pre></td></tr></table></figure>



<h2 id="3-建立模型"><a href="#3-建立模型" class="headerlink" title="3: 建立模型"></a>3: 建立模型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立模型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(v)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> v == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> np.log(v + <span class="number">0.00000001</span>)   <span class="comment"># 平滑操作</span></span><br><span class="line">    <span class="keyword">return</span> np.log(v)        </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">viterbi</span><span class="params">(x, pi, A, B)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    x: 需要预测词性的句子</span></span><br><span class="line"><span class="string">    pi: 词性出现句首的概率</span></span><br><span class="line"><span class="string">    A：给定词性，每个单词出现的概率</span></span><br><span class="line"><span class="string">    B：词性质检转换的概率（上个单词的词性为a，下个单词的词性为b的概率）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    x =[word2id[word] <span class="keyword">for</span> word <span class="keyword">in</span> x.split(<span class="string">' '</span>)]   <span class="comment"># 输入为因为句子，直接用空格切割；如果为中文，则需要分词</span></span><br><span class="line">    T = len(x)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义一个二维数组dp，dp[i][j]表示从第一个单词到第i个单词,第j个词性的最优路径</span></span><br><span class="line">    dp = np.zeros([T,N])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义一个二维数组ptr，记录当前dp节点最好路径得分 是由上一次哪一个词性计算得来的</span></span><br><span class="line">    ptr = np.array([[<span class="number">0</span> <span class="keyword">for</span> y <span class="keyword">in</span> range(N)] <span class="keyword">for</span> x <span class="keyword">in</span> range(T)])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算dp 第一例（第一个单词）在每个词性下的路径值</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">        dp[<span class="number">0</span>][j] = log(pi[j]) + log(A[j][x[<span class="number">0</span>]])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算第二个词往后的所有路径得分</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, T):   <span class="comment"># 每个单词</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(N):   <span class="comment"># 每个词性</span></span><br><span class="line">            dp[i][j] = <span class="number">-999999</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(N):   <span class="comment"># 上一个词的词性</span></span><br><span class="line">                </span><br><span class="line">                score = dp[i<span class="number">-1</span>][k] + log(A[j][x[i]]) + log(B[k][j])   <span class="comment"># 计算每个路径的值</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> score &gt; dp[i][j]:</span><br><span class="line">                    dp[i][j] = score   <span class="comment"># 获取最优值,填到dp中</span></span><br><span class="line">                    ptr[i][j] = k   <span class="comment"># 记录最优值路径</span></span><br><span class="line">                                </span><br><span class="line">    best_seq = [<span class="number">0</span>]*T</span><br><span class="line">    best_seq[T<span class="number">-1</span>] = np.argmax(dp[T<span class="number">-1</span>])  <span class="comment"># 求出最后一个单词 的最大可能性 的词性 的下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(T<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        best_seq[i] = ptr[i+<span class="number">1</span>][best_seq[i+<span class="number">1</span>]]   <span class="comment"># 获取被预测句子的每个词的最优词性的id</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(best_seq)):</span><br><span class="line">        print(id2tag[best_seq[i]])   <span class="comment"># 将最优词性的id转为对应的词性</span></span><br></pre></td></tr></table></figure>



<h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4: 测试"></a>4: 测试</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="string">"Social Security number , passport number and details about the services provided for the payment"</span></span><br><span class="line">viterbi(x, pi, A, B)</span><br></pre></td></tr></table></figure>



<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name">btn</span> #, 文本 &amp; 标题,, 标题 %&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>词性标注</tag>
        <tag>自然语言处理</tag>
        <tag>NLP</tag>
        <tag>viterbi</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：1:基础</title>
    <url>/2018/04/02/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%92%8CPython%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="一、计算机基础"><a href="#一、计算机基础" class="headerlink" title="一、计算机基础"></a>一、计算机基础</h1><h3 id="1-1、进制"><a href="#1-1、进制" class="headerlink" title="1.1、进制"></a>1.1、进制</h3><p>计算机中的数字有四种存在形式，分别是：十进制、二进制、八进制和十六进制</p>
<h5 id="1-1-1、十进制"><a href="#1-1-1、十进制" class="headerlink" title="1.1.1、十进制"></a>1.1.1、十进制</h5><p>1.基数：0-9<br>2.进位：逢10进1<br>3.位权：例：123 = 3*10^0 + 2*10^1 +1*10^2，其中10^x就是这个十进制数的权位<br>4.在Python中的表示方式：十进制数在Python中可直接书写<br>5.将其他进制的数字转换为十进制的方法：直接用输出函数：print()<br>例：<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDAxMDA3Ni1mMjdhZTcwZWRiNGZkN2FjLnBuZw?x-oss-process=image/format,png" alt="用print输出可将其他进制转换为十进制"></p>
<h5 id="1-1-2、二进制"><a href="#1-1-2、二进制" class="headerlink" title="1.1.2、二进制"></a>1.1.2、二进制</h5><p>1.基数：0-1<br>2.进位：逢2进1<br>3.位权：例：1001011 = 1*2^0 + 1*2^1 + 0*2^2 + 1*2^3 + 0*2^4 + 0*2^5 + 1*2^6，其中2^x就是该数的权位<br>4.在Python中的表示方式：在二进制前加 0b / 0B ；例：0b1001/0B1001<br>5.将其他进制的数字转换为二进制的方法：bin(其他进制的数值)<br>例：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDAxMDA3Ni1iNWY3MjFlZjBkMDA0Mjg3LnBuZw?x-oss-process=image/format,png" alt="用bin可将其他进制的数值转换为二进制"></p>
<h5 id="1-1-3、八进制"><a href="#1-1-3、八进制" class="headerlink" title="1.1.3、八进制"></a>1.1.3、八进制</h5><p>1.基数：0-7<br>2.进位：逢8进1<br>3.位权：例：167 = 7*8^0 + 6*8^1 + 1*8^2 ，其中8^x就是该数的权位<br>4.在Python中的表示方式：在八进制前加 0o / 0O ；例：0o123/0O123<br>5.将其他进制的数字转换为八进制的方法：oct(其他进制的数值)<br>例：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDAxMDA3Ni1iNGY4MDBlMGNmNTI2MzI1LnBuZw?x-oss-process=image/format,png" alt="用oct可将其他进制的数值转换为八进制"></p>
<h5 id="1-1-4、十六进制"><a href="#1-1-4、十六进制" class="headerlink" title="1.1.4、十六进制"></a>1.1.4、十六进制</h5><p>1.基数：0，1，2，3，4，5，6，7，8，9，a(10)，b(11)，c(12)，d(13)，e(14)，f(15)<br>2.进位：逢16进1<br>3.位权：例：ef3d = d*16^0 + 3*16^1 + f*16^2 + e*16^3，其中16^x就是该数的权位<br>4.在Python中的表示方式：在十六进制前加 0x / 0X ；例：0xef3d / 0Xef3d<br>5.将其他进制的数字转换为十六进制的方法：hex(其他进制的数值)<br>例<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDAxMDA3Ni03MTc3MDc4Y2IxZDg2MTBjLnBuZw?x-oss-process=image/format,png" alt="用hex可将其他进制的数值转换为十六进制"></p>
<h5 id="1-1-5、进制之间的手动转换"><a href="#1-1-5、进制之间的手动转换" class="headerlink" title="1.1.5、进制之间的手动转换"></a>1.1.5、进制之间的手动转换</h5><h6 id="1、十进制和其他进制"><a href="#1、十进制和其他进制" class="headerlink" title="1、十进制和其他进制"></a>1、十进制和其他进制</h6><p>①：十进制转其他进制<br>辗转取余法：不断除2/8/16取余，然后从下往上将余数写出来。<br>②：其他进制转换成十进制<br>基数与权位的乘积求和。</p>
<h6 id="2、二进制和其他进制"><a href="#2、二进制和其他进制" class="headerlink" title="2、二进制和其他进制"></a>2、二进制和其他进制</h6><p>①：二转八：将二进制数从低位到高位每三位分开，将每三位转换成十进制，最后得到的既是一个八进制数；<br>例：0b1 011 011 -&gt; 0o133<br>②：二转十六：将二进制数从低位到高位每四位分开，将每四位转换成十进制，如果数值大于10，则用a-f代替相应数值，最后得到的既是一个十六进制数；<br>例：0b101 1011 -&gt; 0x5b</p>
<h6 id="3、八转二、十六转二"><a href="#3、八转二、十六转二" class="headerlink" title="3、八转二、十六转二"></a>3、八转二、十六转二</h6><p>①：八转二：将每一位八进制的数转换为三位的二进制数，最后得到相应的二进制数；<br>②：十六转二：将每一位十六进制的数转换为四位的二进制数，最后得到相应的二进制数。</p>
<br>

<h3 id="1-2、计算机存储"><a href="#1-2、计算机存储" class="headerlink" title="1.2、计算机存储"></a>1.2、计算机存储</h3><h5 id="1-2-1、存储单位"><a href="#1-2-1、存储单位" class="headerlink" title="1.2.1、存储单位"></a>1.2.1、存储单位</h5><ul>
<li>在计算机内最小的存储单位是 ： bit（位）</li>
<li>在计算机内使用内存的最小单位是：bytes（字节）</li>
<li>其中：1bytes = 8bit</li>
<li>其他单位换算：<br>1KB = 1024 bytes<br>1MB = 1024KB<br>1GB = 1024MB<br>1TB = 1024GB<br>1PB = 1024TB</li>
</ul>
<h5 id="1-2-2、计算机存储原理"><a href="#1-2-2、计算机存储原理" class="headerlink" title="1.2.2、计算机存储原理"></a>1.2.2、计算机存储原理</h5><ul>
<li>在计算机中，数据有原码，反码，补码三种形态。而数据的存储都是以补码的方式进行存储的，原因是计算机只有加法器，负数在进行运算时不能得出正确的结果，所以只能通过存储补码的方式解决这个问题。</li>
</ul>
<h6 id="1-2-2-1、原码"><a href="#1-2-2-1、原码" class="headerlink" title="1.2.2.1、原码"></a>1.2.2.1、原码</h6><ul>
<li>原码 = 符号位 + 数字对应的二进制</li>
<li>符号位（只有一位）：0代表正数，1代表负数<br>例：<br>12的二进制：1100 -&gt; 00001100(原)，其中最高位的0是符号位，代表正数。</li>
<li>12的原码是：10001100，其中最高位的1是符号位，代表负数。</li>
</ul>
<p><strong>注：由于计算机中使用内存时调用的最小存储单位是一个字节，8位，所以原码、反码和补码的位数都是8的倍数。</strong></p>
<h6 id="1-2-2-2、反码"><a href="#1-2-2-2、反码" class="headerlink" title="1.2.2.2、反码"></a>1.2.2.2、反码</h6><ul>
<li>原码的符号位不变，其余位全部取反，其结果就是原码的反码<br>例：-12  -&gt;  10001100（原码）  -&gt;   11110011（反码）</li>
</ul>
<h6 id="1-2-2-3、补码"><a href="#1-2-2-3、补码" class="headerlink" title="1.2.2.3、补码"></a>1.2.2.3、补码</h6><ul>
<li>补码 = 反码 + 1<br>例：-12  -&gt;  10001100（原码）  -&gt;   11110011（反码）  -&gt;   11110100（补码）</li>
</ul>
<p><strong><em>注：正数的原码、反码和补码相同</em></strong><br><br><br><br></p>
<hr>
<h1 id="二、Python基础"><a href="#二、Python基础" class="headerlink" title="二、Python基础"></a>二、Python基础</h1><h3 id="2-1、Python编程中常用的快捷键"><a href="#2-1、Python编程中常用的快捷键" class="headerlink" title="2.1、Python编程中常用的快捷键"></a>2.1、Python编程中常用的快捷键</h3><table>
<thead>
<tr>
<th>序号</th>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Ctrl+/</td>
<td>添加注释或取消注释</td>
</tr>
<tr>
<td>2</td>
<td>Ctrl+S</td>
<td>保存</td>
</tr>
<tr>
<td>3</td>
<td>Ctrl+C</td>
<td>复制</td>
</tr>
<tr>
<td>4</td>
<td>Ctrl+V</td>
<td>粘贴</td>
</tr>
<tr>
<td>5</td>
<td>Ctrl+Z</td>
<td>撤销</td>
</tr>
<tr>
<td>6</td>
<td>Ctrl+X</td>
<td>剪切</td>
</tr>
<tr>
<td>7</td>
<td>Ctrl+F</td>
<td>查找</td>
</tr>
<tr>
<td>8</td>
<td>Ctrl+Shift+Z</td>
<td>反撤销</td>
</tr>
<tr>
<td>9</td>
<td>Ctrl+R</td>
<td>替换</td>
</tr>
<tr>
<td>10</td>
<td>Ctrl+D</td>
<td>复制整行到下一行</td>
</tr>
<tr>
<td>11</td>
<td>Ctrl+A</td>
<td>全选</td>
</tr>
</tbody></table>
<p>其他快捷操作：<br>①：选区多行代码：先用鼠标点击选区开头，找到选区结尾，按住Shift键再点击选区结尾；<br>②：同时操作多行代码：按住Alt键，用鼠标点击多行代码需要操作的位置即可。</p>
<h3 id="2-2、Python基础语法"><a href="#2-2、Python基础语法" class="headerlink" title="2.2、Python基础语法"></a>2.2、Python基础语法</h3><p><strong>（一）、注释</strong></p>
<ul>
<li>注释是在编程中不参与编译执行的文字，用来对代码进行解释说明<br>1.单行整行注释：在该行代码的开头加  <strong>#</strong> 即可<br>2.单行部分注释：在需要注释部分的代码前加  <strong>#</strong> 即可<br>3.多行注释：在多行注释前后加三个单引号或者三个双引号即可<br>（<strong>注：单引号或双引号都是输入法为英文状态时的符号</strong>）</li>
</ul>
<p><strong>（二）、语句</strong></p>
<ul>
<li>一条语句占一行，一条语句结束后可以不加分号，如果多条语句在同一行，则语句之间必须加分号<br>例：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'helllo world'</span>)</span><br><span class="line">print(<span class="string">'你好'</span>)</span><br><span class="line">print(<span class="string">'helllo world'</span>);print(<span class="string">'你好'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>（三）、缩进</strong></p>
<ul>
<li>一条语句开头不能随便缩进或空格，需要缩进的地方则必须缩进</li>
</ul>
<p><strong><em>小提示：IndentationError   &gt;&gt;&gt;   缩进错误</em></strong></p>
<p><strong>（四）、标识符</strong></p>
<ul>
<li>标识符是专门用来给函数、类和变量命名的</li>
<li>标识符的基本要求：<br> 1、标识符由数字、字母和下划线组成<br> 2、数字不能开头</li>
</ul>
<p><strong>（五）、关键字</strong></p>
<ul>
<li>有特殊功能或者特殊意义的标识符就是关键字，又叫保留字</li>
<li>常见关键字：[‘False’, ‘None’, ‘True’, ‘and’, ‘as’, ‘assert’, ‘async’, ‘await’, break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘nonlocal’, ‘not’,’or’, ‘pass’, ‘raise’, ‘return’, ‘try’,’while’, ‘with’, ‘yield’]</li>
</ul>
<p><strong>（六）、常用数据</strong><br>1.数字数据：用来表示大小，在程序中直接写<br>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">100</span>)</span><br><span class="line">print(<span class="number">2</span>+<span class="number">5j</span>)</span><br></pre></td></tr></table></figure>
<p>2.文本数据：文本信息对应的数据，在程序中需要用双引号或者单引号引起来<br>&emsp;<strong>电话号，身份证号，门牌号等是文本信息</strong><br>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'木_Python'</span>)</span><br><span class="line">print(<span class="string">'13888888888'</span>)</span><br></pre></td></tr></table></figure>
<p>3.布尔数据：用True表示真/肯定，用False表示假/否定，程序中只有True和False两种<br><strong><em>所有类型的数据都能转换成布尔值，所有为数字如果为0，所有序列如果为空则都会转换成False，其他都为True</em></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="literal">True</span>)</span><br><span class="line">print(<span class="literal">False</span>)</span><br><span class="line">print(bool(<span class="number">0</span>), bool(<span class="number">0.0</span>), bool(<span class="string">''</span>), bool([]), bool(()), bool(<span class="literal">None</span>))</span><br><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">if</span> list1:</span><br><span class="line">    print(<span class="string">'==='</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> list1:</span><br><span class="line">    print(<span class="string">'+++'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>（七）、常见数据类型</strong><br>1.数字类型：整型（int）、浮点型（float）、复数<br>2.文本类型：字符串（str）<br>3.布尔类型（bool）：True和False<br>4.其他：列表（list）、字典（dict）、元组（tuple）、集合（set）、迭代器（iter）、生成器、函数（function）<br><strong><em>&emsp;type（数据） - 获取数据类型</em></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(type(<span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<p><strong>（八）、输入和输出</strong><br><strong><em>1.输出：print</em></strong><br>print(数据) - 在控制台直接打印数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">10</span>)</span><br><span class="line">print(<span class="string">'aed'</span>)</span><br></pre></td></tr></table></figure>
<p>print(表达式) - 打印表达式的结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">10</span>+<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>print(表达式1，表达式2，表达式3，…) - 在一行打印多个表达式的结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'你好'</span>,<span class="number">123</span>,<span class="string">'1+2'</span>)</span><br></pre></td></tr></table></figure>
<p>1.定制换行:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'hello world'</span>,end= <span class="string">'你好,世界'</span>)</span><br><span class="line">print(<span class="string">'啥'</span>)</span><br></pre></td></tr></table></figure>
<p>2.定制分隔:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,sep=<span class="string">'+'</span>)</span><br></pre></td></tr></table></figure>
<br>

<p><strong><em>2.输入：input</em></strong><br>input(提示输入信息)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = input(<span class="string">'请输入年龄：'</span>)</span><br><span class="line">print(<span class="string">'输入的年纪是：'</span>,age,type(age))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：10:函数进阶</title>
    <url>/2018/06/20/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.10%20%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="一-函数返回值"><a href="#一-函数返回值" class="headerlink" title="一.函数返回值"></a>一.函数返回值</h1><ul>
<li>1.返回值的作用:将函数里面的数据传到函数外(在函数里的打印只能看不能操作)</li>
<li>2.怎么确定需不需要返回值:看函数的功能完成后会不会产生新的数据</li>
<li>3.怎么确定函数的返回值:函数声明的时候return后面的值就是函数的返回值;如果没有return,函数的返回值就是None</li>
</ul>
<p><strong>return是关键字;只能出现在函数体中</strong><br>&emsp;作用:①.确定函数的返回值<br>&emsp;&emsp;&emsp;②.结束函数(执行函数体的时候若遇到return函数直接结束,同时将return后面的值作为函数的额返回值)</p>
<ul>
<li>4.怎么获取函数的返回值:函数调用表达式就是函数的返回值<pre><code>函数调用表达式:函数调用语句(普通数据能做的事,它都能做)</code></pre></li>
</ul>
<br>

<hr>
<h1 id="二-函数的调用"><a href="#二-函数的调用" class="headerlink" title="二.函数的调用"></a>二.函数的调用</h1><h2 id="1-函数调用过程"><a href="#1-函数调用过程" class="headerlink" title="1.函数调用过程:"></a>1.函数调用过程:</h2><p>①.回到函数声明的位置<br>②.传参 - 保证每个参数都有值<br>③.执行函数体<br>④.执行完函数体确认返回值:若遇到return,return后面的值就是返回值;若没有遇到,返回值就是None<br>⑤.回到函数调用的位置(函数表达式的值就是返回值)  </p>
<h2 id="2-内存的变化"><a href="#2-内存的变化" class="headerlink" title="2.内存的变化:"></a>2.内存的变化:</h2><p>函数的调用过程事一个压栈的过程(系统会自动在栈区间开辟一个专用的内存区域,专门用来保存在函数内声明的变量和产生的数据(形参也是函数内的))    当函数调用结束的时候,这个内存区域会自动销毁(销毁前会将返回值送出)</p>
<br>

<hr>
<h1 id="三-变量的作用域"><a href="#三-变量的作用域" class="headerlink" title="三.变量的作用域"></a>三.变量的作用域</h1><h2 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1).全局变量"></a>1).全局变量</h2><p>没有生命在函数中或者类中的变量都是全局变量<br>作用域:全局变量从声明开始到文件结束任何地方都可以用</p>
<h2 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2).局部变量"></a>2).局部变量</h2><p>在函数内声明的变量就是局部变量;<br>作用域:从声明开始到函数结束可以使用(形参是声明在函数中的局部变量)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#a是全局变量</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="comment"># 循环内声明的变量也是全局变量(b和c)</span></span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    c = <span class="number">100</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 在循环内部可以用</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在函数中可以用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'函数中:'</span>, a)</span><br></pre></td></tr></table></figure>

<p><strong>1.global</strong><br>若要在函数内改变全局变量的值,要先用global进行说明在函数中若要声明一个全局变量,也要在变量前加global<br>语法:global 变量名</p>
<p><strong>2.nonlocal</strong><br>使用方法:在函数中给变量赋值前加:nonlocal 变量名<br>作用:在局部的局部中修改局部变量的值</p>
<br>

<hr>
<h1 id="四-匿名函数"><a href="#四-匿名函数" class="headerlink" title="四.匿名函数"></a>四.匿名函数</h1><p>匿名函数还是函数,除了声明的语法和类型说明以外,其他语法基本都适用匿名函数</p>
<h2 id="1-声明匿名函数"><a href="#1-声明匿名函数" class="headerlink" title="1.声明匿名函数"></a>1.声明匿名函数</h2><p><strong>变量(函数名) = lambda 参数列表:返回值<br>&emsp;def (参数列表):<br>&emsp;return 返回值</strong></p>
<h2 id="2-说明"><a href="#2-说明" class="headerlink" title="2.说明:"></a>2.说明:</h2><p>lambda - 关键字,固定写法<br>参数列表 - 形参:参数名1,参数名2,…<br>:(冒号) - 固定写法<br>返回值 - 相当于普通函数中函数体中的return语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用匿名函数求两个数的和</span></span><br><span class="line">func1 = <span class="keyword">lambda</span> num1, num2: num1 + num2</span><br><span class="line"><span class="comment"># 练习:写一个函数判断指定的年是否是闰年</span></span><br><span class="line">diy_year = <span class="keyword">lambda</span> year: year % <span class="number">400</span> == <span class="number">0</span> <span class="keyword">or</span> (year % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> year % <span class="number">100</span> != <span class="number">0</span>)</span><br><span class="line">print(diy_year(<span class="number">2008</span>))</span><br></pre></td></tr></table></figure>

<br>

<hr>
<h1 id="五-递归函数"><a href="#五-递归函数" class="headerlink" title="五.递归函数"></a>五.递归函数</h1><h2 id="1-什么是递归函数"><a href="#1-什么是递归函数" class="headerlink" title="1.什么是递归函数"></a>1.什么是递归函数</h2><p>声明函数的时候调用函数本身<br>递归可以实现循环效果,除了死循环,其他的循环递归都可以实现</p>
<h2 id="2-递归怎么用"><a href="#2-递归怎么用" class="headerlink" title="2.递归怎么用"></a>2.递归怎么用</h2><p><strong>使用递归的方法:<br>1).设置临界值 - 循环结束的条件(保证函数结束)<br>2).找关系 - 找f(n)和f(n-1)的关系(上一次循环和下一次循环的关系)<br>3).假设函数的功能已经实现,通过f(n-1)去实现f(n)的功能</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写一个递归函数,计算1+2+3+...+n</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diy_sum</span><span class="params">(n)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> diy_sum(n<span class="number">-1</span>) + n</span><br><span class="line"></span><br><span class="line">print(diy_sum(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写一个递归函数,计算斐波那契额数列的第n个数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diy_series</span><span class="params">(n)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> diy_series(n<span class="number">-1</span>) + diy_series(n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line">print(diy_series(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习:</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">n = 4</span></span><br><span class="line"><span class="string">*</span></span><br><span class="line"><span class="string">**</span></span><br><span class="line"><span class="string">***</span></span><br><span class="line"><span class="string">****</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">n = 3</span></span><br><span class="line"><span class="string">*</span></span><br><span class="line"><span class="string">**</span></span><br><span class="line"><span class="string">***</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diy_p</span><span class="params">(n)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">'*'</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  diy_p(n<span class="number">-1</span>)</span><br><span class="line">  print(n * <span class="string">'*'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：11:高阶函数</title>
    <url>/2018/06/26/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.11%20%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="一-实参高阶函数"><a href="#一-实参高阶函数" class="headerlink" title="一.实参高阶函数"></a>一.实参高阶函数</h1><h2 id="1-函数作为变量使用"><a href="#1-函数作为变量使用" class="headerlink" title="1.函数作为变量使用"></a>1.函数作为变量使用</h2><p>python中声明函数就是声明一个类型是function的变量,变量名就是函数名<br>普通变量能做的函数都能做:</p>
<ul>
<li>1).一个变量可以给另一个变量赋值,函数也可以赋值给一个变量</li>
<li>2).变量的值可以修改,函数作为变量并被赋值后,函数原本的功能就消失了</li>
<li>3).变量作为序列中的元素,函数也行</li>
<li>4).变量作为函数的参数,函数也行</li>
</ul>
<p><strong>将函数作为另一个函数的参数,这就是实参高阶函数</strong></p>
<h2 id="2-系统的实参高阶函数"><a href="#2-系统的实参高阶函数" class="headerlink" title="2.系统的实参高阶函数"></a>2.系统的实参高阶函数</h2><p><em>列表.sort(); sorted(); max(); min()   -&gt;   都有一个参数key,要求是一个函数</em></p>
<p><strong>例:列表.sort()排序函数</strong></p>
<p>sort()括号里面有key函数和revers,key函数确定了排序的规则,revers=True时倒序,revers=False时正序</p>
<h3 id="1-排序函数-参数key要求是一个函数-作用是用来定制拍寻的规则"><a href="#1-排序函数-参数key要求是一个函数-作用是用来定制拍寻的规则" class="headerlink" title="1).排序函数;参数key要求是一个函数,作用是用来定制拍寻的规则"></a>1).排序函数;参数key要求是一个函数,作用是用来定制拍寻的规则</h3><p>key的要求:<br>①:key是一个函数<br>②:函数中有且只有一个参数,这个参数指向的是序列中的每个元素<br>③:函数需要一个返回值,这个返回值就是排序的时候比较大小的对象</p>
<h3 id="2-最大值函数"><a href="#2-最大值函数" class="headerlink" title="2).最大值函数:"></a>2).最大值函数:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 练习:进下面的列表按个位数的大小排序</span></span><br><span class="line">nums = [<span class="number">100</span>, <span class="number">39</span>, <span class="number">51</span>, <span class="number">62</span>, <span class="number">58</span>]</span><br><span class="line">nums.sort(key=<span class="keyword">lambda</span> item: item % <span class="number">10</span>)</span><br><span class="line">print(nums)</span><br><span class="line">print(max(nums, key = <span class="keyword">lambda</span> item: item % <span class="number">10</span>))</span><br><span class="line"><span class="comment"># 练习:将学生按成绩排序</span></span><br><span class="line">students = [</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'小明'</span>, <span class="string">'age'</span>: <span class="number">18</span>, <span class="string">'grade'</span>: <span class="number">90</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'小花'</span>, <span class="string">'age'</span>: <span class="number">28</span>, <span class="string">'grade'</span>: <span class="number">59</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'狗子'</span>, <span class="string">'age'</span>: <span class="number">8</span>, <span class="string">'grade'</span>: <span class="number">87</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'大黄'</span>, <span class="string">'age'</span>: <span class="number">45</span>, <span class="string">'grade'</span>: <span class="number">98</span>&#125;</span><br><span class="line">]</span><br><span class="line">students.sort(revers=<span class="literal">True</span>, key=<span class="keyword">lambda</span> item: item[<span class="string">'grade'</span>]</span><br><span class="line">print(students)</span><br><span class="line">print(max(students, key = <span class="keyword">lambda</span> item: item[<span class="string">'grade'</span>]</span><br><span class="line"><span class="comment"># 按学生年龄和分数的和排序</span></span><br><span class="line">students.sort(key = <span class="keyword">lambda</span> itme: item[<span class="string">'age'</span>] + item[<span class="string">'grade'</span>]</span><br><span class="line">print(students)</span><br><span class="line">print(max(students,key = <span class="keyword">lambda</span> item: item[<span class="string">'age'</span>] + item[<span class="string">'grade'</span>]</span><br></pre></td></tr></table></figure>

<br>

<hr>
<h1 id="二-返回值高阶函数"><a href="#二-返回值高阶函数" class="headerlink" title="二.返回值高阶函数"></a>二.返回值高阶函数</h1><p><strong>1.函数作为函数的返回值   -   返回值高阶函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#func1就是一个返回值高阶函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'函数2'</span>)</span><br><span class="line">    <span class="keyword">return</span> func2</span><br></pre></td></tr></table></figure>

<p><strong>2.闭包 - 函数1中声明了函数2 ,函数2 中使用了函数1中的数据,则函数1就是一个闭包<br>特点:闭包函数中的数据不会因为函数调用结束而销毁</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    print(id(a))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func4</span><span class="params">()</span>:</span></span><br><span class="line">        print(a)</span><br><span class="line">        print(id(a))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func4</span><br></pre></td></tr></table></figure>

<h3 id="面试题练习"><a href="#面试题练习" class="headerlink" title="面试题练习:"></a>面试题练习:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#不执行以下代码,问以下代码的执行结果</span></span><br><span class="line">list1 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    list1.append(<span class="keyword">lambda</span> x: x*i)</span><br><span class="line"></span><br><span class="line">print(list1[<span class="number">1</span>](<span class="number">2</span>), list1[<span class="number">2</span>](<span class="number">2</span>), list1[<span class="number">3</span>](<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(seq=[])</span>:</span></span><br><span class="line">    seq.append(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> seq</span><br><span class="line">print(func2())</span><br><span class="line">print(func2())</span><br></pre></td></tr></table></figure>

<br>

<hr>
<h1 id="三-装饰器"><a href="#三-装饰器" class="headerlink" title="三.装饰器"></a>三.装饰器</h1><h2 id="1-什么是装饰器"><a href="#1-什么是装饰器" class="headerlink" title="1.什么是装饰器"></a>1.什么是装饰器</h2><p><strong>装饰器本质就是一个函数   装饰器 = 返回值高阶函数+实参高阶函数+糖语法</strong></p>
<p>装饰器是python的三大神器之一：装饰器、迭代器、生成器</p>
<p><strong>装饰器的作用:给已经写好的函数添加新的功能</strong></p>
<h2 id="2-用函数给函数添加功能的方法"><a href="#2-用函数给函数添加功能的方法" class="headerlink" title="2.用函数给函数添加功能的方法"></a>2.用函数给函数添加功能的方法</h2><p><strong>方法一</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ①:给不需要参数的函数添加功能</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_time</span><span class="params">(fn)</span>:</span></span><br><span class="line">    star = time.time()</span><br><span class="line">    fn</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">'函数执行时间:%fs'</span> % (end - star))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ②:给需要参数的函数添加功能</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_time2</span><span class="params">(fn, *args, **kwargs)</span>:</span></span><br><span class="line">    star = time.time()</span><br><span class="line">    fn(*args, **kwargs)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">'函数执行时间:%fs'</span> % (end - star))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'======'</span>)</span><br><span class="line">    print(<span class="string">'++++++'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'你好,python'</span>)</span><br><span class="line">    print(<span class="string">'你不好,python'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    print(<span class="string">'%d+%d=%d'</span> % (x, y, x+y))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(add_time(func1()))</span><br><span class="line">print(add_time(func2()))</span><br><span class="line">print(add_time2(func3, <span class="number">10</span>, <span class="number">20</span>))</span><br></pre></td></tr></table></figure>

<p><strong>方法二(装饰器)</strong></p>
<p><strong>无参装饰器函数:<br>def 函数名1(参数1):<br>&emsp;def 函数名2(*args, **kwargs):<br>&emsp;&emsp;参数1(*args, **kwargs)<br>&emsp;新功能对应的代码<br>&emsp;return 函数名2</strong></p>
<p>说明:<br>函数名1        -        装饰器的名称;需要添加的共嗯名称<br>参数1          -        需要添加功能的函数,一般命名为fn<br>函数名2        -        随便命名,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加统计函数执行时间的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_time3</span><span class="params">(fn)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        star = time.time()</span><br><span class="line">        re =fn(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(end - star)</span><br><span class="line">        <span class="keyword">return</span> re</span><br><span class="line">    <span class="keyword">return</span> test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange_hex</span><span class="params">(fn)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        re = fn(*args, **kwargs)</span><br><span class="line">        <span class="keyword">if</span> type(re) == int:</span><br><span class="line">            <span class="keyword">return</span> hex(re)</span><br><span class="line">        <span class="keyword">return</span> re</span><br><span class="line">    <span class="keyword">return</span> test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@exchange_hex</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diy_sum</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(diy_sum(<span class="number">10</span>, <span class="number">20</span>))</span><br></pre></td></tr></table></figure>

<br>

<hr>
<h1 id="四-迭代器"><a href="#四-迭代器" class="headerlink" title="四.迭代器"></a>四.迭代器</h1><h2 id="1-什么是迭代器-iter"><a href="#1-什么是迭代器-iter" class="headerlink" title="1.什么是迭代器(iter)"></a>1.什么是迭代器(iter)</h2><p>迭代器也是python提供的容器型数据类型<br>迭代器存储数据的特点:<br>    ①:一个迭代器能存多个数据<br>    ②:若要获取或查看数据必须要从迭代器中取出<br>    ③:取出来的数据不能再添加到迭代器</p>
<h2 id="2-将数据存入迭代器"><a href="#2-将数据存入迭代器" class="headerlink" title="2.将数据存入迭代器"></a>2.将数据存入迭代器</h2><p>①:将其他序列转换成迭代器<br>②:创建一个生成器</p>
<h2 id="3-获取迭代器中的元素"><a href="#3-获取迭代器中的元素" class="headerlink" title="3.获取迭代器中的元素"></a>3.获取迭代器中的元素</h2><p>迭代器中的元素只要取出(任何方式)那这个元素在迭代器中就不存在了</p>
<h3 id="1-获取单个元素"><a href="#1-获取单个元素" class="headerlink" title="1).获取单个元素"></a>1).获取单个元素</h3><p><strong>next(迭代器)   -   取出迭代器中最上面的元素</strong><br>print(next(iter1))<br>print(next(iter1))<br>print(next(iter1))</p>
<h3 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2).遍历"></a>2).遍历</h3><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">for <span class="meta">x</span> <span class="meta">in</span> iter2:</span><br><span class="line">    p<span class="meta">rint(</span><span class="string">'x:'</span>, <span class="meta">x</span>)</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：12:生成器和模块</title>
    <url>/2018/07/08/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.12%20%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="一-生成器"><a href="#一-生成器" class="headerlink" title="一. 生成器"></a>一. 生成器</h1><h2 id="1-生成器"><a href="#1-生成器" class="headerlink" title="1.生成器"></a>1.生成器</h2><ul>
<li>生成器也是迭代器的一种;</li>
<li>生成器作为容器它保存的不是数据,而是产生数据的算法</li>
</ul>
<h2 id="2-创建生成器"><a href="#2-创建生成器" class="headerlink" title="2.创建生成器"></a>2.创建生成器</h2><ul>
<li>调用带有yield关键字的函数,就可以得到一个生成器</li>
</ul>
<p><strong>注:函数中只要有yield,不管会不会遇到(执行),则调用该函数,函数体都不会执行,并且得到一个生成器</strong></p>
<h2 id="3-生成器产生数据"><a href="#3-生成器产生数据" class="headerlink" title="3.生成器产生数据"></a>3.生成器产生数据</h2><ul>
<li>一个生成器能产生多少数据和什么数据,看执行完生成器关联的函数在执行完会遇到几次yield,</li>
<li>能遇到几次yield就产生几个数据;每次遇到yield,后面的数据就是对应的元素</li>
</ul>
<h2 id="4-生成器产生数据的规律"><a href="#4-生成器产生数据的规律" class="headerlink" title="4.生成器产生数据的规律"></a>4.生成器产生数据的规律</h2><ul>
<li>获取第一个元素的时候,从函数的第一条语句开始执行,遇到第一个yield停止,并且将yield后面的值作为当前获取到的元素;</li>
<li>获取下一个元素的时候,接着上一个结束的地方执行,遇到下一个yield停止,并且将yield后面的值作为当前获取到的元素;</li>
<li>以此类推…</li>
<li>当函数体后面没有yield时,说明该生成器的数据已经被取完了,再次运行将会报错</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'======'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    print(<span class="string">'++++++'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">10</span></span><br><span class="line">    print(<span class="string">'******'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">gen2 = func3()</span><br><span class="line">print(next(gen2))</span><br><span class="line">print(next(gen2))</span><br><span class="line">print(next(gen2))</span><br><span class="line">print(next(gen2))   <span class="comment"># 元素取完后报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习:写一个生成器能产生一个班所有学生的学号</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">students_num</span><span class="params">(n)</span>:</span></span><br><span class="line">    length = len(str(n))</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">yield</span> str(num).zfill(length)</span><br><span class="line"></span><br><span class="line">nums = students_num(<span class="number">50</span>)</span><br><span class="line"><span class="keyword">for</span> num1 <span class="keyword">in</span> nums:</span><br><span class="line">    print(num1)</span><br></pre></td></tr></table></figure>

<h2 id="5-生成式"><a href="#5-生成式" class="headerlink" title="5.生成式"></a>5.生成式</h2><h3 id="1-生成式就是生成器-就像函数和匿名函数-只是写法简洁"><a href="#1-生成式就是生成器-就像函数和匿名函数-只是写法简洁" class="headerlink" title="1) 生成式就是生成器;就像函数和匿名函数,只是写法简洁"></a>1) 生成式就是生成器;就像函数和匿名函数,只是写法简洁</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1)语法①:</span></span><br><span class="line"><span class="string">生成器 = (表达式 for 变量 in 序列)</span></span><br><span class="line"><span class="string"> 展开:</span></span><br><span class="line"><span class="string"> def 函数名():</span></span><br><span class="line"><span class="string">    for 变量 in 序列:</span></span><br><span class="line"><span class="string">        yield 表达式</span></span><br><span class="line"><span class="string">生成器 = 函数名()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string"> 语法②:</span></span><br><span class="line"><span class="string"> 生成器 = (表达式 for 变量 in 序列 if 条件语句)</span></span><br><span class="line"><span class="string">  展开:</span></span><br><span class="line"><span class="string"> def 函数名():</span></span><br><span class="line"><span class="string">    for 变量 in 序列:</span></span><br><span class="line"><span class="string">        if 条件语句:</span></span><br><span class="line"><span class="string">            yield 表达式</span></span><br><span class="line"><span class="string">生成器 = 函数名()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">语法③:</span></span><br><span class="line"><span class="string"> 生成器 = (表达式 for 变量1 in 序列1 for 变量2 in 序列2)</span></span><br><span class="line"><span class="string">  展开:</span></span><br><span class="line"><span class="string"> def 函数名():</span></span><br><span class="line"><span class="string">    for 变量1 in 序列1:</span></span><br><span class="line"><span class="string">        for 变量2 in 序列2:</span></span><br><span class="line"><span class="string">            yield 表达式</span></span><br><span class="line"><span class="string">生成器 = 函数名()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例:</span></span><br><span class="line">gen1 = (num <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line"></span><br><span class="line">gen4 = (x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-列表生成式"><a href="#2-列表生成式" class="headerlink" title="2) 列表生成式"></a>2) 列表生成式</h3><ul>
<li>将上面语法中所有的小括号编程中括号,结果就会变成列表</li>
</ul>
<br>

<hr>
<h1 id="二-模块"><a href="#二-模块" class="headerlink" title="二. 模块"></a>二. 模块</h1><h2 id="1-模块-python中-一个py文件就是一个模块"><a href="#1-模块-python中-一个py文件就是一个模块" class="headerlink" title="1.模块(python中,一个py文件就是一个模块)"></a>1.模块(python中,一个py文件就是一个模块)</h2><h2 id="2-模块间的相互引用-导入模块"><a href="#2-模块间的相互引用-导入模块" class="headerlink" title="2.模块间的相互引用(导入模块)"></a>2.模块间的相互引用(导入模块)</h2><p><strong>若要使用另外一个模块的内容,需要在当前模块中导入相应的模块</strong></p>
<h3 id="1-模块导入方法-导入模块的代码一般放在文件最顶部-系统文件放最前面-第三方在中间-自己写的放最后"><a href="#1-模块导入方法-导入模块的代码一般放在文件最顶部-系统文件放最前面-第三方在中间-自己写的放最后" class="headerlink" title="1) 模块导入方法:(导入模块的代码一般放在文件最顶部, 系统文件放最前面,第三方在中间,自己写的放最后)"></a>1) 模块导入方法:(导入模块的代码一般放在文件最顶部, 系统文件放最前面,第三方在中间,自己写的放最后)</h3><p><strong>①:import 模块名</strong><br>     -   导入后可以使用被导入模块的所有全局变量<br>     -    以 ‘模块名.变量名’ 的方式使用相应模块</p>
<p><strong>②:from 模块名 import 变量名1, 变量名2,…</strong><br>     -    导入后可以使用import后指定的变量<br>     -    使用时直接使用</p>
<p><strong>③:from 模块名 import *</strong><br>    -    导入后可以使用被导入模块的所有全局变量<br>    -    使用时直接使用</p>
<h3 id="2-对模块重命名"><a href="#2-对模块重命名" class="headerlink" title="2) 对模块重命名"></a>2) 对模块重命名</h3><ul>
<li>import 模块名 as 新模块名——&gt;有时候导入的模块名或函数名会与本模块内的一些参数名相同,则在模块中通过新名字来使用导入的模块</li>
<li>也可以通过这种方式对模块中的变量进行重命名</li>
</ul>
<h3 id="3-阻止导入"><a href="#3-阻止导入" class="headerlink" title="3) 阻止导入"></a>3) 阻止导入</h3><ul>
<li>当执行导入模块的代码时,系统会执行被导入模块的所有代码,为了防止执行所有代码造成的不必要消耗,需要用到阻止导入</li>
<li><strong>阻止导入:</strong>将被导入模块内不需要被调用的代码放到 <strong>if <strong>name__ == ‘</strong>main__‘</strong> 语句中即可;在该if 语句中的代码不能被其他模块引用,但在本模块内可以运行.</li>
<li><strong>阻止原理:</strong>模块在创建的时候,系统会为模块添加 __name__ 属性,用来保存该模块的名字; __name__ 默认是该文件的文件名,当直接运行该模块时, __name__ 会变成 __main__,此时if语句成立,执行后面的代码</li>
</ul>
<br>

<hr>
<h1 id="三-包-包是用来管理模块的"><a href="#三-包-包是用来管理模块的" class="headerlink" title="三. 包(包是用来管理模块的)"></a>三. 包(包是用来管理模块的)</h1><p><strong>包是包含 __init__.py文件的文件夹</strong></p>
<h2 id="1-导入包内的模块"><a href="#1-导入包内的模块" class="headerlink" title="1 导入包内的模块"></a>1 导入包内的模块</h2><p><strong>①:import 包.模块   (可用as重命名)</strong><br>   包.模块.调用的代码名</p>
<p><strong>②:from 包 import 模块1, 模块2, …</strong><br>   模块.调用的代码名</p>
<p><strong>③:from 包.模块 import 调用的代码名</strong><br><strong>④:from 包.模块 import 变量</strong></p>
<h2 id="2-init文件"><a href="#2-init文件" class="headerlink" title="2.init文件"></a>2.init文件</h2><ul>
<li>导入包后,原始状态的包只会执行 __init__ 文件,需要在 __init__ 文件内导入包内的其他模块.</li>
</ul>
<br>

<hr>
<h1 id="四-hashlib模块"><a href="#四-hashlib模块" class="headerlink" title="四. hashlib模块"></a>四. hashlib模块</h1><h2 id="1-hashlib"><a href="#1-hashlib" class="headerlink" title="1.hashlib"></a>1.hashlib</h2><ul>
<li>hashlib是python提供的用哈希算法进行加密的库</li>
<li>哈希算法又叫离散算法,<strong>主要包含MD5,sha两类算法</strong></li>
</ul>
<h2 id="2-哈希算法加密特点"><a href="#2-哈希算法加密特点" class="headerlink" title="2.哈希算法加密特点"></a>2.哈希算法加密特点</h2><p><strong>1).加密后的的密文(摘要)是不可逆的<br>2).相同的数据通过通过相同的算法加密后的密文是相同的<br>3).不同长度的数据通过相同的算法加密后的密文长度是相同的</strong></p>
<h2 id="3-产生密文-摘要-的过程-如何加密"><a href="#3-产生密文-摘要-的过程-如何加密" class="headerlink" title="3.产生密文(摘要)的过程 (如何加密)"></a>3.产生密文(摘要)的过程 (如何加密)</h2><p><strong>1).创建hashlib对象:  hashlib.算法名()<br>2).添加需要加密的数据:  哈希对象.update(数据(必须是二进制数据))<br>3).生成密文(摘要):  哈希对象.hexdigest()</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hash = hashlib.md5()</span><br><span class="line">pw = <span class="string">'123456'</span></span><br><span class="line">hash.update(pw.encode())</span><br><span class="line">result = hash.hexdigest()</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<br>

<p><strong>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 知识扩展</strong></p>
<p>bytes是二进制的数据类型<br><strong>1.字符串转二进制</strong><br>①:bytes(字符串, encoding=’utf-8’)<br>②:字符串.encode()</p>
<p><strong>2.二进制转字符串</strong><br>①:str(二进制,encoding=’utf-8’)<br>②:二进制.decode(encoding=’utf-8’)</p>
]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：13:文件操作</title>
    <url>/2018/07/11/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.13%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="一-文件操作"><a href="#一-文件操作" class="headerlink" title="一 . 文件操作"></a>一 . 文件操作</h1><h2 id="1-数据的存储"><a href="#1-数据的存储" class="headerlink" title="1. 数据的存储"></a>1. 数据的存储</h2><h3 id="1-数据存储"><a href="#1-数据存储" class="headerlink" title="1).数据存储"></a>1).数据存储</h3><p>计算机存储分为运行内存和硬盘存储<br>运行内存是用来存储程序运行过程中产生的数据,程序结束,数据销毁<br>硬盘存储的文件则一直存在</p>
<h3 id="2-常用的文件"><a href="#2-常用的文件" class="headerlink" title="2).常用的文件"></a>2).常用的文件</h3><p>文本文件: txt, json(前后端), plist(页面), 数据库文件<br>二进制文件: 图片文件: png, jpg… ;音频文件: mp3, wav…; exe文件等</p>
<h2 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="2. 文件操作"></a>2. 文件操作</h2><p><strong>文件内容操作基本步骤 : 打开文件 -&gt; 操作文件(读, 写) -&gt; 关闭文件</strong></p>
<h3 id="1-打开文件"><a href="#1-打开文件" class="headerlink" title="1) . 打开文件"></a>1) . 打开文件</h3><p><strong>open(file, mode=’r’, encoding=None)</strong></p>
<p>open(文件地址, 读写方式, 文本编码方式) - 以指定方式打开指定文件返回文件对象</p>
<p><strong>说明:</strong><br><strong>file ——&gt; 文件路径(相对路径或绝对路径)</strong><br>相对路径: ./  -  表示当前目录<br>&emsp;&emsp;&emsp;&emsp;../  -  表示当前目录的上层目录</p>
<p><strong>mode ——&gt; 文件打开方式,决定打开文件后的操作权限(读-r , 写-w)操作文件的数据类型(文本-t, 二进制-b)</strong><br>文本文件在读取的时候可以用rt, rb,但是二进制文件只能用rb读取<br>a - 只写(a和w的区别就是,a打开文件不会删除源文件,w会)<br>&gt;&gt;&gt; a和w打开文件的时候,若文件不存在,会创建新文件<br>r打开文件时,若文件不存在,报错</p>
<p><strong>encoding -  文本文件编码方式,只能用t打开文本文件的时候才能赋值</strong><br>一般采用’utf-8’的编码方式编码,保证同一文件读和写的编码方式一样</p>
<h3 id="2-文件操作-1"><a href="#2-文件操作-1" class="headerlink" title="2).文件操作"></a>2).文件操作</h3><p><strong>a.读操作</strong><br>文件对象.read()   -   读指定文件,返回文件中的内容(所有文件)<br>文件对象.readline()   -   读指定文件的1行内容(只支持文本文件)<br>文件对象.close()   -   关闭操作好的文件</p>
<p><strong>文件读完之后,光标会停在最后读取的位置,再继续读取的话接着上次的位置继续</strong><br><strong>b.写操作</strong><br>文件对象.write(内容)   -   将指定的功能写入到指定的文件中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">o3 = open(<span class="string">r'../test/诗.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    line = o3.readline()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(line)</span><br></pre></td></tr></table></figure>

<br>

<hr>
<h1 id="二-数据持久化"><a href="#二-数据持久化" class="headerlink" title="二 . 数据持久化"></a>二 . 数据持久化</h1><h2 id="1-数据持久化"><a href="#1-数据持久化" class="headerlink" title="1. 数据持久化"></a>1. 数据持久化</h2><p>1).需要持久化的数据要存到文件中<br>2).需要数据的时候不直接赋值,从文件中读取数据<br>3).若数据的值发生改变,则将新数据更新到文件中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在程序中用一个变量来记录当前程序启动的次数</span></span><br><span class="line"><span class="comment"># count</span></span><br><span class="line"></span><br><span class="line">f = open(<span class="string">r'../test/num.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">count = int(f.read())</span><br><span class="line">print(count)</span><br><span class="line"></span><br><span class="line">count += <span class="number">1</span></span><br><span class="line">f = open(<span class="string">r'../test/num.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">f.write(str(count))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h2 id="2-文件域"><a href="#2-文件域" class="headerlink" title="2. 文件域"></a>2. 文件域</h2><p><strong><em>with open(文件路径,打开方式,编码方式) as 文件对象</em></strong><br>文件路径可以是绝对路径也可以是行对路径<br>相对路径中 ./ 代表当前目录 ; ../ 代表当前目录的上层目录,依次类推</p>
<h2 id="3-容器字符串的转换-eval"><a href="#3-容器字符串的转换-eval" class="headerlink" title="3.容器字符串的转换:eval"></a>3.容器字符串的转换:eval</h2><p>当一个字符串内是一个完整的其他容器(列表,字典,集合,元组)时,eval(字符串)可将字符串转换成相应的容器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">'[1, 2, 3, 4]'</span></span><br><span class="line">re1 = eval(str1)</span><br><span class="line">print(re1, type(re1))</span><br><span class="line"></span><br><span class="line">str2 = <span class="string">"&#123;'name': 2, 'age': 4&#125;"</span></span><br><span class="line">re2 = eval(str2)</span><br><span class="line">print(re2, type(re2))</span><br></pre></td></tr></table></figure>

<br>

<hr>
<h1 id="三-json"><a href="#三-json" class="headerlink" title="三 . json"></a>三 . json</h1><p><strong>json模块是python中专门用来支持json数据的模块</strong></p>
<h2 id="1-json"><a href="#1-json" class="headerlink" title="1.json"></a>1.json</h2><p><strong>json是一种数据格式,专门用来解决各个计算机语言间数据不能互通的问题</strong></p>
<h3 id="1-一个json只有一个数据"><a href="#1-一个json只有一个数据" class="headerlink" title="1).一个json只有一个数据"></a>1).一个json只有一个数据</h3><h3 id="2-唯一的这个数据必须是json支持的数据类型"><a href="#2-唯一的这个数据必须是json支持的数据类型" class="headerlink" title="2).唯一的这个数据必须是json支持的数据类型"></a>2).唯一的这个数据必须是json支持的数据类型</h3><p><strong>json支持的数据类型:</strong></p>
<ul>
<li>a.数字类型(number) ——&gt; 所有数字,支持科学计数法,直接写</li>
<li>b.字符串(string) ——&gt; 文本数据,只能用双引号引起来,并且支持转义字符<pre><code>&quot;abc&quot;, &quot;sadhuwe&quot;, ...</code></pre></li>
<li>c.布尔值(boolean) ——&gt; true/false(直接写)</li>
<li>d.空值 ——&gt; null(直接写)</li>
<li>e.数组(array) ——&gt; [元素1, 元素2, 元素3,…]  元素可以是json支持的任何数据类型</li>
<li>f.字典(dictionary) ——&gt; {key1:value, key2:value, key3:value, …} key必须是字符串,value可以是json支持的任何类型</li>
</ul>
<h2 id="2-json转python"><a href="#2-json转python" class="headerlink" title="2.json转python"></a>2.json转python</h2><h3 id="1-转换规律"><a href="#1-转换规律" class="headerlink" title="1).转换规律"></a>1).转换规律</h3><p>json ——&gt; python<br>数据 ——&gt; int/float<br>字符串 ——&gt; 字符串;双引号可能变为单引号<br>布尔 ——&gt; 布尔:True/False<br>null ——&gt; None<br>数组 ——&gt; 列表<br>字典 ——&gt; 字典</p>
<h3 id="2-转换方法"><a href="#2-转换方法" class="headerlink" title="2).转换方法"></a>2).转换方法</h3><p>json.loads(字符串) ——&gt; 将json字符串转换成python的字符串</p>
<p><strong>注意:要求字符串内的内容必须是json格式的数据</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = json.loads(<span class="string">'1'</span>)</span><br><span class="line">print(result, type(result))</span><br><span class="line"></span><br><span class="line">result = json.loads(<span class="string">'[123, "ads", true]'</span>)</span><br><span class="line">print(result, type(result))</span><br><span class="line"></span><br><span class="line">result = json.loads(<span class="string">'&#123;"name": "an", "age": 20&#125;'</span>)</span><br><span class="line">print(result, type(result))</span><br></pre></td></tr></table></figure>

<h2 id="3-python转json"><a href="#3-python转json" class="headerlink" title="3.python转json"></a>3.python转json</h2><h3 id="1-转换规律-1"><a href="#1-转换规律-1" class="headerlink" title="1).转换规律"></a>1).转换规律</h3><p>python ——&gt; json<br>int/float ——&gt; 数字<br>字符串 ——&gt; 字符串;单引号变成双引号<br>布尔值 ——&gt; 布尔值;true/false<br>None ——&gt; null<br>列表/元组 ——&gt; 数组<br>字典 ——&gt; 字典</p>
<h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2).方法"></a>2).方法</h3><p>json.dumps(数据) ——&gt; 将python数据转换成json类型的python字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = json.dumps(<span class="number">100</span>)</span><br><span class="line">print([result])</span><br><span class="line"></span><br><span class="line">result = json.dumps((<span class="number">10</span>, <span class="string">'ahs'</span>, <span class="literal">False</span>))</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：14:异常捕获</title>
    <url>/2018/07/14/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.14%20%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/</url>
    <content><![CDATA[<h1 id="一-异常"><a href="#一-异常" class="headerlink" title="一. 异常"></a>一. 异常</h1><p><strong>程序在运行过程中的报错就叫异常</strong></p>
<br>

<hr>
<h1 id="二-异常捕获"><a href="#二-异常捕获" class="headerlink" title="二. 异常捕获"></a>二. 异常捕获</h1><h2 id="1-使用异常捕获的场景"><a href="#1-使用异常捕获的场景" class="headerlink" title="1. 使用异常捕获的场景"></a>1. 使用异常捕获的场景</h2><p><strong>在知道某个位置可能会出现异常,但开发者无法控制时使用</strong></p>
<h2 id="2-捕获异常"><a href="#2-捕获异常" class="headerlink" title="2. 捕获异常"></a>2. 捕获异常</h2><p><strong>①:捕获任何异常</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">try:</span></span><br><span class="line"><span class="string">    代码块一(可能出现异常的代码)</span></span><br><span class="line"><span class="string">except:</span></span><br><span class="line"><span class="string">    代码块二(对异常进行处理)</span></span><br><span class="line"><span class="string">finally:</span></span><br><span class="line"><span class="string">    代码块三</span></span><br><span class="line"><span class="string">其他语句</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<ul>
<li>先执行代码块1,如果异常,直接执行代码块2,依次往后执行;若代码块1没有异常,不执行代码块2,往后执行</li>
</ul>
<p><strong>②:捕获针对异常</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">try:</span></span><br><span class="line"><span class="string">    代码块一(可能出现异常的代码)</span></span><br><span class="line"><span class="string">except 异常类型:</span></span><br><span class="line"><span class="string">    代码块二(对异常进行处理)</span></span><br><span class="line"><span class="string">其他语句</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<ul>
<li>先执行代码块1,如果异常,检查该异常是否和except后的异常类型是否一致若一致,执行代码块2,依次往后执行;若不一致,程序崩溃.</li>
</ul>
<p><strong>③:捕获多个异常一(相同处理)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">try:</span></span><br><span class="line"><span class="string">    代码块一(可能出现异常的代码)</span></span><br><span class="line"><span class="string">except (异常类型1, 异常类型2...):</span></span><br><span class="line"><span class="string">    代码块二(对异常进行处理)</span></span><br><span class="line"><span class="string">其他语句</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p><strong>④:捕获多个异常一(不同处理)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">try:</span></span><br><span class="line"><span class="string">    代码块一(可能出现异常的代码)</span></span><br><span class="line"><span class="string">except (异常类型1):</span></span><br><span class="line"><span class="string">    代码块二(对异常进行处理)</span></span><br><span class="line"><span class="string">except (异常类型2):</span></span><br><span class="line"><span class="string">    代码块三(对异常进行处理)</span></span><br><span class="line"><span class="string">except (异常类型3):</span></span><br><span class="line"><span class="string">    代码块四(对异常进行处理)</span></span><br><span class="line"><span class="string">    ...  </span></span><br><span class="line"><span class="string">其他代码</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<br>

<hr>
<h1 id="三-关键字finally"><a href="#三-关键字finally" class="headerlink" title="三. 关键字finally"></a>三. 关键字finally</h1><p>在以上四个捕获异常的方法中都可以在最后加上finally关键字,它的作用是:<strong>不管try中的代码出现任何情况,finally后的代码都会执行</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(&#123;<span class="string">'name'</span>: <span class="string">'an'</span>, <span class="string">'age'</span>: <span class="number">29</span>&#125;[<span class="string">'gender'</span>])</span><br><span class="line">    print(<span class="string">'hello'</span>[<span class="number">19</span>])</span><br><span class="line">    print(max([<span class="number">10</span>, <span class="string">'asd'</span>, <span class="literal">True</span>]))</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    print(<span class="string">'出现异常'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">'写遗书'</span>)</span><br></pre></td></tr></table></figure>


<h1 id="四-抛出异常"><a href="#四-抛出异常" class="headerlink" title="四. 抛出异常"></a>四. 抛出异常</h1><p><strong>raise 异常类型</strong></p>
]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：15:类和对象(基础)</title>
    <url>/2018/07/15/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.15%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1(%E5%9F%BA%E7%A1%80)/</url>
    <content><![CDATA[<h1 id="一-类和对象"><a href="#一-类和对象" class="headerlink" title="一. 类和对象"></a>一. 类和对象</h1><h2 id="1-先来两句废话"><a href="#1-先来两句废话" class="headerlink" title="1. 先来两句废话"></a>1. 先来两句废话</h2><ul>
<li>类就是拥有相同功能和相同属性的对象的集合</li>
<li>对象就是类的实例</li>
</ul>
<h2 id="2-类的声明"><a href="#2-类的声明" class="headerlink" title="2. 类的声明"></a>2. 类的声明</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1).语法"></a>1).语法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名:</span></span><br><span class="line">    类的说明文档</span><br><span class="line">    类的内容</span><br></pre></td></tr></table></figure>

<h3 id="2-说明"><a href="#2-说明" class="headerlink" title="2).说明"></a>2).说明</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>        -   声明类的关键字</span></span><br><span class="line">类名         -    和变量的声明要求相同; 规范:见名知义;首字母大写;驼峰式命名</span><br><span class="line">类的说明文档  -  用三个双引号引起来</span><br><span class="line">类的内容      -  描述声明的类的功能和属性</span><br><span class="line">            函数(功能)和变量(属性)</span><br></pre></td></tr></table></figure>

<h2 id="3-创建对象"><a href="#3-创建对象" class="headerlink" title="3. 创建对象"></a>3. 创建对象</h2><p><strong>对象 = 类名( )</strong></p>
<br>

<hr>
<h1 id="二-类的方法"><a href="#二-类的方法" class="headerlink" title="二. 类的方法"></a>二. 类的方法</h1><p><strong>对象方法, 类方法, 静态方法</strong></p>
<h2 id="1-对象方法"><a href="#1-对象方法" class="headerlink" title="1. 对象方法"></a>1. 对象方法</h2><ul>
<li>1).声明: 在类里面直接声明函数</li>
<li>2).调用: 用对象来调用,以’对象.对象方法()’的形式来调用</li>
<li>3).特点: 有个默认参数self, 通过对象调用时不用传参(系统自动传参,将当前调用函数的对象传给self)</li>
<li>4).使用条件:在实现函数功能时需要用到对象属性时使用对象方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, food = <span class="string">'骨头'</span>)</span>:</span></span><br><span class="line">        print(<span class="string">'狗吃'</span> + food)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'狗跑步'</span>)</span><br><span class="line"></span><br><span class="line">dog1 = Dog()</span><br><span class="line">dog1.eat()</span><br></pre></td></tr></table></figure>

<h2 id="2-类方法"><a href="#2-类方法" class="headerlink" title="2. 类方法"></a>2. 类方法</h2><ul>
<li>1).声明: 在声明前加@classmethod</li>
<li>2).调用: 通过类来调用 ‘类.类方法’</li>
<li>3).特点: 自带参数cls,不需要传参,系统会自动将当前类(class)传给cls</li>
<li>4).使用条件:在实现函数功能时不需要用到对象属性的前提下,需要用到类方法</li>
</ul>
<h2 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3. 静态方法"></a>3. 静态方法</h2><ul>
<li>1).声明: 在声明前加@classmethod</li>
<li>2).调用: 通过类来调用 ‘类.静态方法’</li>
<li>3).特点: 没有自带参数</li>
<li>4).使用条件:在实现函数功能时不需要用到对象属性也不需要用到类</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, tel, age=<span class="number">18</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.tel = tel</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">study</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s在学习'</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">'类方法'</span>)</span><br><span class="line">        stu2 = cls(<span class="string">'小花'</span>, <span class="string">'1234'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'类方法'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu = Student(<span class="string">'小明'</span>, <span class="number">2341</span>)</span><br><span class="line">stu.study()</span><br><span class="line"></span><br><span class="line">Student.func1()</span><br><span class="line"></span><br><span class="line">Student.func2()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><br>1).用类调用对象方法时,对象方法中的self就不会自动传参,失去对象方法的意义<br>2).类方法可以通过对象调用,但是要有对象</p>
</blockquote>
<blockquote>
<p><strong>扩展</strong></p>
<p>1) 构造函数:<br>声明类的时候,系统会声明一个和类同名的函数(构造函数);构造函数可以用来创建当前类的对象<br>在创建对象时,系统会调用类中的<strong>init</strong>方法来初始化对象<br>2) __init__是魔法方法,也是对象方法.<br>    在类里面声明的时候函数名必须是__init__,并保证它是对象方法<br>    若__init__函数需要传参,则可以通过构造函数传参</p>
</blockquote>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">       print(<span class="string">'init魔法'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;dog1 = Dog()</span><br><span class="line">&gt;print(dog1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">       print(<span class="string">'学生:'</span>, name, age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;stu = Student(<span class="string">'小明'</span>, <span class="string">'20'</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
<br>

<hr>
<h1 id="三-类中的属性"><a href="#三-类中的属性" class="headerlink" title="三. 类中的属性"></a>三. 类中的属性</h1><h2 id="1-字段属性"><a href="#1-字段属性" class="headerlink" title="1. 字段属性"></a>1. 字段属性</h2><p>1).声明:直接声明在类里面,函数外面的变量就是字段<br>2).使用:通过类使用 ‘类.变量’<br>3).使用时机:属性值不会因对象不同而改变的属性就是字段属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    a = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(Dog.a)</span><br></pre></td></tr></table></figure>

<h2 id="2-对象属性"><a href="#2-对象属性" class="headerlink" title="2. 对象属性"></a>2. 对象属性</h2><p>1).声明:声明在 <strong>init</strong>方法中, 以’self.属性名=值’的形式声明<br>2).使用:通过对象以’对象.属性’来用<br>3).使用时机:属性值会因对象不同而不一样的属性就是对象属性(例如,人的名字会因为人不一样而不同)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, variety, age)</span>:</span></span><br><span class="line">        self.name = variety</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dog1 = Dog(<span class="string">'柯基'</span>, <span class="number">2</span>)</span><br><span class="line">print(dog1.name, dog1.age)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/20010076-772cfd191ba2ba6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<blockquote>
<p>练习 : 声明一个狗的类:品种,名字,颜色,年龄,性别;吃(xxx吃xxx)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, variety, name, color, age, gender)</span>:</span></span><br><span class="line">        self.variety = variety</span><br><span class="line">        self.name = name</span><br><span class="line">        self.color = color</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, food)</span>:</span></span><br><span class="line">        print(<span class="string">'😆%s吃了%s😆'</span> % (self.name, food))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dog1 = Dog(<span class="string">'长白山吊睛白额虎'</span>, <span class="string">'旺财'</span>, <span class="string">'花'</span>, <span class="number">3</span>, <span class="string">'公'</span>)</span><br><span class="line">dog1.eat(<span class="string">'一只老虎'</span>)</span><br><span class="line"></span><br><span class="line">dog2 = Dog(<span class="string">'蝙蝠侠的耳朵'</span>, <span class="string">'鸡翅膀'</span>, <span class="string">'油'</span>, <span class="number">2.5</span>, <span class="string">'不明'</span>)</span><br><span class="line">dog2.eat(<span class="string">'美国队长的盾牌🛡'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-对象属性的增删改查"><a href="#3-对象属性的增删改查" class="headerlink" title="3. 对象属性的增删改查"></a>3. 对象属性的增删改查</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, gender)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dog1 = Dog(<span class="string">'大黄'</span>, <span class="number">2</span>, <span class="string">'公'</span>)</span><br><span class="line">dog2 = Dog(<span class="string">'小黄'</span>, <span class="number">3</span>, <span class="string">'母'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1).对象.属性</span></span><br><span class="line"><span class="string">2).getattr(对象, 属性名:str)</span></span><br><span class="line"><span class="string">   getattr(对象, 属性名:str, 默认值)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(dog1.name)   <span class="comment"># (不可以将属性赋值给一个变量,再将变量作为属性名)</span></span><br><span class="line">print(getattr(dog1, <span class="string">'name'</span>))</span><br><span class="line">print(getattr(dog1, <span class="string">'name'</span>, <span class="string">'没有这条狗'</span>))   <span class="comment"># (没有该属性的时候不会报错,可以将属性赋值给一个变量,再将变量作为属性名)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1).对象.属性 = 值   属性存在就修改,不存在就增加</span></span><br><span class="line"><span class="string">2)setattr(对象, 属性名:str, 值)   属性存在就修改,不存在就增加</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">dog1.name = <span class="string">'老黄'</span></span><br><span class="line">print(dog1.name)</span><br><span class="line">setattr(dog1, <span class="string">'name'</span>, <span class="string">'老老黄'</span>)</span><br><span class="line">print(dog1.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1).del 对象.属性   删除对象中指定的属性</span></span><br><span class="line"><span class="string">2).delattr(对象, 属性名)   删除对象中指定的属性</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">del</span> dog1.name</span><br><span class="line"><span class="comment"># print(dog1.name)   # 报错</span></span><br><span class="line">delattr(dog2, <span class="string">'name'</span>)</span><br><span class="line"><span class="comment"># print(dog2.name)   # 报错</span></span><br></pre></td></tr></table></figure>

<br>

<hr>
<h1 id="四-内置属性"><a href="#四-内置属性" class="headerlink" title="四. 内置属性"></a>四. 内置属性</h1><p><strong>举例说明!</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="string">"""狗类"""</span></span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># __slots__ = ('name', 'age', 'gender', 'height')  # 限制对象的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, gender)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'对象方法'</span>, self.name)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">'类方法'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'静态方法'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dog1 = Dog(<span class="string">'大黄'</span>, <span class="number">2</span>, <span class="string">'公'</span>)</span><br><span class="line"><span class="comment"># 1. 类.__name__   --&gt;   获取类名</span></span><br><span class="line">print(Dog.__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 对象.__class__   --&gt;   获取对象对应的类(type(对象)功能一样)</span></span><br><span class="line">print(type(Dog))</span><br><span class="line">print(dog1.__class__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 类.__doc__  --&gt;   获取类的说明文档</span></span><br><span class="line">print(Dog.__doc__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. __dict__</span></span><br><span class="line"><span class="comment"># 1) 类.__dict__   --&gt;   获取类中所有的字段和字段对应的值,以字典的形式返回</span></span><br><span class="line">print(Dog.__dict__)</span><br><span class="line"><span class="comment"># 2) 对象.__dict__   --&gt;   获取对象中所有的属性和属性对应的值,以字典的形式返回(不能和__slots__并用)</span></span><br><span class="line">print(dog1.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 类.__module__   --&gt;  获取类所在得模块</span></span><br><span class="line">print(Dog.__module__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 类.__bases__   --&gt;   获取当前类得父类</span></span><br><span class="line"><span class="comment"># object 是python中所有类得基类</span></span><br><span class="line">print(Dog.__bases__)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：16:类和对象(进阶)</title>
    <url>/2018/07/20/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.16%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1(%E8%BF%9B%E9%98%B6)/</url>
    <content><![CDATA[<h1 id="一-类的继承"><a href="#一-类的继承" class="headerlink" title="一. 类的继承"></a>一. 类的继承</h1><p><strong>继承是让子类直接拥有父类的属性和方法</strong></p>
<h2 id="1-用法"><a href="#1-用法" class="headerlink" title="1. 用法"></a>1. 用法</h2><blockquote>
<p>class 类名(父类1,父类2,…)<br>&emsp;&emsp;类的内容</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    num = <span class="number">70</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'小明'</span></span><br><span class="line">        self.age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'静态方法'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类直接使用父类的属性和方法</span></span><br><span class="line">stu1 = Student.num</span><br><span class="line">print(stu1)</span><br><span class="line"></span><br><span class="line">stu2 = Student()</span><br><span class="line">print(stu2.name, stu2.age)</span><br></pre></td></tr></table></figure>

<h2 id="2-子类中添加属性和方法"><a href="#2-子类中添加属性和方法" class="headerlink" title="2. 子类中添加属性和方法"></a>2. 子类中添加属性和方法</h2><h3 id="1-添加方法和字段"><a href="#1-添加方法和字段" class="headerlink" title="1). 添加方法和字段"></a>1). 添加方法和字段</h3><p>在子类中直接声明新的字段和方法,若字段和方法与父类的重名,则父类的会被覆盖(重写)</p>
<h3 id="2-添加对象属性"><a href="#2-添加对象属性" class="headerlink" title="2). 添加对象属性"></a>2). 添加对象属性</h3><p>用__initial__方法添加新的属性,并且通过 <strong>super().__init__</strong> 方法继承父类的对象属性</p>
<ul>
<li>可以在类的任何一个对象方法或者类方法中去通过super()调用父类的的对象方法或者类方法</li>
<li>super(类1,类1的对象).方法()  -&gt;   调用类1的父类中的方法<br>super().方法() &lt;==&gt; super(当前类,当前类的对象)</li>
<li>super(type, obj)  -&gt; 要求obj必须是type的对象或者是type的子类对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.age = <span class="number">10</span></span><br><span class="line">        self.gender = <span class="string">'雌'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'动物类中的对象方法'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">'动物类中的类方法'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'动物类中的静态方法'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    voice = <span class="string">'喵~'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()   <span class="comment"># 调用当前类的父类的__init__方法</span></span><br><span class="line">        self.color = <span class="string">'白'</span></span><br><span class="line">        self.breed = <span class="string">'加菲猫'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func4</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().func1()   <span class="comment"># 用super实现 子类Cat中的函数(方法)内调用父类Animal的方法</span></span><br><span class="line">        print(<span class="string">'猫类中的对象方法'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func5</span><span class="params">(cls)</span>:</span></span><br><span class="line">        super().func2()   <span class="comment"># 用super实现 子类Cat中的函数(方法)内调用父类Animal的方法</span></span><br><span class="line">        print(<span class="string">'猫类中的类方法'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func6</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'猫类中的静态方法'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类Cat继承父类Animal的属性和方法</span></span><br><span class="line"><span class="comment"># (父类的类方法和静态方法只能用子类的类调用,对象方法只能用对象调用)</span></span><br><span class="line">cat1 = Cat()</span><br><span class="line">print(cat1.color, cat1.breed, cat1.age, cat1.gender)</span><br><span class="line">cat1.func1()</span><br><span class="line">Cat.func2()</span><br><span class="line">Cat.func3()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用super实现 子类Cat中的函数(方法)内调用父类Animal的方法</span></span><br><span class="line">cat1.func4()</span><br><span class="line">Cat.func5()</span><br><span class="line">Cat.func6()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上代码的执行结果:<br>白  加菲猫  10 雌<br>动物类中的对象方法<br>动物类中的类方法<br>动物类中的静态方法<br>动物类中的对象方法<br>猫类中的对象方法<br>动物类中的类方法<br>猫类中的类方法<br>猫类中的静态方法</p>
</blockquote>
<h2 id="3-多继承"><a href="#3-多继承" class="headerlink" title="3. 多继承"></a>3. 多继承</h2><blockquote>
<p><strong>子类在继承多个父类时,对象属性只能继承第一个父类的对象属性</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, age=<span class="number">0</span>, gender=<span class="string">'雄'</span>)</span>:</span></span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">a_func1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'动物的对象方法'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">massage</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'this is Animal'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fly</span>:</span></span><br><span class="line">    flag = <span class="string">'飞行'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, height=<span class="number">1000</span>, time=<span class="number">3</span>)</span>:</span></span><br><span class="line">        self.height = height</span><br><span class="line">        self.time = time</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f_func1</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">'飞行的类方法'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span><span class="params">(Animal, Fly)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b1 = Bird()</span><br><span class="line">print(Bird.num, Bird.flag)</span><br><span class="line"></span><br><span class="line">b1.a_func1()</span><br><span class="line">Bird.f_func1()</span><br><span class="line"></span><br><span class="line">print(b1.age, b1.gender)</span><br><span class="line">print(b1.height, b1.time)   <span class="comment">#  第二个父类的属性不能继承,本行代码会报错</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/20010076-58b0961bef4d933f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码执行结果"></p>
<h2 id="4-多继承的执行顺序"><a href="#4-多继承的执行顺序" class="headerlink" title="4. 多继承的执行顺序"></a>4. 多继承的执行顺序</h2><p>例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">massage</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'this is A'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">massage</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().massage()</span><br><span class="line">        print(<span class="string">'this is B'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">massage</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().massage()</span><br><span class="line">        print(<span class="string">'this is C'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">massage</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().massage()</span><br><span class="line">        print(<span class="string">'this is D'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D().massage()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码执行结果:<br>this is A<br>this is C<br>this is B<br>this is D</p>
</blockquote>
<p><strong>说明:</strong>我也说不清,别喷我😭</p>
<p><img src="https://upload-images.jianshu.io/upload_images/20010076-d011e9259894990f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行顺序"></p>
<br>

<hr>
<h1 id="二-私有化"><a href="#二-私有化" class="headerlink" title="二. 私有化"></a>二. 私有化</h1><h2 id="1-访问权限"><a href="#1-访问权限" class="headerlink" title="1. 访问权限"></a>1. 访问权限</h2><p>公开的(public):类的里面,外面都能用,也可以被继承<br>保护的(protect):类的里面可以用,也可以被继承<br>私有的(private):类的里面可以用,不能被继承</p>
<h2 id="2-python中的权限"><a href="#2-python中的权限" class="headerlink" title="2. python中的权限"></a>2. python中的权限</h2><p>python类中的内容只有公开的,私有化是假的私有化</p>
<h2 id="3-python私有化"><a href="#3-python私有化" class="headerlink" title="3.python私有化"></a>3.python私有化</h2><p>在方法名前或属性名前加两个下划线__<br>只是在 __方法名 前加了下划线类名(_类名),在外部加_类名可以调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    num = <span class="number">61</span></span><br><span class="line">    __num2 = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age=<span class="number">18</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = <span class="string">'男'</span></span><br><span class="line">        self.__gender = <span class="string">'男'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s今年%d岁'</span> % (self.name, self.age), self.__gender)</span><br><span class="line">        self.__func11()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__func11</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'私有的对象方法'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'我是静态方法1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__func22</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'我是静态方法1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(cls.num)</span><br><span class="line">        print(cls.__num2)</span><br></pre></td></tr></table></figure>

<br>

<hr>
<h1 id="3-getter和setter"><a href="#3-getter和setter" class="headerlink" title="3. getter和setter"></a>3. getter和setter</h1><h2 id="1-什么时候用"><a href="#1-什么时候用" class="headerlink" title="1. 什么时候用"></a>1. 什么时候用</h2><p>如果希望在对象属性赋值前做点儿别的什么事情就给这个属性添加setter<br>如果希望在获取属性值之前做点儿别的什么事情就给这个属性添加getter</p>
<h2 id="2-怎么用"><a href="#2-怎么用" class="headerlink" title="2. 怎么用"></a>2. 怎么用</h2><p><strong>getter：</strong><br>a. 将需要添加getter的属性名前加 _<br>b. 声明函数：声明前加@property；<br>           函数名不带_的属性名；<br>           函数需要一个返回值，返回值就是获取这个属性能够得到的值<br>c.在外面使用属性的时候不带下划线</p>
<p><strong>setter:</strong><br>注意: 如果想要给属性添加setter必须先添加getter<br>a. 声明函数: 声明前加@getter名.setter;<br>            函数名不带_的属性名；<br>            函数不需要返回值，但是需要一个参数，这个参数就是给属性赋的值<br>b.在外面给属性赋值的时候不带下划线</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span></span><br><span class="line">    pi = <span class="number">3.1415926</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, r)</span>:</span></span><br><span class="line">        self.r = r</span><br><span class="line">        self._area = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Circle.pi * self.r * self.r</span><br><span class="line"></span><br><span class="line"><span class="meta">    @area.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        print(<span class="string">'给area属性赋值:'</span>, value)</span><br><span class="line">        <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c1 = Circle(<span class="number">1</span>)</span><br><span class="line">print(c1.area)    <span class="comment"># 本质是在调用area函数: c1.area()</span></span><br><span class="line"></span><br><span class="line">c1.r = <span class="number">10</span></span><br><span class="line">print(c1.area)   <span class="comment"># 本质是在调用area函数: c1.area()</span></span><br><span class="line"></span><br><span class="line">c1.r = <span class="number">3</span></span><br><span class="line">print(c1.area)   <span class="comment"># 本质是在调用getter的area函数: c1.area()</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：17:内存管理, 拷贝,正则表达式</title>
    <url>/2018/07/25/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.17%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86,%20%E6%8B%B7%E8%B4%9D,%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="一-内存管理"><a href="#一-内存管理" class="headerlink" title="一. 内存管理"></a>一. 内存管理</h1><h2 id="1-C语言中内存管理的概念"><a href="#1-C语言中内存管理的概念" class="headerlink" title="1. C语言中内存管理的概念"></a>1. C语言中内存管理的概念</h2><ul>
<li>内存分为堆区间和栈区间</li>
<li>C的栈区间的内存是系统自动申请和释放(自动管理)</li>
<li>C的堆区间的内存需要调用malloc函数申请,调用free函数释放</li>
</ul>
<p><em>其他高级语言中的垃圾管理机制是针对堆区间的内存进行管理的</em></p>
<h2 id="2-python的内存管理机制"><a href="#2-python的内存管理机制" class="headerlink" title="2. python的内存管理机制"></a>2. python的内存管理机制</h2><h3 id="1-内存的申请"><a href="#1-内存的申请" class="headerlink" title="1) 内存的申请"></a>1) 内存的申请</h3><p>python中所有的数据都是存在堆中的，变量是保存在栈区间的，变量中保存的是保存在堆中的数据的地址。</p>
<p>重新给变量赋值，会先在内存开辟新的内存保存新的数据，然后将新的数据的地址重新保存到变量<br>但是如果使用数字或者字符串给变量赋值,不会直接开辟新的内存，而是先检查内存有没有这个数据，如果有直接将原来的数据的地址给变量</p>
<h3 id="2-内存的释放-垃圾回收机制"><a href="#2-内存的释放-垃圾回收机制" class="headerlink" title="2)内存的释放(垃圾回收机制)"></a>2)内存的释放(垃圾回收机制)</h3><p>在python中一个数据对应的内存空间是否释放，就看这个数据的引用计数是否为0；如果引用计数为0，数据对应的内存就会被自动释放<br>循环引用问题: python的垃圾回收机制会自动处理循环引用问题</p>
<p>增加引用计数: 增加数据的引用(让更多的变量来保存数据的地址)<br>减少引用计数: 删除引用，或者让引用去保存新的数据</p>
<h3 id="3-查看引用次数"><a href="#3-查看引用次数" class="headerlink" title="3)查看引用次数"></a>3)查看引用次数</h3><p>导入sys模块中的getrefcount<br>print(getrefcount(list2))<br><strong>getrefcount函数在调用时会给形参赋值,所以打印的值会比我们需要的值多1</strong></p>
<h2 id="3-循环引用"><a href="#3-循环引用" class="headerlink" title="3.循环引用"></a>3.循环引用</h2><ul>
<li>堆中的数据相互间的引用,数据计数不为零,不被释放</li>
<li>python的垃圾回收机制会自动解决循环引用的问题</li>
</ul>
<br>

<hr>
<h1 id="二-拷贝-需要导入copy模块"><a href="#二-拷贝-需要导入copy模块" class="headerlink" title="二. 拷贝(需要导入copy模块)"></a>二. 拷贝(需要导入copy模块)</h1><h2 id="1-直接赋值"><a href="#1-直接赋值" class="headerlink" title="1. 直接赋值"></a>1. 直接赋值</h2><p>一个变量给另外一个变量赋值时,两个变量的数据是同一个值</p>
<h2 id="2-浅拷贝"><a href="#2-浅拷贝" class="headerlink" title="2.浅拷贝"></a>2.浅拷贝</h2><p>拷贝之后产生新的相同的数据,新的地址.但是若数据内有引用其他的数据,则其他数据的地址还是原来的地址,(相当于一个人的类,有一个狗的属性,浅拷贝之后,多个人对象拥有同一条狗(拷贝之后狗对象的地址不变,只是多了几次引用))</p>
<h2 id="3-深拷贝"><a href="#3-深拷贝" class="headerlink" title="3.深拷贝"></a>3.深拷贝</h2><p>(多个人都拥有各自的狗)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> copy, deepcopy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, color=<span class="string">'黄色'</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;%s __id: %s&gt;'</span> % (str(self.__dict__)[<span class="number">1</span>:<span class="number">-1</span>], id(self))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age=<span class="number">10</span>, gender=<span class="string">'男'</span>, dog=None)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.dog = dog</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;%s __id: %s&gt;'</span> % (str(self.__dict__)[<span class="number">1</span>:<span class="number">-1</span>], id(self))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接赋值</span></span><br><span class="line">print(<span class="string">'直接赋值'</span>)</span><br><span class="line">p1 = Person(<span class="string">'小明'</span>, dog=Dog(<span class="string">'大黄'</span>))</span><br><span class="line">p2 = p1    <span class="comment"># 赋值后p1和p2指向是同一个Person对象</span></span><br><span class="line">print(<span class="string">'p1:'</span>, p1)</span><br><span class="line">print(<span class="string">'p2:'</span>, p2)</span><br><span class="line">p1.gender = <span class="string">'女'</span></span><br><span class="line">p1.dog.color = <span class="string">'白色'</span></span><br><span class="line">print(<span class="string">'p1:'</span>, p1)</span><br><span class="line">print(<span class="string">'p2:'</span>, p2)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'=============浅拷贝=============='</span>)</span><br><span class="line">p1 = Person(<span class="string">'小明'</span>, dog=Dog(<span class="string">'大黄'</span>))</span><br><span class="line">p2 = copy(p1)</span><br><span class="line">print(p1)</span><br><span class="line">print(p2)</span><br><span class="line">p1.gender = <span class="string">'女'</span></span><br><span class="line">p1.dog.color = <span class="string">'白色'</span></span><br><span class="line">print(<span class="string">'p1:'</span>, p1)</span><br><span class="line">print(<span class="string">'p2:'</span>, p2)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'=============深拷贝==========='</span>)</span><br><span class="line">p1 = Person(<span class="string">'小花'</span>, dog=Dog(<span class="string">'大黄'</span>))</span><br><span class="line">p2 = deepcopy(p1)</span><br><span class="line">print(<span class="string">'p1:'</span>, p1)</span><br><span class="line">print(<span class="string">'p2:'</span>, p2)</span><br><span class="line">p1.gender = <span class="string">'女'</span></span><br><span class="line">p1.dog.color = <span class="string">'白色'</span></span><br><span class="line">print(<span class="string">'p1:'</span>, p1)</span><br><span class="line">print(<span class="string">'p2:'</span>, p2)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>魔法方法(__repr__):自定义打印结果的显示<br>    def <strong>repr</strong>(self):<br>        return ‘&lt;%s <strong>id: %s&gt;’ % (str(self.</strong>dict__)[1:-1], id(self))</p>
</blockquote>
<br>

<hr>
<h1 id="三-正则表达式"><a href="#三-正则表达式" class="headerlink" title="三. 正则表达式"></a>三. 正则表达式</h1><h2 id="1-正则表达式"><a href="#1-正则表达式" class="headerlink" title="1.正则表达式"></a>1.正则表达式</h2><p>用正则符号来描述字符串规则让字符串匹配更简单(计算机语言基本支持正则,python通过re模块支持正则)</p>
<h2 id="2-正则符号"><a href="#2-正则符号" class="headerlink" title="2. 正则符号"></a>2. 正则符号</h2><h3 id="1-匹配符号"><a href="#1-匹配符号" class="headerlink" title="1) 匹配符号"></a>1) 匹配符号</h3><p><strong>1).普通字符:在正则中没有特殊功能和意义的字符</strong></p>
<p><strong>2).特殊字符:</strong><br>①:点(.)   -   代表任意字符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(re.fullmatch(<span class="string">r'a..b'</span>, <span class="string">'au9b'</span>))</span><br></pre></td></tr></table></figure>
<p>②:(\w)   -   ASCII码表中只能匹配字母、数字或者下划线；ASCII码表以外的都可以匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(re.fullmatch(<span class="string">r'a\wb'</span>, <span class="string">'a8b'</span>))</span><br></pre></td></tr></table></figure>
<p>③:(\d)   -   匹配任意一个数字字符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(re.fullmatch(<span class="string">r'a\d\db'</span>, <span class="string">'a33b'</span>))</span><br></pre></td></tr></table></figure>
<p>④:(\s)   -   匹配任意一个空白字符(空格,缩进,换行…)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(re.fullmatch(<span class="string">r'a\sb'</span>, <span class="string">'a\tb'</span>))</span><br><span class="line">print(re.fullmatch(<span class="string">r'a\sb'</span>, <span class="string">'a\nb'</span>))</span><br></pre></td></tr></table></figure>
<p>⑤:(\W \D \S)   -&gt;   功能和小写的相反<br>   \W   -   匹配ASCII码表任意非字母数字下划线<br>   \D   -   匹配任意非数字字符<br>   \S   -   匹配任意非空白字符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(re.fullmatch(<span class="string">r'a\Db\Sc\Wd'</span>, <span class="string">'aZb=c+d'</span>))</span><br></pre></td></tr></table></figure>

<p>⑥:[字符集]   -   匹配字符集中的任意一个字符(一个中括号只能匹配一个字符集)<br><strong>注意:前一个字符的编码值一定要比后一个字符的编码值要大</strong><br><strong>当字符集中有减号时,减号不能放中间</strong></p>
<ul>
<li>&emsp;[1-9]  - 匹配123456789中的任意一个字符</li>
<li>&emsp;[0-9]  - \d</li>
<li>&emsp;[a-z]  - 匹配任意一个小写字母</li>
<li>&emsp;[A-Z]  - 匹配任意一个大写字母</li>
<li>&emsp;[a-zA-Z] - 匹配任意一个字母</li>
<li>&emsp;[\u4e00-\u9fa5]  - 匹配任意一个中文字符</li>
<li>&emsp;[1-9abc] - 匹配1~9或者abc中的任意一个字符</li>
<li>&emsp;[a-zA-Z0-9_]  - 匹配字母数字下划线</li>
<li>&emsp;[\dxyz]  - 任意数字或者x、y、z</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(re.fullmatch(<span class="string">r'a[xyz89?]b'</span>, <span class="string">'azb'</span>))</span><br><span class="line">print(re.fullmatch(<span class="string">r'a[xyz]b'</span>, <span class="string">'anb'</span>))</span><br><span class="line">print(re.fullmatch(<span class="string">r'a[23456789]b'</span>, <span class="string">r'a7b'</span>))</span><br><span class="line">print(re.fullmatch(<span class="string">r'a[1-9abc]b'</span>, <span class="string">'aab'</span>))</span><br><span class="line">print(re.fullmatch(<span class="string">r'a[abc1-9]b'</span>, <span class="string">'aab'</span>))</span><br><span class="line">print(re.fullmatch(<span class="string">r'a[ac1-9b]b'</span>, <span class="string">'aab'</span>))</span><br><span class="line">print(re.fullmatch(<span class="string">r'a[+*-]b'</span>, <span class="string">'a-b'</span>))</span><br><span class="line">print(re.fullmatch(<span class="string">r'a[\dxyz]b'</span>, <span class="string">'axb'</span>))</span><br><span class="line">print(re.fullmatch(<span class="string">r'a[\\dxyz]b'</span>, <span class="string">'a\\b'</span>))</span><br></pre></td></tr></table></figure>

<p>⑦:[^字符集]   -   匹配除了字符集以外的其他任意字符<br><strong>注意:符号^只能放在最前面!</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(re.fullmatch(<span class="string">r'a[xyz^]b'</span>, <span class="string">'a^b'</span>))</span><br></pre></td></tr></table></figure>

<h3 id="2-检测符号"><a href="#2-检测符号" class="headerlink" title="2 检测符号"></a>2 检测符号</h3><p>①: \b   -   检测是否是单词结尾<br>单词结尾-所有可以区分出两个不同单词的符号都是单词结尾，其中字符串开头和字符串结尾<br>用法：检测\b所在的位置是否是单词结尾；不影响匹配的时候的字符串长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re_str = <span class="string">r'a\db\b'</span></span><br><span class="line">print(re.fullmatch(re_str, <span class="string">'a7b'</span>))</span><br></pre></td></tr></table></figure>

<p>②:^   -   检测是否是字符开头</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re_str = <span class="string">r'^\d\d\d'</span></span><br><span class="line">print(re.fullmatch(re_str, <span class="string">'123'</span>))</span><br><span class="line">print(re.search(re_str, <span class="string">'k898ahs237khhj'</span>))</span><br></pre></td></tr></table></figure>

<p>③:$   -   检测是否是字符结尾</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re_str = <span class="string">r'\d\d\d$'</span></span><br><span class="line">print(re.search(re_str, <span class="string">'123k898ahs237khhj990'</span>))</span><br></pre></td></tr></table></figure>

<h3 id="3-匹配次数"><a href="#3-匹配次数" class="headerlink" title="3 匹配次数"></a>3 匹配次数</h3><p>①:?   -   匹配0次或1次<br>    例: x?   -   x出现0次或1次<br>       \d?   -   数字出现0次或1次</p>
<p>②:*   -   任意次数,0次也可以</p>
<p>③:+   -   1次或多次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(re.fullmatch(<span class="string">r'ax?b'</span>, <span class="string">'axb'</span>))</span><br><span class="line">print(re.fullmatch(<span class="string">r'a\d*b'</span>, <span class="string">'a12b'</span>))</span><br><span class="line">print(re.fullmatch(<span class="string">r'a\d+b'</span>, <span class="string">'a1272937928329b'</span>))</span><br></pre></td></tr></table></figure>

<p>④:{}<br>a: {N}   -   匹配N次<br>b: {M,N}   -   匹配M到N次<br>b: {M,}   -   至少匹配M次<br>b: {,N}   -   最多匹配N次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re_str = <span class="string">r'a\d&#123;3,5&#125;b'</span></span><br><span class="line">print(re.fullmatch(re_str, <span class="string">'a78988b'</span>))</span><br><span class="line">print(re.fullmatch(re_str, <span class="string">'a7898b'</span>))</span><br><span class="line">print(re.fullmatch(re_str, <span class="string">'a789880b'</span>))   <span class="comment"># None</span></span><br></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 练习: 写一个正则表达式判断输入的内容是否是整数</span></span><br><span class="line"><span class="comment"># 123 -&gt; 成功!  123a -&gt; 失败!   -123  -&gt; 成功!   --123 -&gt; 失败!   +123 -&gt; 成功</span></span><br><span class="line">re_str = <span class="string">r'[+-]?[1-9]\d*'</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>贪婪和非贪婪</strong></p>
</blockquote>
<blockquote>
<p>匹配次数不确定的时候有贪婪和非贪婪状态<br>? * + {M,} {M,N} {,N}   默认贪婪<br>在能匹配成功的前提下，尽可能多的匹配<br>?? *? +? {M,}? {M,N}? {,N}?   非贪婪<br>在能匹配成功的前提下，尽可能少的匹配</p>
</blockquote>
<h2 id="3-分支和分组"><a href="#3-分支和分组" class="headerlink" title="3. 分支和分组"></a>3. 分支和分组</h2><h3 id="1-分支"><a href="#1-分支" class="headerlink" title="1).分支"></a>1).分支</h3><p><strong>正则1 | 正则2</strong>      -       先让正则1匹配,再让正则2匹配;只要有一个匹配就能成功</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 匹配一个字符串: abc前是3个数字或者3个字母</span></span><br><span class="line"><span class="comment"># 123abc, uJhabc</span></span><br><span class="line">re_str = <span class="string">r'\d&#123;3&#125;abc|[a-zA-Z]&#123;3&#125;abc'</span></span><br></pre></td></tr></table></figure>

<h3 id="2-分组"><a href="#2-分组" class="headerlink" title="2).分组"></a>2).分组</h3><p><strong>①:整体控制次数: ()匹配次数<br>②:将正则表达式作为一个整体操作</strong></p>
<p>重复：带分组的正则表达式\M - 在\M的位置重前面第M个分组匹配到的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 匹配一个字符串: abc前是3个数字或者3个字母</span></span><br><span class="line">re_str = <span class="string">r'(\d&#123;3&#125;|[a-z]&#123;3&#125;)abc'</span></span><br><span class="line">print(re.fullmatch(re_str, <span class="string">'mskabc'</span>))</span><br><span class="line">re_str = <span class="string">r'(\d+)([a-z]+)=\2'</span></span><br><span class="line">print(re.fullmatch(re_str, <span class="string">'6kh=kh'</span>))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：18:re模块</title>
    <url>/2018/08/03/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.18%20re%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="一：方法使用"><a href="#一：方法使用" class="headerlink" title="一：方法使用"></a>一：方法使用</h1><h2 id="1-compile-正则表达式-编译创建正则表达式对象"><a href="#1-compile-正则表达式-编译创建正则表达式对象" class="headerlink" title="1. compile(正则表达式)  - 编译创建正则表达式对象"></a>1. compile(正则表达式)  - 编译创建正则表达式对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re_obj = re.compile(<span class="string">r'\d&#123;3&#125;'</span>)</span><br><span class="line">re_obj.fullmatch(<span class="string">'234'</span>)</span><br><span class="line"></span><br><span class="line">re.fullmatch(<span class="string">r'\d&#123;3&#125;'</span>, <span class="string">'345'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>a.获取匹配结果:<br>匹配对象.group()   - 获取整个正则表达式匹配到的结果<br>匹配对象.group(N)  - 获取第N分组匹配到的结果</p>
</li>
<li><p>b.获取匹配结果在原字符串中的范围<br>匹配对象.span()</p>
</li>
<li><p>c.获取原字符串<br>匹配对象.string</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(result.group())   <span class="comment"># 234hksj</span></span><br><span class="line">print(result.group(<span class="number">1</span>))  <span class="comment"># 234</span></span><br><span class="line">print(result.group(<span class="number">2</span>))  <span class="comment"># hksj</span></span><br><span class="line"></span><br><span class="line">print(result.span())   <span class="comment"># (0, 7)</span></span><br><span class="line">print(result.span(<span class="number">2</span>))  <span class="comment"># (3, 7)</span></span><br><span class="line"></span><br><span class="line">print(result.string)   <span class="comment"># 234hksj</span></span><br></pre></td></tr></table></figure>

<h2 id="2-fullmatch-正则表达式-字符串-让正则表达式和整个字符串进行匹配；如果匹配成功返回匹配对象，匹配失败返回None"><a href="#2-fullmatch-正则表达式-字符串-让正则表达式和整个字符串进行匹配；如果匹配成功返回匹配对象，匹配失败返回None" class="headerlink" title="2. fullmatch(正则表达式, 字符串)  -  让正则表达式和整个字符串进行匹配；如果匹配成功返回匹配对象，匹配失败返回None"></a>2. fullmatch(正则表达式, 字符串)  -  让正则表达式和整个字符串进行匹配；如果匹配成功返回匹配对象，匹配失败返回None</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = re.fullmatch(<span class="string">r'(\d&#123;3&#125;)([a-z]&#123;4&#125;)'</span>, <span class="string">'234hksj'</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<h2 id="3-match-正则表达式-字符串-让字符串开头和正则表达式进行匹配-返回值是匹配对象或者None"><a href="#3-match-正则表达式-字符串-让字符串开头和正则表达式进行匹配-返回值是匹配对象或者None" class="headerlink" title="3.match(正则表达式, 字符串)  -  让字符串开头和正则表达式进行匹配; 返回值是匹配对象或者None"></a>3.match(正则表达式, 字符串)  -  让字符串开头和正则表达式进行匹配; 返回值是匹配对象或者None</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(re.match(<span class="string">r'\d&#123;3&#125;'</span>, <span class="string">'789佳的说法0023-==='</span>))</span><br><span class="line">print(re.match(<span class="string">r'\d&#123;3&#125;abc'</span>, <span class="string">'345ABC就开始大锅饭'</span>, flags=re.I))</span><br></pre></td></tr></table></figure>

<h2 id="4-search-正则表达式-字符串-在字符串中查找第一个满足正则表达式的子串；返回值是匹配对象或者None"><a href="#4-search-正则表达式-字符串-在字符串中查找第一个满足正则表达式的子串；返回值是匹配对象或者None" class="headerlink" title="4.search(正则表达式, 字符串)  - 在字符串中查找第一个满足正则表达式的子串；返回值是匹配对象或者None"></a>4.search(正则表达式, 字符串)  - 在字符串中查找第一个满足正则表达式的子串；返回值是匹配对象或者None</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(re.search(<span class="string">r'\d&#123;3&#125;'</span>, <span class="string">'时代峰峻34890shh==23992课时费'</span>))</span><br></pre></td></tr></table></figure>

<h2 id="5-findall-正则表达式-字符串-获取字符串中所有满足正则表达式的子串；返回值是列表，列表中的元素是字符串"><a href="#5-findall-正则表达式-字符串-获取字符串中所有满足正则表达式的子串；返回值是列表，列表中的元素是字符串" class="headerlink" title="5.findall(正则表达式,字符串)  - 获取字符串中所有满足正则表达式的子串；返回值是列表，列表中的元素是字符串"></a>5.findall(正则表达式,字符串)  - 获取字符串中所有满足正则表达式的子串；返回值是列表，列表中的元素是字符串</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(re.findall(<span class="string">r'\d+'</span>, <span class="string">'安抚348净宽度34920skdsf45烧开后09823hsd3sd89'</span>))</span><br></pre></td></tr></table></figure>

<h2 id="6-finditer-正则表达式-字符串-获取字符串中所有满足正则表达式的子串-返回值是迭代器，迭代器中的元素是匹配对象"><a href="#6-finditer-正则表达式-字符串-获取字符串中所有满足正则表达式的子串-返回值是迭代器，迭代器中的元素是匹配对象" class="headerlink" title="6.finditer(正则表达式,字符串) - 获取字符串中所有满足正则表达式的子串; 返回值是迭代器，迭代器中的元素是匹配对象"></a>6.finditer(正则表达式,字符串) - 获取字符串中所有满足正则表达式的子串; 返回值是迭代器，迭代器中的元素是匹配对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = re.finditer(<span class="string">r'(\d+)([a-z]&#123;2&#125;)'</span>, <span class="string">'安抚348净宽度34920skdsf45烧开后09823hsd3sd89'</span>)</span><br><span class="line">print(list(result))</span><br></pre></td></tr></table></figure>

<h2 id="7-split-正则表达式-字符串-以正则表达式匹配到的子串作为切割点，对字符串进行切割-返回值是列表，列表中的元素是字符串"><a href="#7-split-正则表达式-字符串-以正则表达式匹配到的子串作为切割点，对字符串进行切割-返回值是列表，列表中的元素是字符串" class="headerlink" title="7.split(正则表达式,字符串)  - 以正则表达式匹配到的子串作为切割点，对字符串进行切割; 返回值是列表，列表中的元素是字符串"></a>7.split(正则表达式,字符串)  - 以正则表达式匹配到的子串作为切割点，对字符串进行切割; 返回值是列表，列表中的元素是字符串</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = re.split(<span class="string">r'\d+'</span>, <span class="string">'暗红色的83大黄金黄色的9罚款0233s闪电发货890'</span>)</span><br><span class="line">print(result)   <span class="comment"># ['暗红色的', '大黄金黄色的', '罚款', 's闪电发货', '']</span></span><br></pre></td></tr></table></figure>

<h2 id="8-sub-正则表达式-字符串1-字符串2-将字符串2中满足正则表达式的子串全部替换成字符串1；返回值是替换后的字符串"><a href="#8-sub-正则表达式-字符串1-字符串2-将字符串2中满足正则表达式的子串全部替换成字符串1；返回值是替换后的字符串" class="headerlink" title="8.sub(正则表达式,字符串1,字符串2)  -  将字符串2中满足正则表达式的子串全部替换成字符串1；返回值是替换后的字符串"></a>8.sub(正则表达式,字符串1,字符串2)  -  将字符串2中满足正则表达式的子串全部替换成字符串1；返回值是替换后的字符串</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = re.sub(<span class="string">r'\d+'</span>, <span class="string">'and'</span>, <span class="string">'暗红色的83大黄金黄色的9罚款0233s闪电发货890'</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<h2 id="9-参数flags"><a href="#9-参数flags" class="headerlink" title="9.参数flags"></a>9.参数flags</h2><p>以上所有的函数都有一个参数flags, 可以加re.I表示匹配的时候忽略大小写；加re.S表示单行匹配(默认是多行匹配re.M)<br>多行和单行的主要区别: 多行匹配.不能和\n进行匹配；单行.可以和\n进行匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(re.fullmatch(<span class="string">r'a.b'</span>, <span class="string">'a\nb'</span>))   <span class="comment"># None</span></span><br><span class="line">print(re.fullmatch(<span class="string">r'a.b'</span>, <span class="string">'a\nb'</span>, flags=re.S))</span><br><span class="line"></span><br><span class="line">print(re.search(<span class="string">r'a.+b'</span>, <span class="string">'世纪东方anmb\n是否b大括号'</span>))</span><br><span class="line">print(re.search(<span class="string">r'a.+b'</span>, <span class="string">'世纪东方anmb\n是否b大括号'</span>, re.S))</span><br></pre></td></tr></table></figure>

<h3 id="附上整理的表格"><a href="#附上整理的表格" class="headerlink" title="附上整理的表格"></a>附上整理的表格</h3><p><img src="https://upload-images.jianshu.io/upload_images/20010076-f46a5dcaef681b9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整理表格"></p>
]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：19:网络编程基础</title>
    <url>/2018/08/08/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.19%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="一-socket编程"><a href="#一-socket编程" class="headerlink" title="一. socket编程"></a>一. socket编程</h1><ul>
<li>socket又叫套接字</li>
<li>socket编程其实就是用代码来实现进行网络通信的两个端；套接字就是实现通信的两个程序</li>
<li>实现通信的两个端分为 <strong>服务器</strong> 和 <strong>客户端</strong> 两种</li>
<li>python通过 <strong>socket模块</strong> 来提供socket编程相关的类和方法</li>
</ul>
<hr>
<h1 id="二-服务器端"><a href="#二-服务器端" class="headerlink" title="二. 服务器端"></a>二. 服务器端</h1><p><strong>(注:以下操作中服务器端和客户端分两个py文件实现)</strong></p>
<h2 id="1-创建套接字对象-买电话机"><a href="#1-创建套接字对象-买电话机" class="headerlink" title="1. 创建套接字对象(买电话机)"></a>1. 创建套接字对象(买电话机)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">socket(family=AF_INET, type=SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># family - 设置ip类型; AF_INET对应的是ipv4; AF_INET6对应的是ipv6</span></span><br><span class="line"><span class="comment"># type - 设置传输类型;  SOCK_STREAM对应的是TCP协议; SOCK_DGRAM对应的是UDP协议</span></span><br></pre></td></tr></table></figure>

<h2 id="2-绑定IP和端口-插电话线"><a href="#2-绑定IP和端口-插电话线" class="headerlink" title="2. 绑定IP和端口(插电话线)"></a>2. 绑定IP和端口(插电话线)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bind((ip地址, 端口))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ip地址: 找到互联网中唯一的一台计算机; 赋值ip地址对应的字符串</span></span><br><span class="line"><span class="comment"># 端口: 区分同一台计算机中不同的服务(程序); 赋整数,值的范围是0~65535, 其中0~1024属于著名，不能随便用。</span></span><br><span class="line"><span class="comment"># 同一时间同一个端口只能对应一个服务</span></span><br></pre></td></tr></table></figure>

<h2 id="3-开始监听-等电话"><a href="#3-开始监听-等电话" class="headerlink" title="3. 开始监听(等电话)"></a>3. 开始监听(等电话)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server.listen(N)</span><br><span class="line"></span><br><span class="line"><span class="comment"># N : 表示能同时接通的"电话"的数量</span></span><br></pre></td></tr></table></figure>

<h2 id="4-接受客户端请求-接电话"><a href="#4-接受客户端请求-接电话" class="headerlink" title="4. 接受客户端请求(接电话)"></a>4. 接受客户端请求(接电话)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">connection, address = server.accept()</span><br><span class="line"></span><br><span class="line"><span class="comment"># connection : 服务器接收的客户端的分机对象</span></span><br><span class="line"><span class="comment"># address : 该客户端的IP地址</span></span><br><span class="line"><span class="comment"># 返回为这个客户端创建的独立的套接字对象(分机)和客户端的地址</span></span><br><span class="line"><span class="comment"># 当程序运行到这句代码的时候会停下来，直到有请求为止</span></span><br></pre></td></tr></table></figure>

<h2 id="5-接收消息-听对方说话"><a href="#5-接收消息-听对方说话" class="headerlink" title="5. 接收消息(听对方说话)"></a>5. 接收消息(听对方说话)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#分机对象 . recv(一次性能够接收的数据的大小)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#返回接收到的数据, 数据类型是二进制</span></span><br></pre></td></tr></table></figure>

<h2 id="6-发送消息-说话给别人听"><a href="#6-发送消息-说话给别人听" class="headerlink" title="6. 发送消息(说话给别人听)"></a>6. 发送消息(说话给别人听)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分机对象.send(需要发送的数据)</span></span><br></pre></td></tr></table></figure>

<h2 id="7-关闭连接-挂电话"><a href="#7-关闭连接-挂电话" class="headerlink" title="7. 关闭连接(挂电话)"></a>7. 关闭连接(挂电话)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分机对象.close()</span></span><br></pre></td></tr></table></figure>

<br>

<hr>
<blockquote>
<p><strong>一个完整的服务器端</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">server = socket()</span><br><span class="line">server.bind((<span class="string">'192.168.10.234'</span>, <span class="number">5200</span>)) <span class="comment"># ip地址可以用自己电脑的IP, 端口随便,只要不是0-1024</span></span><br><span class="line">server.listen(<span class="number">50</span>) <span class="comment"># 表示这个服务器可以同时和50个客户端进行通信</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 保证通话一直进行</span></span><br><span class="line">    print(<span class="string">'正在监听...'</span>)</span><br><span class="line">    connection, address = server.accept() <span class="comment"># 接受客户端请求,并创建分机对象connection, 返回分机地址address</span></span><br><span class="line">    recv_data = connection.recv(<span class="number">1024</span>).decode(encoding=<span class="string">'utf-8'</span>) <span class="comment"># 接收客户端发来的数据,并将二进制转换成字符串(.decode方法)</span></span><br><span class="line">    print(<span class="string">'recv_data'</span>) <span class="comment"># 打印接收到的数据</span></span><br><span class="line">    massage = input(<span class="string">'请输入发送内容:'</span>) <span class="comment"># 输入要发送的内容</span></span><br><span class="line">    connection.send(massage) <span class="comment"># 发送数据</span></span><br><span class="line">    connection.close() <span class="comment"># 关闭对话</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="三-客户端"><a href="#三-客户端" class="headerlink" title="三. 客户端"></a>三. 客户端</h1><h2 id="1-创建套接字对象-买电话"><a href="#1-创建套接字对象-买电话" class="headerlink" title="1. 创建套接字对象(买电话)"></a>1. 创建套接字对象(买电话)</h2><p>client = socket()</p>
<h2 id="2-连接服务器"><a href="#2-连接服务器" class="headerlink" title="2. 连接服务器"></a>2. 连接服务器</h2><p>client.connect((‘192.168.10.234’, 5200))</p>
<h2 id="3-发送消息"><a href="#3-发送消息" class="headerlink" title="3. 发送消息"></a>3. 发送消息</h2><p>client.send()</p>
<h2 id="4-接收消息"><a href="#4-接收消息" class="headerlink" title="4. 接收消息"></a>4. 接收消息</h2><p>client.recv()</p>
<h2 id="5-断开连接"><a href="#5-断开连接" class="headerlink" title="5. 断开连接"></a>5. 断开连接</h2><p>client.close()</p>
<blockquote>
<p><strong>一个完整的客户端</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">client = socket()</span><br><span class="line">client.connect((<span class="string">'192.168.10.234'</span>, <span class="number">5200</span>))</span><br><span class="line">client.send(<span class="string">'服务器你好吗？'</span>.encode())</span><br><span class="line">re_data = client.recv(<span class="number">1024</span>)</span><br><span class="line">print(re_data.decode(encoding=<span class="string">'utf-8'</span>))</span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="四-其他骚操作"><a href="#四-其他骚操作" class="headerlink" title="四. 其他骚操作"></a>四. 其他骚操作</h1><h2 id="1-一对一持续通信"><a href="#1-一对一持续通信" class="headerlink" title="1. 一对一持续通信"></a>1. 一对一持续通信</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""服务器端"""</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">server = socket()</span><br><span class="line">server.bind((<span class="string">'10.7.156.55'</span>, <span class="number">9999</span>))</span><br><span class="line">server.listen(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    print(<span class="string">'正在监听...'</span>)</span><br><span class="line">    connection, address = server.accept()</span><br><span class="line">    <span class="comment"># 持续通信</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        re_data = connection.recv(<span class="number">1024</span>)</span><br><span class="line">        re_massage = re_data.decode(encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        print(<span class="string">'client:'</span>, re_massage)</span><br><span class="line">        <span class="keyword">if</span> re_massage == <span class="string">'再见'</span>:</span><br><span class="line">            connection.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        massage = input(<span class="string">'server:'</span>)</span><br><span class="line">        connection.send(massage.encode())</span><br><span class="line">        <span class="keyword">if</span> massage == <span class="string">'再见'</span>:</span><br><span class="line">            connection.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""客户端"""</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client = socket()</span><br><span class="line">client.connect((<span class="string">'10.7.156.55'</span>, <span class="number">9999</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    massage = input(<span class="string">'client:'</span>)</span><br><span class="line">    <span class="comment"># for _ in range(10):</span></span><br><span class="line">    client.send(massage.encode())</span><br><span class="line">    <span class="keyword">if</span> massage == <span class="string">'拜拜'</span>:</span><br><span class="line">        client.close()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    re_massage = client.recv(<span class="number">1024</span>).decode(encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    print(<span class="string">'server:'</span>, re_massage)</span><br><span class="line">    <span class="keyword">if</span> re_massage == <span class="string">'拜拜'</span>:</span><br><span class="line">        client.close()</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h2 id="2-发送图片"><a href="#2-发送图片" class="headerlink" title="2. 发送图片"></a>2. 发送图片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""服务器端"""</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">server = socket()</span><br><span class="line">server.bind((<span class="string">'10.7.156.55'</span>, <span class="number">8000</span>))</span><br><span class="line">server.listen(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    connection, address = server.accept()</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'../code/1024x1024.jpg'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">    connection.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""客户端"""</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client = socket()</span><br><span class="line">client.connect((<span class="string">'10.7.156.55'</span>, <span class="number">8000</span>))</span><br><span class="line"><span class="comment"># 接收图片长度</span></span><br><span class="line">total_length = int(client.recv(<span class="number">1024</span>).decode())</span><br><span class="line">print(<span class="string">'第一次:'</span>, total_length)</span><br><span class="line">sum_data = bytes()   <span class="comment"># 保存接收到的图片的总数据</span></span><br><span class="line"><span class="comment"># 接收图片</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    re_data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    sum_data += re_data</span><br><span class="line">    <span class="keyword">if</span> len(sum_data) == total_length:</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'client/test1.wav'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(sum_data)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<hr>
<p>完结撒花</p>
]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：20:多线程基础</title>
    <url>/2018/08/10/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.20%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><strong>一个应用程序在运行时就是一个进程,一个进程默认只有一个主线程,也可以有多个进程,同时执行不同的任务;本次课程主要是实现如何让进程可以进行多线程工作</strong></p>
<blockquote>
<p>一个进程就像一个工厂,多个进程就像工厂例的工人,每个工人之间的工作相互之间不影响</p>
</blockquote>
<p><strong>让一个进程多线程工作有两种实现方式:</strong><br>①.直接导入treading模块种的Tread类并创建子线程对象<br>②.导入treading模块种的Tread类,创建一个Tread的子类,并用这个子类创建子线程对象</p>
<h1 id="一-在进程种创建Tread类的对象"><a href="#一-在进程种创建Tread类的对象" class="headerlink" title="一. 在进程种创建Tread类的对象"></a>一. 在进程种创建Tread类的对象</h1><h2 id="1-创建线程对象-子线程"><a href="#1-创建线程对象-子线程" class="headerlink" title="1. 创建线程对象 - 子线程"></a>1. 创建线程对象 - 子线程</h2><p><strong>线程对象 = Thread(target=函数, args=元组)</strong><br>说明:<br>target  -  函数，需要在子线程中执行的任务(会在子线程中调用)<br>args  -   target对应的函数在调用的时候传的参数</p>
<h2 id="2-让子线程执行子线程中的任务"><a href="#2-让子线程执行子线程中的任务" class="headerlink" title="2. 让子线程执行子线程中的任务"></a>2. 让子线程执行子线程中的任务</h2><p><strong>线程对象.start()</strong><br>在子线程中调用target对用的函数，并且将args中的元素作为参数</p>
<p>比如在一个进程中模拟下载电影:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> treading <span class="keyword">import</span> Tread</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self, movie_name)</span></span></span><br><span class="line"><span class="function">	<span class="title">print</span><span class="params">(<span class="string">'%s开始下载了,开始时间是%s'</span> % <span class="params">(movie_name, datetime.time<span class="params">()</span>)</span>)</span></span></span><br><span class="line"><span class="function">	<span class="title">time</span>.<span class="title">sleep</span><span class="params">(<span class="number">5</span>)</span></span></span><br><span class="line"><span class="function">	<span class="title">print</span><span class="params">(<span class="string">'%s下载完成了,完成时间是%s'</span> % <span class="params">(movie_name, datetime.time<span class="params">()</span>)</span>)</span></span></span><br><span class="line"><span class="function">	</span></span><br><span class="line"><span class="function"># 创建线程对象 - 子线程</span></span><br><span class="line">t1 = Tread(target=download, args=('暮光之城'))</span><br><span class="line">t2 = Tread(target=download, args=(<span class="string">'两只老虎'</span>))</span><br><span class="line">t3 = Tread(target=download, args=(<span class="string">'卧虎藏龙'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让子线程执行子线程中的任务</span></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t3.start()</span><br></pre></td></tr></table></figure>

<h1 id="二-在进程种创建Tread类的子类的对象"><a href="#二-在进程种创建Tread类的子类的对象" class="headerlink" title="二. 在进程种创建Tread类的子类的对象"></a>二. 在进程种创建Tread类的子类的对象</h1><p>还是下载电影的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> treading <span class="keyword">import</span> Tread</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadTread</span><span class="params">(Tread)</span>:</span> <span class="comment"># 创建Tread的子类</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mvoie_name)</span> # 创建子类的对象属性</span></span><br><span class="line"><span class="function">	<span class="title">super</span><span class="params">()</span>.<span class="title">__init__</span><span class="params">()</span> # 继承父类的属性</span></span><br><span class="line">	self.movie_name = movie_name</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># run方法是在子线程中自动调用的,除了self之外不能有其他的参数</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">		print(<span class="string">'%s开始下载,开始时间是:%s'</span> % (self.movie_name, datetime.now()))</span><br><span class="line">		time.sleep(<span class="number">5</span>)</span><br><span class="line">		print(<span class="string">'%s下载结束,结束时间是:%s'</span> % (self.movie_name, datetime.now()))</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">t1 = DownloadTead(<span class="string">'暮光之城'</span>)</span><br><span class="line">t2 = DownloadTead(<span class="string">'两只老虎'</span>)</span><br><span class="line">t3 = DownloadTead(<span class="string">'卧虎藏龙'</span>)</span><br><span class="line"></span><br><span class="line">t1.start</span><br><span class="line">t3.start</span><br><span class="line">t2.start</span><br></pre></td></tr></table></figure>

<blockquote>
<p>join的用法<br>线程对象.join()<br>其他代码</p>
</blockquote>
<p>这儿的其他代码会在线程对象中的任务执行完后才执行</p>
]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：2:变量和运算符</title>
    <url>/2018/04/05/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.2%20%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h1><h3 id="1、变量"><a href="#1、变量" class="headerlink" title="1、变量"></a>1、变量</h3><ul>
<li>变量是用来申请空间保存数据的<br>变量的公式：<strong>变量名 = 值</strong></li>
</ul>
<h3 id="2、说明"><a href="#2、说明" class="headerlink" title="2、说明"></a>2、说明</h3><ul>
<li>变量名：自由命名，但要遵循一下要求和规范<br><strong>要求</strong>:<br>是标识符（1.由数字、字母和下划线组成；2.数字不能开头），不能是关键字<br><strong>规范</strong>:<br>1.见名知义：看到变量名，知道变量里存的什么数据<pre><code>2.满足PEP8命名规范：变量名内所有字母都小写，如果由多个单词组成变量名，则多个单词之间用下划线隔开
3.不能用系统提供的函数名、类名、库名等系统相关的名来给变量命名</code></pre></li>
<li>值：可以是任何有结果的表达式；例如：数据，已经赋值过的比那辆、运算表达式等</li>
</ul>
<h3 id="3、变量的使用"><a href="#3、变量的使用" class="headerlink" title="3、变量的使用"></a>3、变量的使用</h3><p>使用变量就是在使用变量里面的值;变量中的值可以修改大小和类型</p>
<h3 id="4、同时声明多个变量"><a href="#4、同时声明多个变量" class="headerlink" title="4、同时声明多个变量"></a>4、同时声明多个变量</h3><ul>
<li>同时声明多个变量赋相同的值<br>变量1 = 变量2 = 变量3 = … = 值</li>
<li>同时声明多个变量赋不同的值<br>变量1，变量2，变量3，…=值1，值2，值3…</li>
</ul>
<h3 id="5、python声明变量的原理"><a href="#5、python声明变量的原理" class="headerlink" title="5、python声明变量的原理"></a>5、python声明变量的原理</h3><p>根据变量的大小申请的相应大小的内存，将变量名和数据对应的内存空间关联在一起；<br>在python中用一个变量给另外一个变量赋值的时候是将原来的变量的地址赋给另外一个变量，赋值完成后，数据只有一份。</p>
<br>

<p><strong>变量三要素：<br>1.类型  -  给变量复制的数据的类型  -  type（变量）<br>2.地址  -  给变量复制的数据在内存中的地址，也是正真存储的东西  -  id（变量）<br>3.值  -  给变量复制的数据</strong></p>
<br>

<hr>
<h1 id="二、运算符"><a href="#二、运算符" class="headerlink" title="二、运算符"></a>二、运算符</h1><h3 id="一-、数学运算符"><a href="#一-、数学运算符" class="headerlink" title="(一)、数学运算符"></a>(一)、数学运算符</h3><h6 id="1、加减乘除：-emsp-emsp-emsp"><a href="#1、加减乘除：-emsp-emsp-emsp" class="headerlink" title="1、加减乘除：+&emsp;   -&emsp;   *&emsp;   /"></a>1、加减乘除：+&emsp;   -&emsp;   *&emsp;   /</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">10</span> + <span class="number">3</span>)</span><br><span class="line">print(<span class="number">10</span> - <span class="number">3</span>)</span><br><span class="line">print(<span class="number">10</span> * <span class="number">3</span>)</span><br><span class="line">print(<span class="number">10</span> / <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h6 id="2、取余-取模-求余数："><a href="#2、取余-取模-求余数：" class="headerlink" title="2、取余/取模/求余数：%"></a>2、取余/取模/求余数：%</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">123</span></span><br><span class="line">print(num % <span class="number">10</span>)   <span class="comment">#取个位</span></span><br><span class="line">print(num % <span class="number">100</span>)   <span class="comment">#取个位和十位</span></span><br></pre></td></tr></table></figure>
<p>应用：<br>1、判断正数的奇偶性 - 判断该数对2取余结果是否为0<br>2、判断是否能整除<br>3、取低位数  </p>
<h6 id="3、整除：-（商只取整数部分）"><a href="#3、整除：-（商只取整数部分）" class="headerlink" title="3、整除：//（商只取整数部分）"></a>3、整除：//（商只取整数部分）</h6><p>应用：取高位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(num // <span class="number">100</span>)   <span class="comment">#取高位1</span></span><br></pre></td></tr></table></figure>
<p><strong><em>注：负数的整除，取了结果之后减1</em></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">-9</span> // <span class="number">2</span>) = <span class="number">-5</span></span><br></pre></td></tr></table></figure>
<h6 id="4、幂运算：-（x-y-–-x的y次方）"><a href="#4、幂运算：-（x-y-–-x的y次方）" class="headerlink" title="4、幂运算：**  （x**y –  x的y次方）"></a>4、幂运算：**  （x**y –  x的y次方）</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">2</span> ** <span class="number">3</span>)</span><br><span class="line">print(<span class="number">16</span> ** (<span class="number">1</span>/<span class="number">2</span>))   <span class="comment">#开方</span></span><br><span class="line">print(<span class="number">8</span> ** (<span class="number">1</span>/<span class="number">3</span>))   <span class="comment">#开方</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="（二）、比较运算符"><a href="#（二）、比较运算符" class="headerlink" title="（二）、比较运算符"></a>（二）、比较运算符</h3><p><strong><em>所有的比较运算符的运算结果都是布尔值</em></strong><br>1、大于、小于、大于等于、小于等于：&gt;  &lt;  &gt;=  &lt;=</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">30</span> &gt;= <span class="number">20</span>)</span><br><span class="line">print(<span class="number">30</span> &gt;= <span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p>2、等于、不等于：==  !=   –  判断两个值是否相等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">10</span> == <span class="number">10</span>)</span><br><span class="line">print(<span class="number">10</span> != <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>3、python可以用连续的比较运算符表示范围</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">30</span></span><br><span class="line">print(<span class="number">28</span> &lt; age &lt; <span class="number">40</span>)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="（三）、逻辑运算符"><a href="#（三）、逻辑运算符" class="headerlink" title="（三）、逻辑运算符"></a>（三）、逻辑运算符</h3><p><strong><em>逻辑运算的对象和结果都是布尔值</em></strong><br><strong>1、and (逻辑与)</strong><br>1）、运算规则：两个都是True结果才是True，只要有一个是False结果就是False<br>2）、使用场景：需要多个条件同时满足</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断一个数是否能同时被3和7整除</span></span><br><span class="line">num = input(<span class="string">'请输入数值：'</span>)</span><br><span class="line">rem1 = int(num) % <span class="number">3</span></span><br><span class="line">rem2 = int(num) % <span class="number">7</span></span><br><span class="line">print(<span class="string">'是否能同时被3和7整除：'</span>,rem1 == <span class="number">0</span> <span class="keyword">and</span> rem2 == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><strong>2、or (逻辑或)</strong><br>1）、运算规则：两个都是False结果才是False，只要有一个是True结果就是True<br>2）、使用场景：多个条件中有一个田间满足就行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断一个数是否能被3或被7整除</span></span><br><span class="line">num = input(<span class="string">'请输入数值：'</span>)</span><br><span class="line">rem1 = int(num) % <span class="number">3</span></span><br><span class="line">rem2 = int(num) % <span class="number">7</span></span><br><span class="line">print(<span class="string">'是否能被3或被7整除：'</span>,rem1 == <span class="number">0</span> <span class="keyword">or</span> rem2 == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><strong>3、not (逻辑非)</strong><br>1）、运算规则：True变False，False变True<br>2）、使用场景：对一个条件进行否定</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一个数不能同时被3和7整除的条件</span></span><br><span class="line">num = input(<span class="string">'请输入数值：'</span>)</span><br><span class="line">rem1 = int(num) % <span class="number">3</span></span><br><span class="line">rem2 = int(num) % <span class="number">7</span></span><br><span class="line">print(<span class="string">'不能同时被3和7整除：'</span>,<span class="keyword">not</span> (rem1 == <span class="number">0</span> <span class="keyword">and</span> rem2 == <span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<br>

<h3 id="（四）、赋值运算符"><a href="#（四）、赋值运算符" class="headerlink" title="（四）、赋值运算符"></a>（四）、赋值运算符</h3><p>= ， += ，-= ，<em>= ，/= ，%= ，//= ，*</em>=<br>所有赋值运算符的左边必须是变量，组合赋值运算符的左边除了是变量，这个变量还必须是已经声明过的。<br>1)、 变量 = 值  -&gt;  将右边的值赋给左边的变量<br>2)、 组合赋值运算符<br>已经声明过的变量 += 值  -&gt;  变量 = 变量 + 值</p>
<hr>
<p><strong><em>运算符优先级：</em></strong></p>
<p>数学运算符 &gt; 比较运算符 &gt; 逻辑运算符 &gt; 赋值运算符</p>
<p><strong><em>数学运算符优先级：</em></strong></p>
<p>** &gt;  *,/,//,%(优先级相同)  &gt;   + ,-</p>
<p>如果有括号则先算括号</p>
<br>

<h3 id="（五）、位运算"><a href="#（五）、位运算" class="headerlink" title="（五）、位运算"></a>（五）、位运算</h3><p><strong><em>所有的位运算都是针对数字的补码进行操作的</em></strong><br>位运算符：&amp;(与)、|(或)、~(取反)、^(异或)、&lt;&lt;(左移)、&gt;&gt;(右移)<br><strong>1、&amp;(按位与)</strong><br>1）、运算规则：补码每一位上的数都是1结果就是1，如果有一个0结果就是0<br>例：1110 &amp; 0111 = 0110<br>2）、运用：高效判断数字的奇偶性<br>&emsp;将数字和1进行按位与运算，判断结果是0（偶数）还是1（奇数）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">3</span> &amp; <span class="number">1</span>, <span class="number">7</span> &amp; <span class="number">1</span>,<span class="number">19</span> &amp; <span class="number">1</span>)</span><br><span class="line">print(<span class="number">4</span> &amp; <span class="number">1</span>, <span class="number">128</span> &amp; <span class="number">1</span>,<span class="number">800</span> &amp; <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><strong>2、| (按位或)</strong><br>1）、运算规则：补码每一位上的数都是0结果就是0，如果有一个1结果就是1<br>例：1110 | 0111 = 1111<br><strong>3、~ (按位取反)、单目运算</strong><br>例：~1101 =  0010<br><strong>4、^ (异或)</strong><br>运算规则：每一位上的数相同为0，不同为1<br>例：1110 ^ 0111 = 1001<br><strong>5、&lt;&lt; (左移)</strong><br><strong><em>数字 &lt;&lt; N</em></strong>   &emsp;指定的数字的补码整体向左移动N位；<br><strong><em>计算：数字*2**N</em></strong><br><strong>6、&gt;&gt; (右移)</strong><br><strong><em>数字 &gt;&gt; N</em></strong>   &emsp;指定的数字的补码整体向右移动N位；<br><strong><em>计算：数字//2**N</em></strong></p>
]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：3:循环结构与分支结构</title>
    <url>/2018/04/18/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.3%20%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="一、分支结构"><a href="#一、分支结构" class="headerlink" title="一、分支结构"></a>一、分支结构</h1><h3 id="1、if-结构-（满足条件就执行某个操作，不满足就不执行。）"><a href="#1、if-结构-（满足条件就执行某个操作，不满足就不执行。）" class="headerlink" title="1、if 结构 （满足条件就执行某个操作，不满足就不执行。）"></a>1、if 结构 （满足条件就执行某个操作，不满足就不执行。）</h3><h6 id="1）、语法结构"><a href="#1）、语法结构" class="headerlink" title="1）、语法结构"></a>1）、语法结构</h6><p><strong><em>if 条件语句：<br>&emsp;代码段</em></strong></p>
<h6 id="2）、说明"><a href="#2）、说明" class="headerlink" title="2）、说明"></a>2）、说明</h6><ul>
<li>if——&gt;关键字，固定写法</li>
<li>条件语句——&gt;任何有结果的表达式都可以：数据，已经声明过的变量，运算表达式；<strong><em>不能是赋值</em></strong></li>
<li>:（冒号） ——&gt;固定写法，（一般出现冒号的位置，后面一般都会产生缩进）</li>
<li>代码段——&gt;和if保持一个缩进的一条或多条语句；需要满足条件才执行的代码</li>
</ul>
<h6 id="3-执行过程"><a href="#3-执行过程" class="headerlink" title="3)执行过程"></a>3)执行过程</h6><p>先判断条件语句的结果是否为True（如果条件语句的结果不是布尔值，就先转换成布尔值）<br>如果为True就执行代码段，否则代码段不执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">11</span></span><br><span class="line"><span class="keyword">if</span> num &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'偶数'</span>)</span><br></pre></td></tr></table></figure>



<h3 id="2、if-else-结构（满足条件执行操作，不满足条件执行另外一个操作）"><a href="#2、if-else-结构（满足条件执行操作，不满足条件执行另外一个操作）" class="headerlink" title="2、if - else 结构（满足条件执行操作，不满足条件执行另外一个操作）"></a>2、if - else 结构（满足条件执行操作，不满足条件执行另外一个操作）</h3><h6 id="1）、语法结构-1"><a href="#1）、语法结构-1" class="headerlink" title="1）、语法结构"></a>1）、语法结构</h6><p><strong><em>if 条件语句：<br>&emsp;代码段1 （满足条件执行）<br>else：<br>&emsp;代码段2 （不满足条件执行）</em></strong></p>
<h6 id="2）、说明-1"><a href="#2）、说明-1" class="headerlink" title="2）、说明"></a>2）、说明</h6><p>先判断条件语句的结果是否为True（如果条件语句的结果不是布尔值，就先转换成布尔值）<br>如果为True就执行代码段1，否则执行代码段2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'已成年'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'未成年'</span>)</span><br></pre></td></tr></table></figure>



<h3 id="3、if-elif-else-结构"><a href="#3、if-elif-else-结构" class="headerlink" title="3、if - elif - else 结构"></a>3、if - elif - else 结构</h3><h6 id="1）、语法结构-2"><a href="#1）、语法结构-2" class="headerlink" title="1）、语法结构"></a>1）、语法结构</h6><p><strong><em>if 条件语句：<br>&emsp;代码段1<br>elif 条件语句：<br>&emsp;代码段2<br>&emsp;&emsp;.<br>&emsp;&emsp;.<br>&emsp;&emsp;.<br>else:<br>&emsp;代码段N<br>其他代码</em></strong></p>
<h6 id="2）、执行过程"><a href="#2）、执行过程" class="headerlink" title="2）、执行过程"></a>2）、执行过程</h6><p>先判断田间语句1 是否为True，为True就执行代码段1，然后整个if-elif-else结构结束<br>如果为False，就判断条件语句2是否为True，为True就执行代码段2，然后整个if-elif-else结构结束<br>以此类推<br>如果所有条件语句都不成立，执行else后面的代码段</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据年龄范围打印：少年(14以下)、青年(14~25)、壮年(26~35)、中年(36~50)、老年(50以上)</span></span><br><span class="line">age = int(input(<span class="string">'请输入你的年龄：'</span>))</span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">0</span> <span class="keyword">or</span> age &gt;<span class="number">150</span>:</span><br><span class="line">    print(<span class="string">'年龄不合法'</span>)</span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">14</span>:</span><br><span class="line">    print(<span class="string">'少年'</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">14</span> &lt; age &lt;= <span class="number">25</span>:</span><br><span class="line">    print(<span class="string">'青年'</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">26</span> &lt; age &lt;= <span class="number">35</span>:</span><br><span class="line">    print(<span class="string">'壮年'</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">36</span> &lt; age &lt;= <span class="number">50</span>:</span><br><span class="line">    print(<span class="string">'中年'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'老年'</span>)</span><br></pre></td></tr></table></figure>


<h3 id="4、if-的嵌套"><a href="#4、if-的嵌套" class="headerlink" title="4、if 的嵌套"></a>4、if 的嵌套</h3><p><strong>if结构中的代码段中可以再出现其他的if语句</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断一个数是否是偶数，并且再判断这个数是否是4的倍数，并打出结论</span></span><br><span class="line">num = <span class="number">9</span></span><br><span class="line"><span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:   <span class="comment"># if num &amp; 1 == 0:</span></span><br><span class="line">    print(<span class="string">'偶数'</span>)</span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'是4的倍数'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'奇数'</span>)</span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">10</span> == <span class="number">3</span>:</span><br><span class="line">        print(<span class="string">'个位数是3'</span>)</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="二、循环结构"><a href="#二、循环结构" class="headerlink" title="二、循环结构"></a>二、循环结构</h1><h3 id="1、for-循环"><a href="#1、for-循环" class="headerlink" title="1、for 循环"></a>1、for 循环</h3><h6 id="1）、语法结构-3"><a href="#1）、语法结构-3" class="headerlink" title="1）、语法结构"></a>1）、语法结构</h6><p>for 变量 in 序列：<br>&emsp;循环体</p>
<h6 id="2）、说明-2"><a href="#2）、说明-2" class="headerlink" title="2）、说明"></a>2）、说明</h6><ul>
<li>for——&gt;关键字，固定写法</li>
<li>变量名——&gt;标识符，声明变量的要求一样（当这个变量在循环中用不到时可以用下划线命名）</li>
<li>in——&gt;关键字，固定写法</li>
<li>序列——&gt;结果是容器型数据；字符串，列表，字典，元组，集合，迭代器，生成器，range</li>
<li>：（冒号）——&gt;固定写法</li>
<li>循环体——&gt;和for保持一个缩进的一条或者多条语句：需要重复执行的语句</li>
</ul>
<h6 id="3）、执行过程"><a href="#3）、执行过程" class="headerlink" title="3）、执行过程"></a>3）、执行过程</h6><p>让变量取序列中取值，每取一个值，执行一次循环体<br>(for循环可以通过控制序列中元素的数量来控制循环的次数)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'abcd'</span>:</span><br><span class="line">    print(<span class="string">'==='</span>)</span><br></pre></td></tr></table></figure>
<p><strong><em>注意：在for循环中，如果变量取出来的值用不到，则可以用下划线（_）给变量命名</em></strong></p>
<h3 id="2、range-函数-（控制for循环的次数）"><a href="#2、range-函数-（控制for循环的次数）" class="headerlink" title="2、range 函数 （控制for循环的次数）"></a>2、range 函数 （控制for循环的次数）</h3><h6 id="1）、range函数的作用"><a href="#1）、range函数的作用" class="headerlink" title="1）、range函数的作用"></a>1）、range函数的作用</h6><ul>
<li>1、产生指定的数字序列</li>
<li>2、控制循环次数</li>
</ul>
<h6 id="2）、range-函数的用法"><a href="#2）、range-函数的用法" class="headerlink" title="2）、range 函数的用法"></a>2）、range 函数的用法</h6><p>&emsp;N 是正整数</p>
<ul>
<li><strong>1、range(N)          -     产生0~N-1的数字序列</strong><br>range(4) -&gt; 0,1,2,3<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure></li>
<li><strong>2、range(M,N)        -     产生M~N-1的数字序列</strong><br>range(3,10) -&gt; 3,4,5,6,7,8,9<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>,<span class="number">10</span>):</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure></li>
<li><strong>3、range(M,N,step)   -     从M开始每隔step产生下一个数字，到N前一个数为止</strong><br>range(0,10,2) -&gt; 0,2,4,6,8<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>):</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 练习1，打印0-100中所有能被3整除的数</span></span><br><span class="line"><span class="comment"># 方法1：</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">101</span>):</span><br><span class="line">    <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        print(x)</span><br><span class="line"><span class="comment"># 方法2：</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">101</span>,<span class="number">3</span>):</span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习2，统计1-100中能被4整除并且个位数是2的数字的个数</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line">    <span class="keyword">if</span> x % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> x % <span class="number">10</span> == <span class="number">2</span>:</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">print(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习3.计算1+2+3+...+100</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line">    sum += x</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>



<h3 id="3、while-循环"><a href="#3、while-循环" class="headerlink" title="3、while 循环"></a>3、while 循环</h3><h6 id="1）、语法结构-4"><a href="#1）、语法结构-4" class="headerlink" title="1）、语法结构"></a>1）、语法结构</h6><p><strong><em>while 条件语句：<br>&emsp;循环体</em></strong></p>
<h6 id="2）、说明-3"><a href="#2）、说明-3" class="headerlink" title="2）、说明"></a>2）、说明</h6><ul>
<li>while——&gt;关键字，固定写法</li>
<li>条件语句——&gt;任何有结果的表达式：数据，声明过的变量，运算表达式等（不能是赋值语句）</li>
<li>：(冒号)——&gt;固定写法</li>
<li>循环体——&gt;和while保持一个缩进的一条或者多条语句；（需要重复执行的额语句）</li>
</ul>
<h6 id="3）、执行过程-1"><a href="#3）、执行过程-1" class="headerlink" title="3）、执行过程"></a>3）、执行过程</h6><p>先判断条件语句是否为True，如果为True就执行循环体，执行完循环体再判断条件语句是否为True<br>为True又执行循环体，以此类推，直到循环体的结果是Fals循环结束</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> num &lt; <span class="number">5</span>:</span><br><span class="line">  print(<span class="string">'我爱你'</span>)</span><br><span class="line">  num += <span class="number">1</span></span><br></pre></td></tr></table></figure>


<h4 id="思考：什么时候用-for-，什么时候用-while-？"><a href="#思考：什么时候用-for-，什么时候用-while-？" class="headerlink" title="思考：什么时候用 for ，什么时候用 while ？"></a>思考：什么时候用 for ，什么时候用 while ？</h4><ul>
<li><strong>用 for 循环的情况：</strong><br>当循环次数确定<br>遍历元素的时候</li>
<li><strong>用 while 循环的情况</strong><br>死循环<br>循环次数不确定</li>
</ul>
<h4 id="练习：猜数字"><a href="#练习：猜数字" class="headerlink" title="练习：猜数字"></a>练习：猜数字</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">num1 = randint(<span class="number">100</span>)</span><br><span class="line">num2 = int(input(<span class="string">'请输入数字'</span>))</span><br><span class="line"><span class="keyword">while</span> num1 != num2:</span><br><span class="line">  <span class="keyword">if</span> num1 &gt; num2:</span><br><span class="line">    print(<span class="string">'这个数小了'</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'这个数大了'</span>)</span><br><span class="line">  num2 = int(input(<span class="string">'请输入数字'</span>))</span><br><span class="line">print(<span class="string">'恭喜你答对了'</span>)</span><br></pre></td></tr></table></figure>



<h3 id="4、循环结构中的关键字"><a href="#4、循环结构中的关键字" class="headerlink" title="4、循环结构中的关键字"></a>4、循环结构中的关键字</h3><h6 id="1）、continue"><a href="#1）、continue" class="headerlink" title="1）、continue"></a>1）、continue</h6><p><strong>当执行循环体的时候，如果遇到continue那么此循环直接结束，直接进入下次循环的判断</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">  print(<span class="string">'x'</span>)</span><br><span class="line">  print(<span class="string">'我是循环结果1'</span>)</span><br><span class="line">  <span class="keyword">continue</span></span><br><span class="line">  print(<span class="string">'我是循环结果2'</span></span><br></pre></td></tr></table></figure>
<h6 id="2）、break"><a href="#2）、break" class="headerlink" title="2）、break"></a>2）、break</h6><p><strong>当执行循环体时，如果遇到break，那么整个循环直接结束，执行循环后的其他代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  x = int(input(<span class="string">'请输入数字'</span>))</span><br><span class="line">  <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">     <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">if</span> x &amp; <span class="number">1</span> == <span class="number">0</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  sum += x</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>
<h6 id="3）、else"><a href="#3）、else" class="headerlink" title="3）、else"></a>3）、else</h6><ul>
<li>1）、完整的for循环</li>
</ul>
<p><strong><em>for 变量 in 序列：<br>&emsp;循环体<br>else：<br>&emsp;代码段</em></strong></p>
<ul>
<li>2）、完整的while循环</li>
</ul>
<p><strong><em>while 条件语句：<br>&emsp;循环体<br>else：<br>&emsp;代码段</em></strong></p>
<p>else中的代码段：当循环自然死亡（for后的变量数据取完了，while后的条件为False）else后面的代码会在循环结束后执行,如果循环是在遇到break后结束的，那么else后的代码段就不会执行</p>
<p>else的意义：<br>可以通过判断else中的代码有没有执行来判断循环有没有遇到break</p>
<h6 id="4）、while死循环的用法："><a href="#4）、while死循环的用法：" class="headerlink" title="4）、while死循环的用法："></a>4）、while死循环的用法：</h6><p><strong><em>while True:<br>&emsp;需要执行的代码<br>&emsp;if 退出循环的条件：<br>&emsp;&emsp;break</em></strong></p>
<h3 id="5、循环嵌套"><a href="#5、循环嵌套" class="headerlink" title="5、循环嵌套"></a>5、循环嵌套</h3><h4 id="练习：计算：1！-2！-3！-…-10！"><a href="#练习：计算：1！-2！-3！-…-10！" class="headerlink" title="练习：计算：1！+2！+3！+…+10！"></a>练习：计算：1！+2！+3！+…+10！</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方法1</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x1 <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">  pro = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> x2 <span class="keyword">in</span> range(<span class="number">1</span>,x1 + <span class="number">1</span>):</span><br><span class="line">    pro *= x2</span><br><span class="line">  sum += pro</span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法2</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line">pro = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>)</span><br><span class="line">  pro *= x</span><br><span class="line">  sum += pro</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：4:数据类型之列表</title>
    <url>/2018/05/01/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.4%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="一、什么是列表"><a href="#一、什么是列表" class="headerlink" title="一、什么是列表"></a>一、什么是列表</h1><h2 id="1、列表"><a href="#1、列表" class="headerlink" title="1、列表"></a>1、列表</h2><p>列表是python提供的容器型数据类型；以中括号[]作为容器标志；<br>里面多个元素用逗号隔开：[1,2,3,4,5,6],元素的个数就是列表的长度<br>列表是可变的、 有序的 ；</p>
<ul>
<li>可变性：（元素的个数，元素的值，元素的顺序）-元素支持增、删、改操作；</li>
<li>有序性：支持下标操作</li>
</ul>
<h2 id="2、列表元素："><a href="#2、列表元素：" class="headerlink" title="2、列表元素："></a>2、列表元素：</h2><p>列表中的元素可以是任何类型的数据(赋值语句除外)<br>同一个列表中的元素的类型可以不一样<br>例：[123,12.4,True,’sdf’,[1,4,5],(10,19),{‘name’:100},{1,2}]</p>
<hr>
<h1 id="二、列表的相关操作"><a href="#二、列表的相关操作" class="headerlink" title="二、列表的相关操作"></a>二、列表的相关操作</h1><h2 id="1、查-——-gt-获取列表中的元素"><a href="#1、查-——-gt-获取列表中的元素" class="headerlink" title="1、查  ——&gt; 获取列表中的元素"></a>1、查  ——&gt; 获取列表中的元素</h2><h3 id="1）、获取单个元素"><a href="#1）、获取单个元素" class="headerlink" title="1）、获取单个元素"></a>1）、获取单个元素</h3><p><strong>①：语法：</strong><br><strong><em>列表 [ 下标 ]</em></strong></p>
<p><strong>②：说明：</strong><br>列表———–&gt;可以是列表值、保存列表的变量、结果是列表的表达式<br>中括号[ ]——&gt;固定写法<br>下标————&gt;列表中的每个元素都会对应一个下标，来表示元素在列表中的位置</p>
<p><strong>下标范围：</strong><br>&emsp;0到列表长度减一   -   从前往后以此增加，0表示第一个元素<br>&emsp;-1到负列表长度    -   从后往前依次递减，-1表示最后一个元素</p>
<p><strong><em>IndexError：list index out of range   -   下标越界报错</em></strong></p>
<h3 id="2）、获取部分元素（切片）-切片的结果还是列表"><a href="#2）、获取部分元素（切片）-切片的结果还是列表" class="headerlink" title="2）、获取部分元素（切片）  -    切片的结果还是列表"></a>2）、获取部分元素（切片）  -    切片的结果还是列表</h3><p><strong>①：语法：</strong><br><strong><em>列表 [ 开始下标：结束下标：步长 ]</em></strong></p>
<p>列表<strong>[m:n:step]</strong>      -     获取range(m,n,step)产生的数字序列作为下标去列表里取元素</p>
<p><strong>②：其他用法：</strong></p>
<ul>
<li>省略步长(默认步长是1)：列表[开始下标：结束下标];<strong>[m:n]</strong></li>
<li>省略开始下标/步长：列表[：结束下标：步长];<strong>[:n:step]</strong>/列表[：结束下标]<strong>[:n]</strong><br>&emsp;如果步长为正，从前往后取；如果步长为负，从后往前取</li>
<li>省略结束下标/步长：列表[开始下标：：步长];<strong>[m::step]</strong>/列表[开始下标：]<strong>[m:]</strong><br>&emsp;从开始下标取到最后一个</li>
<li>省略开始和结束下标：列表[：：步长];<strong>[::step]</strong>/列表<strong>[：]</strong></li>
</ul>
<p><strong>③：遍历列表：</strong></p>
<ul>
<li>直接遍历：</li>
</ul>
<p><strong><em>for 变量 in 列表：<br>&emsp;&emsp;循环体</em></strong></p>
<ul>
<li>通过下标遍历</li>
</ul>
<p><strong><em>length = len（列表）<br>&emsp;for 变量 in range（length）：<br>&emsp;&emsp;元素 = 列表[变量]</em></strong></p>
<h3 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">1</span>, <span class="number">30</span>, <span class="number">69</span>, <span class="number">6</span>, <span class="number">58</span>, <span class="number">77</span>, <span class="number">106</span>]</span><br><span class="line">print(list[<span class="number">4</span>]) <span class="comment"># 58</span></span><br><span class="line">print(list[<span class="number">2</span>:<span class="number">5</span>]) <span class="comment"># [69, 6, 58]</span></span><br><span class="line">print(list[<span class="number">2</span>:<span class="number">5</span>:<span class="number">2</span>]) <span class="comment"># [69, 58]</span></span><br><span class="line">print(list[:<span class="number">4</span>])</span><br><span class="line">prine(list[<span class="number">3</span>:])</span><br><span class="line">print(list[:])</span><br></pre></td></tr></table></figure>


<h2 id="2、增-——-gt-添加元素"><a href="#2、增-——-gt-添加元素" class="headerlink" title="2、增 ——&gt; 添加元素"></a>2、增 ——&gt; 添加元素</h2><h3 id="1）、列表-append-元素-——-gt-在列表的最后添加元素"><a href="#1）、列表-append-元素-——-gt-在列表的最后添加元素" class="headerlink" title="1）、列表.append [ 元素 ] ——&gt; 在列表的最后添加元素"></a>1）、列表.append [ 元素 ] ——&gt; 在列表的最后添加元素</h3><h3 id="2）、列表-insert-下标-，元素-——-gt-在列表指定下标位置添加元素"><a href="#2）、列表-insert-下标-，元素-——-gt-在列表指定下标位置添加元素" class="headerlink" title="2）、列表.insert [ 下标 ，元素 ] ——&gt; 在列表指定下标位置添加元素"></a>2）、列表.insert [ 下标 ，元素 ] ——&gt; 在列表指定下标位置添加元素</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="string">'肖申克的救赎'</span>, <span class="string">'功夫'</span>, <span class="string">'霸王别姬'</span>, <span class="string">'卧虎藏龙'</span>, <span class="string">'天方异谭'</span>, <span class="string">'恐怖游轮'</span>]</span><br><span class="line">print(list.append[<span class="string">'我不是药神'</span>])</span><br><span class="line">print(list.insert[<span class="number">-3</span>, <span class="string">'大圣归来'</span>])</span><br></pre></td></tr></table></figure>


<h2 id="3、删-——-gt-删除列表元素"><a href="#3、删-——-gt-删除列表元素" class="headerlink" title="3、删 ——&gt; 删除列表元素"></a>3、删 ——&gt; 删除列表元素</h2><h3 id="1）、del列表-下标-——-gt-删除指定下标的元素"><a href="#1）、del列表-下标-——-gt-删除指定下标的元素" class="headerlink" title="1）、del列表[下标]——&gt;删除指定下标的元素"></a>1）、del列表[下标]——&gt;删除指定下标的元素</h3><h3 id="2）、列表-remove-元素-——-gt-删除列表中指定的元素"><a href="#2）、列表-remove-元素-——-gt-删除列表中指定的元素" class="headerlink" title="2）、列表.remove(元素)——&gt;删除列表中指定的元素"></a>2）、列表.remove(元素)——&gt;删除列表中指定的元素</h3><p>&emsp;<strong><em>注：若列表中没有指定的元素，报错<br>&emsp;&emsp;&emsp;若列表中有多个相同的指定元素，删除第一个</em></strong></p>
<h3 id="3）、列表-pop（）——-gt-取出列表中最后一个元素"><a href="#3）、列表-pop（）——-gt-取出列表中最后一个元素" class="headerlink" title="3）、列表.pop（）——&gt;取出列表中最后一个元素"></a>3）、列表.pop（）——&gt;取出列表中最后一个元素</h3><h4 id="emsp-emsp-emsp-列表-pop（下标）——-gt-取出列表中指定下标的元素"><a href="#emsp-emsp-emsp-列表-pop（下标）——-gt-取出列表中指定下标的元素" class="headerlink" title="&emsp;&emsp;&emsp;列表.pop（下标）——&gt;取出列表中指定下标的元素"></a>&emsp;&emsp;&emsp;列表.pop（下标）——&gt;取出列表中指定下标的元素</h4><p><strong><em>注：pop()中，元素是被取出，并没有被删除；只是对列表来说，元素减少了，如果将pop取出的值用变量保存并打印出来，能得到该元素</em></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = [<span class="number">2</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">43</span>]</span><br><span class="line">prunt(num.pop(<span class="number">2</span>)) <span class="comment"># 8</span></span><br><span class="line">print(num) <span class="comment"># [2, 50, 9, 43]</span></span><br></pre></td></tr></table></figure>

<p><strong>练习</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 练习下面这个列表中小于60的元素</span></span><br><span class="line"><span class="comment"># 答案：[89, 90, 78, 60, 87]</span></span><br><span class="line">方法一、</span><br><span class="line">scores = [<span class="number">89</span>, <span class="number">45</span>, <span class="number">56</span>, <span class="number">20</span>, <span class="number">90</span>, <span class="number">78</span>, <span class="number">60</span>, <span class="number">23</span>, <span class="number">87</span>, <span class="number">20</span>, <span class="number">50</span>]</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> scores[:]: <span class="comment"># 如果在原列表中删除，那么原列表的元素下标会不断变化，</span></span><br><span class="line"><span class="comment">#最后程序虽然不报错，但是结果不准确</span></span><br><span class="line">  <span class="keyword">if</span> num &lt; <span class="number">60</span>:</span><br><span class="line">    scores.remove(num)</span><br><span class="line">print(scores)</span><br><span class="line"></span><br><span class="line">方法二、</span><br><span class="line">scores = [<span class="number">89</span>, <span class="number">45</span>, <span class="number">56</span>, <span class="number">20</span>, <span class="number">90</span>, <span class="number">78</span>, <span class="number">60</span>, <span class="number">23</span>, <span class="number">87</span>, <span class="number">20</span>, <span class="number">50</span>]</span><br><span class="line">scores2 = scores[:]</span><br><span class="line">length = len(scores2)</span><br><span class="line">t = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(length):</span><br><span class="line">  <span class="keyword">if</span> scores2[x] &lt; <span class="number">60</span>:</span><br><span class="line">    scores.remove(scores[x])</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    t += <span class="number">1</span></span><br><span class="line">print(scores)</span><br></pre></td></tr></table></figure>


<h2 id="4、改——-gt-修改列表中的元素"><a href="#4、改——-gt-修改列表中的元素" class="headerlink" title="4、改——&gt;修改列表中的元素"></a>4、改——&gt;修改列表中的元素</h2><p>列表[下标] = 值——&gt;修改列表中指定的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">练习：将下列表中小于<span class="number">60</span>的分数换成不及格</span><br><span class="line">scores = [<span class="number">89</span>, <span class="number">45</span>, <span class="number">56</span>, <span class="number">20</span>, <span class="number">90</span>, <span class="number">78</span>, <span class="number">60</span>, <span class="number">23</span>, <span class="number">87</span>, <span class="number">20</span>, <span class="number">50</span>]</span><br><span class="line">length = len(scores)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(length):</span><br><span class="line">    <span class="keyword">if</span> scores[x] &lt; <span class="number">60</span>:</span><br><span class="line">        scores[x] = <span class="string">'不及格'</span></span><br><span class="line">print(scores)</span><br></pre></td></tr></table></figure>
<br>

<hr>
<h1 id="三、列表运算"><a href="#三、列表运算" class="headerlink" title="三、列表运算"></a>三、列表运算</h1><h2 id="1、数学运算"><a href="#1、数学运算" class="headerlink" title="1、数学运算"></a>1、数学运算</h2><p><strong>1）、加法</strong></p>
<ul>
<li>新列表中的元素是两个列表中元素的合并</li>
</ul>
<p><strong>2）、乘法</strong></p>
<ul>
<li>列表中的元素重复N次，产生一个新的列表<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">list2 = [<span class="string">'王二'</span>, <span class="string">'张三'</span>, <span class="string">'李四'</span>]</span><br><span class="line">print(list1 + list2)</span><br><span class="line">print(list1 * <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2、比较运算符"><a href="#2、比较运算符" class="headerlink" title="2、比较运算符"></a>2、比较运算符</h2><ul>
<li>等于和不等 == 、!=<br>元素的内容，个数，顺序都一样才相等</li>
<li>大于、小于 &gt; &gt;= &lt; &lt;=<br>两个列表的比较：先比较第一队元素的数值大小，第一队数值的大小就是列表的大小，如果第一队数值相等或者比较不了大小，比较第二队<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li1 = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">li2 = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">print(li1 == li2)</span><br><span class="line">print(li1 == li2) <span class="comment"># print(id(li1) == id(li2))</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3、is-in-not-in"><a href="#3、is-in-not-in" class="headerlink" title="3、is / in / not in"></a>3、is / in / not in</h2><ul>
<li>is 判断两个列表的地址是否相等</li>
<li>元素 in 列表——&gt;判断列表中是否存在指定元素</li>
<li>元素 not in 列表——&gt;判断列表中是否不存在指定元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">'小红'</span>, <span class="string">'小强'</span>, <span class="string">'小明'</span>]</span><br><span class="line">print(<span class="string">'小明'</span> <span class="keyword">in</span> names)</span><br><span class="line">print(<span class="string">'李四'</span> <span class="keyword">in</span> names)</span><br></pre></td></tr></table></figure>

<h2 id="4、列表相关函数"><a href="#4、列表相关函数" class="headerlink" title="4、列表相关函数"></a>4、列表相关函数</h2><p><strong><em>len / max / min / list / sum</em></strong></p>
<h3 id="1）、len-序列-——-gt-获取序列的长度（元素的个数）"><a href="#1）、len-序列-——-gt-获取序列的长度（元素的个数）" class="headerlink" title="1）、len(序列)——&gt;获取序列的长度（元素的个数）"></a>1）、len(序列)——&gt;获取序列的长度（元素的个数）</h3><h3 id="2）、max-序列-min-序列-——-gt-获取序列中最大值和最小值"><a href="#2）、max-序列-min-序列-——-gt-获取序列中最大值和最小值" class="headerlink" title="2）、max(序列)\min(序列)——&gt;获取序列中最大值和最小值"></a>2）、max(序列)\min(序列)——&gt;获取序列中最大值和最小值</h3><p><strong>对序列的要求：</strong><br>&emsp;&emsp;1.序列中所有元素的类型一致（数字看成一个类型）<br>&emsp;&emsp;2.元素本身支持比较大小</p>
<h3 id="3）、sum-数字序列-——-gt-求序列中所有元素的和"><a href="#3）、sum-数字序列-——-gt-求序列中所有元素的和" class="headerlink" title="3）、sum(数字序列)——&gt;求序列中所有元素的和"></a>3）、sum(数字序列)——&gt;求序列中所有元素的和</h3><p>（要求序列中的元素全是数字）</p>
<h3 id="4）、list-序列-——-gt-将其他类型的序列转换成列表；序列是容器型数据"><a href="#4）、list-序列-——-gt-将其他类型的序列转换成列表；序列是容器型数据" class="headerlink" title="4）、list(序列)——&gt;将其他类型的序列转换成列表；序列是容器型数据"></a>4）、list(序列)——&gt;将其他类型的序列转换成列表；序列是容器型数据</h3><br>

<hr>
<h1 id="四、列表的其他操作"><a href="#四、列表的其他操作" class="headerlink" title="四、列表的其他操作"></a>四、列表的其他操作</h1><h3 id="1、列表-count（元素）——-gt-统计列表中指定元素的个数"><a href="#1、列表-count（元素）——-gt-统计列表中指定元素的个数" class="headerlink" title="1、列表.count（元素）——&gt;统计列表中指定元素的个数"></a>1、列表.count（元素）——&gt;统计列表中指定元素的个数</h3><h3 id="2、列表-extend（序列）——-gt-将其他序列的元素全部添加到列表中"><a href="#2、列表-extend（序列）——-gt-将其他序列的元素全部添加到列表中" class="headerlink" title="2、列表.extend（序列）——&gt;将其他序列的元素全部添加到列表中"></a>2、列表.extend（序列）——&gt;将其他序列的元素全部添加到列表中</h3><h3 id="3、列表-index（元素）——-gt-获取指定元素在列表中的下标"><a href="#3、列表-index（元素）——-gt-获取指定元素在列表中的下标" class="headerlink" title="3、列表.index（元素）——&gt;获取指定元素在列表中的下标"></a>3、列表.index（元素）——&gt;获取指定元素在列表中的下标</h3><ul>
<li>a.若元素不存在，报错</li>
<li>b.若元素有多个</li>
</ul>
<h3 id="4、列表-revers（）——-gt-将原来的列表倒序（反过来）"><a href="#4、列表-revers（）——-gt-将原来的列表倒序（反过来）" class="headerlink" title="4、列表.revers（）——&gt;将原来的列表倒序（反过来）"></a>4、列表.revers（）——&gt;将原来的列表倒序（反过来）</h3><h3 id="5、列表-clear（）——-gt-清空列表"><a href="#5、列表-clear（）——-gt-清空列表" class="headerlink" title="5、列表.clear（）——&gt;清空列表"></a>5、列表.clear（）——&gt;清空列表</h3><ul>
<li>清空列表用clear函数，不直接赋值为[]。</li>
</ul>
<h3 id="6、列表-copy-——-gt-复制列表中的元素，产生一个新的列表-赋值后两个相互不影响"><a href="#6、列表-copy-——-gt-复制列表中的元素，产生一个新的列表-赋值后两个相互不影响" class="headerlink" title="6、列表.copy()——&gt;复制列表中的元素，产生一个新的列表,赋值后两个相互不影响"></a>6、列表.copy()——&gt;复制列表中的元素，产生一个新的列表,赋值后两个相互不影响</h3><h3 id="7、列表-sort-——-gt-将列表中的元素从小到大排序（直接修改列表中元素的顺序，不产生新列表）"><a href="#7、列表-sort-——-gt-将列表中的元素从小到大排序（直接修改列表中元素的顺序，不产生新列表）" class="headerlink" title="7、列表.sort()——&gt;将列表中的元素从小到大排序（直接修改列表中元素的顺序，不产生新列表）"></a>7、列表.sort()——&gt;将列表中的元素从小到大排序（直接修改列表中元素的顺序，不产生新列表）</h3><ul>
<li>列表.sort(revers=True)  —–    将列表中的元素从大到小排序</li>
<li>列表.sort(revers=True) 相当于 列表.sort() ；列表.revers()</li>
</ul>
<h3 id="8、sorted-序列-——-gt-不修改原序列，排序后产生一个新的列表（从小到大）"><a href="#8、sorted-序列-——-gt-不修改原序列，排序后产生一个新的列表（从小到大）" class="headerlink" title="8、sorted(序列)——&gt;不修改原序列，排序后产生一个新的列表（从小到大）"></a>8、sorted(序列)——&gt;不修改原序列，排序后产生一个新的列表（从小到大）</h3><ul>
<li>sorted(序列，reverse=True)    从大到小</li>
</ul>
]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：5:数据类型之元组</title>
    <url>/2018/05/07/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.5%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%85%83%E7%BB%84/</url>
    <content><![CDATA[<h1 id="一、什么是元组"><a href="#一、什么是元组" class="headerlink" title="一、什么是元组"></a>一、什么是元组</h1><ul>
<li>元组就是不可变的列表</li>
<li>元组是将小括号 () 作为容器的标志；(元素1，元素2，…)</li>
<li>元组不可变性，不能增、删、改，</li>
<li>元组有序性，支持下标操作</li>
<li>元组元素可以是任何类型的数据</li>
</ul>
<h1 id="二、元组的操作。-元组的操作和列表的相似度很大，有一些独特的操作已单独列出）"><a href="#二、元组的操作。-元组的操作和列表的相似度很大，有一些独特的操作已单独列出）" class="headerlink" title="二、元组的操作。(元组的操作和列表的相似度很大，有一些独特的操作已单独列出）"></a>二、元组的操作。(元组的操作和列表的相似度很大，有一些独特的操作已单独列出）</h1><h2 id="1、查-（元组的查和列表的基本相同；但元组不支持增、删、改）"><a href="#1、查-（元组的查和列表的基本相同；但元组不支持增、删、改）" class="headerlink" title="1、查 （元组的查和列表的基本相同；但元组不支持增、删、改）"></a>1、查 （元组的查和列表的基本相同；但元组不支持增、删、改）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">8</span>)</span><br><span class="line">print(tuple1[<span class="number">0</span>])</span><br><span class="line">print(tuple1[<span class="number">3</span>])</span><br><span class="line">print(tuple1[<span class="number">2</span>:<span class="number">4</span>:<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<h2 id="2、元组和列表相同的操作"><a href="#2、元组和列表相同的操作" class="headerlink" title="2、元组和列表相同的操作"></a>2、元组和列表相同的操作</h2><p><strong><em>+&emsp;、\</em>&emsp; == &emsp;!=&emsp; is&emsp; in &emsp; not in &emsp; len &emsp;max &emsp;min&emsp; sum &emsp;sorted*</strong></p>
<h1 id="三、元组的独特操作"><a href="#三、元组的独特操作" class="headerlink" title="三、元组的独特操作"></a>三、元组的独特操作</h1><h2 id="1、单个元素的元组-单个元素后面要加一个逗号-不然打印不出类型"><a href="#1、单个元素的元组-单个元素后面要加一个逗号-不然打印不出类型" class="headerlink" title="1、单个元素的元组(单个元素后面要加一个逗号,不然打印不出类型)"></a>1、单个元素的元组(单个元素后面要加一个逗号,不然打印不出类型)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">10</span>]</span><br><span class="line">print(list1, type(list1))   <span class="comment">#   [10] &lt;class 'list'&gt;</span></span><br><span class="line">tuple1 = (<span class="number">10</span>,)</span><br><span class="line">print(tuple1,type(tuple1))</span><br></pre></td></tr></table></figure>
<h2 id="2、单独使用的元组的值，-括号（）可以省略；直接多个数据用逗号隔开表示的还是一个元组"><a href="#2、单独使用的元组的值，-括号（）可以省略；直接多个数据用逗号隔开表示的还是一个元组" class="headerlink" title="2、单独使用的元组的值， 括号（）可以省略；直接多个数据用逗号隔开表示的还是一个元组"></a>2、单独使用的元组的值， 括号（）可以省略；直接多个数据用逗号隔开表示的还是一个元组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple2 = <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span></span><br></pre></td></tr></table></figure>
<h2 id="3、可以通过让变量的个数和元组中元素的个数保持一致来分别获取元组中的元素（列表也适用此方法）"><a href="#3、可以通过让变量的个数和元组中元素的个数保持一致来分别获取元组中的元素（列表也适用此方法）" class="headerlink" title="3、可以通过让变量的个数和元组中元素的个数保持一致来分别获取元组中的元素（列表也适用此方法）"></a>3、可以通过让变量的个数和元组中元素的个数保持一致来分别获取元组中的元素（列表也适用此方法）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple3 = (<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">x,y = tuple3</span><br><span class="line">print(x,y)   <span class="comment">#   10 20</span></span><br></pre></td></tr></table></figure>
<h2 id="4、同时申明多个变量获取元组元素，变量的个数可以比元组中元素的个数少，但是多个变量中的某一个变量前必须加星号-；带星号的变量可以获取不带星号的变量获取完剩下的部分。（列表也适用此方法）"><a href="#4、同时申明多个变量获取元组元素，变量的个数可以比元组中元素的个数少，但是多个变量中的某一个变量前必须加星号-；带星号的变量可以获取不带星号的变量获取完剩下的部分。（列表也适用此方法）" class="headerlink" title="4、同时申明多个变量获取元组元素，变量的个数可以比元组中元素的个数少，但是多个变量中的某一个变量前必须加星号*；带星号的变量可以获取不带星号的变量获取完剩下的部分。（列表也适用此方法）"></a>4、同时申明多个变量获取元组元素，变量的个数可以比元组中元素的个数少，但是多个变量中的某一个变量前必须加星号*；带星号的变量可以获取不带星号的变量获取完剩下的部分。（列表也适用此方法）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple4 = (<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line">x1 ,*x2 ,x3 = tuple4</span><br><span class="line">print(x1,x2,x3)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：6:数据类型之字典</title>
    <url>/2018/05/15/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.6%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<h1 id="一、字典"><a href="#一、字典" class="headerlink" title="一、字典"></a>一、字典</h1><h2 id="1、什么是字典"><a href="#1、什么是字典" class="headerlink" title="1、什么是字典"></a>1、什么是字典</h2><h3 id="1）、字典："><a href="#1）、字典：" class="headerlink" title="1）、字典："></a>1）、字典：</h3><ul>
<li>字典是容器型数据类型，将大括号{}作为容器的标志，里面多个元素用逗号隔开，字典中的元素只能是键值对：{键1:值1, 键2:值2, 键3:值3,…}</li>
<li>字典的可变性(支持增删改)，无序性(不支持下标操作)</li>
</ul>
<h3 id="2）、键值对"><a href="#2）、键值对" class="headerlink" title="2）、键值对"></a>2）、键值对</h3><ul>
<li>字典中所有元素都必须是键值对，键和值必须成对出现</li>
<li>字典存数据存的是值，键只是用来区分不同的值的</li>
<li>键 - 理论上是任何不可变的数据都可以，实际开发的时候一般将字符串作为键（key），在同一字典中键是唯一的</li>
<li>值 - 可以是任何类型的数据<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">'dfg'</span>:<span class="number">34</span>, <span class="string">'a'</span>:<span class="literal">True</span>, <span class="string">'o'</span>:[<span class="number">1</span>,<span class="number">2</span>], <span class="string">'c'</span>:&#123;<span class="string">'name'</span>:<span class="string">'小明'</span>&#125;&#125;   <span class="comment">#   值可以是任何数据</span></span><br><span class="line">dict2 = &#123;<span class="number">10</span>:<span class="number">34</span>, <span class="string">'a'</span>:<span class="literal">True</span>, [<span class="number">1</span>,<span class="number">2</span>]:&#123;<span class="string">'name'</span>:<span class="string">'小明'</span>&#125;&#125;   <span class="comment">#   键只能是不可变数据：数字，元组，字符串</span></span><br></pre></td></tr></table></figure>
<br>

</li>
</ul>
<hr>
<h1 id="二、字典的基本操作（增删改查）"><a href="#二、字典的基本操作（增删改查）" class="headerlink" title="二、字典的基本操作（增删改查）"></a>二、字典的基本操作（增删改查）</h1><h2 id="1、查-—-获取字典的值"><a href="#1、查-—-获取字典的值" class="headerlink" title="1、查 — 获取字典的值"></a>1、查 — 获取字典的值</h2><h3 id="1-、获取单个值"><a href="#1-、获取单个值" class="headerlink" title="1)、获取单个值"></a>1)、获取单个值</h3><p><strong>字典[key]</strong>——&gt;获取字典中指定key对应的值，若key值不存在，报错<br><strong>字典.get(key)</strong>——&gt;获取字典中指定key对应的值，若key值不存在，不报错，返回None<br><strong>字典.get(key，默认值)</strong>——&gt;获取字典中指定key对应的值，若key值不存在，不报错，返回指定的默认值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">person = &#123;<span class="string">'name'</span>:<span class="string">'小明'</span>, <span class="string">'age'</span>:<span class="string">'18'</span>, <span class="string">'tel'</span>:<span class="string">'13888888888'</span>&#125;</span><br><span class="line">print(person[<span class="string">'age'</span>])</span><br><span class="line">print(person.get(<span class="string">'age'</span>))</span><br></pre></td></tr></table></figure>
<h3 id="2-、遍历"><a href="#2-、遍历" class="headerlink" title="2)、遍历"></a>2)、遍历</h3><p><strong>for key in 字典:<br>&emsp;循环体</strong></p>
<p>其他遍历方法<strong>（效率较低）</strong><br>for key,value in person.items():<br>&emsp;print(key, value)</p>
<h2 id="2、增-改"><a href="#2、增-改" class="headerlink" title="2、增 / 改"></a>2、增 / 改</h2><p><strong>字典[key] = 值</strong></p>
<ul>
<li>若key在字典内存在，修改</li>
<li>若key不在字典内，增加  ‘key’:’值’<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">person = &#123;<span class="string">'name'</span>:<span class="string">'小明'</span>, <span class="string">'age'</span>:<span class="string">'18'</span>, <span class="string">'tel'</span>:<span class="string">'13888888888'</span>&#125;</span><br><span class="line">person[<span class="string">'name'</span>] = <span class="string">'小花'</span></span><br><span class="line">person[<span class="string">'分数'</span>] = <span class="number">89</span></span><br><span class="line">print(person)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="3、删-—-删除键对"><a href="#3、删-—-删除键对" class="headerlink" title="3、删 — 删除键对"></a>3、删 — 删除键对</h2><h3 id="1）、del-字典-key-删除字典中指定key对应的键值对"><a href="#1）、del-字典-key-删除字典中指定key对应的键值对" class="headerlink" title="1）、del 字典[key]     -     删除字典中指定key对应的键值对"></a>1）、del 字典[key]     -     删除字典中指定key对应的键值对</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> person[<span class="string">'age'</span>]</span><br><span class="line">print(person)</span><br></pre></td></tr></table></figure>
<h3 id="2）、字典-pop-key-取出字典中指定key对应的值（key对应的键值对会从字典消失）"><a href="#2）、字典-pop-key-取出字典中指定key对应的值（key对应的键值对会从字典消失）" class="headerlink" title="2）、字典.pop(key)     -     取出字典中指定key对应的值（key对应的键值对会从字典消失）"></a>2）、字典.pop(key)     -     取出字典中指定key对应的值（key对应的键值对会从字典消失）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">person.pop(<span class="string">'name'</span>)</span><br><span class="line">print(person)</span><br></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 练习，保存一个班的学生信息：姓名，学号，年龄，成绩，电话）一个班五个人</span></span><br><span class="line">all_student = [</span><br><span class="line">    &#123;<span class="string">'name'</span>:<span class="string">'tom'</span>, <span class="string">'age'</span>:<span class="number">20</span>, <span class="string">'score'</span>:<span class="number">80</span>, <span class="string">'tel'</span>:<span class="string">'13888888888'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>:<span class="string">'tony'</span>, <span class="string">'age'</span>:<span class="number">13</span>, <span class="string">'score'</span>:<span class="number">90</span>, <span class="string">'tel'</span>:<span class="string">'13888888883'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>:<span class="string">'john'</span>, <span class="string">'age'</span>:<span class="number">45</span>, <span class="string">'score'</span>:<span class="number">49</span>, <span class="string">'tel'</span>:<span class="string">'13888888884'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>:<span class="string">'tom2'</span>, <span class="string">'age'</span>:<span class="number">35</span>, <span class="string">'score'</span>:<span class="number">73</span>, <span class="string">'tel'</span>:<span class="string">'13888888885'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>:<span class="string">'tom3'</span>, <span class="string">'age'</span>:<span class="number">10</span>, <span class="string">'score'</span>:<span class="number">99</span>, <span class="string">'tel'</span>:<span class="string">'13888888886'</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 1）统计以上学生中不及格学生的人数</span></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> all_student:</span><br><span class="line">  <span class="keyword">if</span> student[score] &lt; <span class="number">60</span>:</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">print(n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2）将打印所有未成年人学生的姓名</span></span><br><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> all_student:</span><br><span class="line">  <span class="keyword">if</span> student[age] &lt; <span class="number">18</span>:</span><br><span class="line">    print(student[name])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3）将年龄为25岁以上的学生的电话号码设置为’保密’</span></span><br><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> all_student:</span><br><span class="line">   <span class="keyword">if</span> student[age] &gt; <span class="number">25</span>:</span><br><span class="line">     student[tel] = <span class="string">'保密'</span></span><br><span class="line">print(all_student)</span><br></pre></td></tr></table></figure>
<br>

<hr>
<h1 id="三、字典的其他操作"><a href="#三、字典的其他操作" class="headerlink" title="三、字典的其他操作"></a>三、字典的其他操作</h1><h2 id="1、运算符：-（不支持：-lt-gt-lt-gt-运算）"><a href="#1、运算符：-（不支持：-lt-gt-lt-gt-运算）" class="headerlink" title="1、运算符：== !=（不支持：+ * &lt; &gt; &lt;= &gt;=运算）"></a>1、运算符：== !=（不支持：+ * &lt; &gt; &lt;= &gt;=运算）</h2><h2 id="2、in-not-in"><a href="#2、in-not-in" class="headerlink" title="2、in / not in"></a>2、in / not in</h2><p><strong>key in 字典 / key not in 字典   -   判断key是否存在于字典中</strong></p>
<h2 id="3、len-dict"><a href="#3、len-dict" class="headerlink" title="3、len , dict"></a>3、len , dict</h2><p><strong>len(字典)</strong>——&gt;字典的长度，键值对的个数<br><strong>dict(数据)</strong>——&gt;将指定的数据转换成字典；</p>
<p>数据的要求：</p>
<ul>
<li>1).数据本身是序列；</li>
<li>2).序列中的元素也是序列;</li>
<li>3).小序列中的元素智能有两个，第一个元素不可变</li>
</ul>
<p><strong>字典转换成列表  —  将字典所有的key取出来作为列表的元素</strong></p>
<h2 id="4、字典-clear-清空字典"><a href="#4、字典-clear-清空字典" class="headerlink" title="4、字典.clear()   -   清空字典"></a>4、字典.clear()   -   清空字典</h2><h2 id="5、字典-copy-拷贝字典，返回新字典-相互不影响"><a href="#5、字典-copy-拷贝字典，返回新字典-相互不影响" class="headerlink" title="5、字典.copy()   -   拷贝字典，返回新字典(相互不影响)"></a>5、字典.copy()   -   拷贝字典，返回新字典(相互不影响)</h2><h2 id="6、dict-fromkeys-序列，值-创建新的字典，将序列中的元素作为key，指定的值作为每个key的值，创建新字典"><a href="#6、dict-fromkeys-序列，值-创建新的字典，将序列中的元素作为key，指定的值作为每个key的值，创建新字典" class="headerlink" title="6、dict.fromkeys(序列，值)   -   创建新的字典，将序列中的元素作为key，指定的值作为每个key的值，创建新字典"></a>6、dict.fromkeys(序列，值)   -   创建新的字典，将序列中的元素作为key，指定的值作为每个key的值，创建新字典</h2><h2 id="7、字典-items-字典-values-字典-keys"><a href="#7、字典-items-字典-values-字典-keys" class="headerlink" title="7、字典.items(),字典.values(),字典.keys()"></a>7、字典.items(),字典.values(),字典.keys()</h2><h3 id="1）、字典-key-gt-获取字典所有的key并且返回，返回的数据类型是序列但是不是列表"><a href="#1）、字典-key-gt-获取字典所有的key并且返回，返回的数据类型是序列但是不是列表" class="headerlink" title="1）、字典.key() -&gt; 获取字典所有的key并且返回，返回的数据类型是序列但是不是列表"></a>1）、字典.key() -&gt; 获取字典所有的key并且返回，返回的数据类型是序列但是不是列表</h3><h3 id="2）、字典-values-gt-获取字典所有的value并且返回，返回的数据类型是序列但是不是列表"><a href="#2）、字典-values-gt-获取字典所有的value并且返回，返回的数据类型是序列但是不是列表" class="headerlink" title="2）、字典.values() -&gt; 获取字典所有的value并且返回，返回的数据类型是序列但是不是列表"></a>2）、字典.values() -&gt; 获取字典所有的value并且返回，返回的数据类型是序列但是不是列表</h3><h3 id="3）、字典-items-gt-同时获取字典所有的key和value，返回一个序列，序列中元素是有两个元素的元祖，这两个元素分别是key和值"><a href="#3）、字典-items-gt-同时获取字典所有的key和value，返回一个序列，序列中元素是有两个元素的元祖，这两个元素分别是key和值" class="headerlink" title="3）、字典.items() -&gt; 同时获取字典所有的key和value，返回一个序列，序列中元素是有两个元素的元祖，这两个元素分别是key和值"></a>3）、字典.items() -&gt; 同时获取字典所有的key和value，返回一个序列，序列中元素是有两个元素的元祖，这两个元素分别是key和值</h3><h2 id="8、字典-setdefault-key-value-字典中添加键值对（key值存在时不会修改）"><a href="#8、字典-setdefault-key-value-字典中添加键值对（key值存在时不会修改）" class="headerlink" title="8、字典.setdefault(key, value) - 字典中添加键值对（key值存在时不会修改）"></a>8、字典.setdefault(key, value) - 字典中添加键值对（key值存在时不会修改）</h2><h2 id="9、字典1-update-字典2-将字典2中的键值对添加到字典1中（不存在的就添加，存在的就覆盖）"><a href="#9、字典1-update-字典2-将字典2中的键值对添加到字典1中（不存在的就添加，存在的就覆盖）" class="headerlink" title="9、字典1.update(字典2)   -   将字典2中的键值对添加到字典1中（不存在的就添加，存在的就覆盖）"></a>9、字典1.update(字典2)   -   将字典2中的键值对添加到字典1中（不存在的就添加，存在的就覆盖）</h2><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 练习2：设计数据保存一个班的信息：</span></span><br><span class="line"><span class="comment"># 名字：python1906；</span></span><br><span class="line"><span class="comment"># 所有老师（名字，性别，联系方式，职位）：</span></span><br><span class="line"><span class="comment"># 所有学生（姓名，毕业学校，电话，性别，年龄，紧急联系人（姓名，电话，关系））</span></span><br><span class="line">class_1906 = &#123;</span><br><span class="line">  <span class="string">'class_name'</span> : <span class="string">'python_1906'</span>, </span><br><span class="line">  <span class="string">'all_teacher'</span> : [</span><br><span class="line">    &#123;<span class="string">'name'</span> : <span class="string">'张老师'</span>, <span class="string">'gender'</span> : <span class="string">'女'</span>, <span class="string">'职位'</span> : <span class="string">'班主任'</span>, <span class="string">'联系方式'</span> : <span class="string">'123451'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span> : <span class="string">'余老师'</span>, <span class="string">'gender'</span> : <span class="string">'女'</span>, <span class="string">'职位'</span> : <span class="string">'讲师'</span>, <span class="string">'联系方式'</span> : <span class="string">'123452'</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">  <span class="string">'all_student'</span> : [</span><br><span class="line">    &#123;<span class="string">'name'</span> : <span class="string">'张三'</span>, <span class="string">'gender'</span> : <span class="string">'男'</span>, <span class="string">'年龄'</span> : <span class="string">'25'</span>, <span class="string">'联系方式'</span> : <span class="string">'123453'</span>, <span class="string">'紧急联系人'</span> : &#123;<span class="string">'name'</span> : <span class="string">'李四'</span>, <span class="string">'关系'</span> : <span class="string">'父子'</span>, <span class="string">'联系方式'</span> : <span class="string">'12345678'</span>&#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">print(class_1906[all_student][<span class="number">-1</span>][<span class="string">'紧急联系人'</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：7:数据类型之集合</title>
    <url>/2018/05/23/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.7%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="一、什么是集合"><a href="#一、什么是集合" class="headerlink" title="一、什么是集合"></a>一、什么是集合</h1><ul>
<li>集合是容器型数据类型，将大括号{}作为容器标志，元素之间用逗号隔开<br>  <strong>{元素1，元素2，元素3…}</strong></li>
<li>集合有可变性（支持增删改），无序性（不支持下标操作）</li>
<li>集合中的元素：元素不可变性，元素唯一性（自带去重）</li>
</ul>
<h2 id="1、空集合"><a href="#1、空集合" class="headerlink" title="1、空集合"></a>1、空集合</h2><p>x = {} —（如果这样写，系统会默认为空字典而不是空集合）<br>空集合的正确写法：set1 = <strong>set()</strong></p>
<h2 id="2、集合中的元素"><a href="#2、集合中的元素" class="headerlink" title="2、集合中的元素"></a>2、集合中的元素</h2><p>集合里的元素具有不可变性和唯一性</p>
<h2 id="3、集合的基本操作"><a href="#3、集合的基本操作" class="headerlink" title="3、集合的基本操作"></a>3、集合的基本操作</h2><h3 id="1、查-—-只能遍历，不能单取或切片"><a href="#1、查-—-只能遍历，不能单取或切片" class="headerlink" title="(1、查   —   只能遍历，不能单取或切片"></a>(1、查   —   只能遍历，不能单取或切片</h3><h3 id="2、增"><a href="#2、增" class="headerlink" title="(2、增"></a>(2、增</h3><p>a.添加单个元素：<strong>集合.add(元素)</strong>   -   在集合中添加指定元素<br>b.<strong>集合.update(序列)</strong>   -   将序列中所有的元素都添加到集合中去</p>
<h3 id="3、删"><a href="#3、删" class="headerlink" title="(3、删"></a>(3、删</h3><p>a.<strong>集合.remove(元素)</strong>—元素不存在报错<br>b.<strong>集合.discard(序列)</strong>—元素不存在不报错</p>
<h2 id="4、其他"><a href="#4、其他" class="headerlink" title="4、其他"></a>4、其他</h2><h3 id="1、in-not-in"><a href="#1、in-not-in" class="headerlink" title="(1、in / not in"></a>(1、in / not in</h3><h3 id="2、len、set"><a href="#2、len、set" class="headerlink" title="(2、len、set"></a>(2、len、set</h3><p>set(序列)   -   所有的序列都可以转换成集合（元素不可变），自动去重</p>
<br>

<hr>
<h1 id="二、集合运算"><a href="#二、集合运算" class="headerlink" title="二、集合运算"></a>二、集合运算</h1><p><strong>并集（+），交集（&amp;），差集（-），对称差集（^），&gt; / &lt;（包含关系）</strong></p>
<h2 id="1、并集：集合1-集合2-gt-将两个集合合并在一起产生一个新的集合"><a href="#1、并集：集合1-集合2-gt-将两个集合合并在一起产生一个新的集合" class="headerlink" title="1、并集：集合1 | 集合2   -&gt;   将两个集合合并在一起产生一个新的集合"></a>1、并集：集合1 | 集合2   -&gt;   将两个集合合并在一起产生一个新的集合</h2><p>print(set1 | set2)</p>
<h2 id="2、交集：集合1-amp-集合2-gt-获取两个集合的公共部分产生一个辛几何"><a href="#2、交集：集合1-amp-集合2-gt-获取两个集合的公共部分产生一个辛几何" class="headerlink" title="2、交集：集合1 &amp; 集合2   -&gt;   获取两个集合的公共部分产生一个辛几何"></a>2、交集：集合1 &amp; 集合2   -&gt;   获取两个集合的公共部分产生一个辛几何</h2><p>print(set1 &amp; set2)</p>
<h2 id="3、差集：集合1-集合2-gt-获取集合1中去掉集合2剩下的部分"><a href="#3、差集：集合1-集合2-gt-获取集合1中去掉集合2剩下的部分" class="headerlink" title="3、差集：集合1 - 集合2   -&gt;   获取集合1中去掉集合2剩下的部分"></a>3、差集：集合1 - 集合2   -&gt;   获取集合1中去掉集合2剩下的部分</h2><p>print(set1 - set2)<br>print(set2 - set1)</p>
<h2 id="4、对称差集：集合1-集合2-gt-获取集合1和集合2合并后去掉公共部分剩下的部分"><a href="#4、对称差集：集合1-集合2-gt-获取集合1和集合2合并后去掉公共部分剩下的部分" class="headerlink" title="4、对称差集：集合1 ^ 集合2 -&gt;  获取集合1和集合2合并后去掉公共部分剩下的部分"></a>4、对称差集：集合1 ^ 集合2 -&gt;  获取集合1和集合2合并后去掉公共部分剩下的部分</h2><p>print(set1 ^ set2)</p>
<h2 id="5、集合1-gt-集合2-gt-判断集合1是否包含集合2"><a href="#5、集合1-gt-集合2-gt-判断集合1是否包含集合2" class="headerlink" title="5、集合1 &gt; 集合2        -&gt;    判断集合1是否包含集合2"></a>5、集合1 &gt; 集合2        -&gt;    判断集合1是否包含集合2</h2><p>&emsp; 集合2 &gt; 集合1        -&gt;    判断集合2是否包含集合1</p>
]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：8:数据类型之字符串</title>
    <url>/2018/06/06/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.8%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="一、字符串"><a href="#一、字符串" class="headerlink" title="一、字符串"></a>一、字符串</h1><ul>
<li>字符串(str)是容器型数据类型，他是将单引号(‘’)、双引号(“”)、三个单引号或三个双引号(‘’’ ‘’’/“”” “””)作为容器标志</li>
<li>字符串有不可变性（不支持增删改）、有序性（支持下标操作）</li>
</ul>
<h2 id="1、字符串的元素-—字符"><a href="#1、字符串的元素-—字符" class="headerlink" title="1、字符串的元素 —字符"></a>1、字符串的元素 —字符</h2><p>python中只有字符概念，<strong>没有字符类型</strong>。引号中只有一个元素的字符串可以看成一个字符；字符串又叫字符集。</p>
<h3 id="1）、字符"><a href="#1）、字符" class="headerlink" title="1）、字符"></a>1）、字符</h3><p>原则上任何可以通过键盘输入或者从其他地方复制粘贴的所有符号都可以作为字符</p>
<h3 id="2）、普通字符"><a href="#2）、普通字符" class="headerlink" title="2）、普通字符"></a>2）、普通字符</h3><p>在字符串中能够代表符号本身的字符（没有特殊意义和特殊功能的符号）</p>
<h3 id="3）、转义字符"><a href="#3）、转义字符" class="headerlink" title="3）、转义字符"></a>3）、转义字符</h3><p>在字符串中有特殊意义和特殊功能的字符的组合，一般是以斜杠\开头的<br><strong>常见的转义字符：</strong><br><strong>\n</strong> ——&gt; 表示换行<br><strong>\t</strong> ——&gt; 表示一个缩进（Tab）<br><strong>\\</strong> ——&gt; 表示斜杠本身<br><strong>&#39;</strong> ——&gt; 表示单引号<br><strong>&quot;</strong> ——&gt; 表示双引号<br><strong>\u四位16进制数</strong> ——&gt; 编码字符（获取四位16进制数作为编码值对应的值）</p>
<p><strong>所有的转义字符长度都是1</strong></p>
<h3 id="4）、阻止转义"><a href="#4）、阻止转义" class="headerlink" title="4）、阻止转义"></a>4）、阻止转义</h3><p>在字符串最前面加r或R可以让当前字符串中所有的转义字符失效（所有的符号在字符串中都表示这个符号本身）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str6 = <span class="string">'\tsd\n\'ds123'</span></span><br><span class="line">str7 = <span class="string">r'\tsd\n\'ds123'</span></span><br></pre></td></tr></table></figure>



<h2 id="2、字符编码"><a href="#2、字符编码" class="headerlink" title="2、字符编码"></a>2、字符编码</h2><h3 id="1）、计算机不能直接存储符号，只能存储数字，为了能够存储字符，把每个字符关联了一个固定的数字（这个固定的数字就是对应字符的编码）"><a href="#1）、计算机不能直接存储符号，只能存储数字，为了能够存储字符，把每个字符关联了一个固定的数字（这个固定的数字就是对应字符的编码）" class="headerlink" title="1）、计算机不能直接存储符号，只能存储数字，为了能够存储字符，把每个字符关联了一个固定的数字（这个固定的数字就是对应字符的编码）"></a>1）、计算机不能直接存储符号，只能存储数字，为了能够存储字符，把每个字符关联了一个固定的数字（这个固定的数字就是对应字符的编码）</h3><h3 id="2）、ASCII表在计算机中采用一个字节保存一个字符（128个字符），字符包含了所有的字母、数字和英文常用符号"><a href="#2）、ASCII表在计算机中采用一个字节保存一个字符（128个字符），字符包含了所有的字母、数字和英文常用符号" class="headerlink" title="2）、ASCII表在计算机中采用一个字节保存一个字符（128个字符），字符包含了所有的字母、数字和英文常用符号"></a>2）、ASCII表在计算机中采用一个字节保存一个字符（128个字符），字符包含了所有的字母、数字和英文常用符号</h3><p>&emsp; 0-9：编码值依次增加 ； 0对应48<br>&emsp;   A-Z：编码值以此增加 ； A对应65<br>&emsp;   a-z：编码值依次增加 ； a对应97</p>
<h3 id="3）、Unicode编码表是ASCII表的扩展，包含了世界上所有国家所有语言对应的符号（总共有65536个符号）"><a href="#3）、Unicode编码表是ASCII表的扩展，包含了世界上所有国家所有语言对应的符号（总共有65536个符号）" class="headerlink" title="3）、Unicode编码表是ASCII表的扩展，包含了世界上所有国家所有语言对应的符号（总共有65536个符号）"></a>3）、Unicode编码表是ASCII表的扩展，包含了世界上所有国家所有语言对应的符号（总共有65536个符号）</h3><p>&emsp;  ASCII表范围：0 - 127<br>&emsp;  <strong>中文的编码范围：4e00 - 9fa5</strong></p>
<h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p><strong>①：编码字符：\u4位16进制数<br>②：chr(编码值(可以是任何进制)) - 获取编码值对应的字符<br>③：ord(字符) - 获取指定字符对应的编码值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取所有的中文字符</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0x4e00</span>, <span class="number">0x9fa5</span>):</span><br><span class="line">  print(chr(x))</span><br><span class="line">  <span class="keyword">if</span> num % <span class="number">35</span> == <span class="number">0</span>:</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure>
<br>

<hr>
<h1 id="二、字符串的查（字符串有不可变性（不支持增删改））"><a href="#二、字符串的查（字符串有不可变性（不支持增删改））" class="headerlink" title="二、字符串的查（字符串有不可变性（不支持增删改））"></a>二、字符串的查（字符串有不可变性（不支持增删改））</h1><h2 id="1、获取单个字符：字符串-下标"><a href="#1、获取单个字符：字符串-下标" class="headerlink" title="1、获取单个字符：字符串[下标]"></a>1、获取单个字符：字符串[下标]</h2><p><strong>一个空格是一个字符；tab键是4个字符；\t是一个字符</strong></p>
<h2 id="2、获取多个字符：切片—字符串-开始下标：结束下标：步长"><a href="#2、获取多个字符：切片—字符串-开始下标：结束下标：步长" class="headerlink" title="2、获取多个字符：切片—字符串[开始下标：结束下标：步长]"></a>2、获取多个字符：切片—字符串[开始下标：结束下标：步长]</h2><h2 id="3、遍历：遍历元素，遍历下标"><a href="#3、遍历：遍历元素，遍历下标" class="headerlink" title="3、遍历：遍历元素，遍历下标"></a>3、遍历：遍历元素，遍历下标</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">'hello python'</span></span><br><span class="line">print(str1[<span class="number">-4</span>])</span><br><span class="line">print(str1[<span class="number">5</span>])</span><br><span class="line">print(str1[<span class="number">2</span>:])</span><br><span class="line">print(str1[:<span class="number">-2</span>:])</span><br></pre></td></tr></table></figure>
<br>

<hr>
<h1 id="三、字符串的运算和函数"><a href="#三、字符串的运算和函数" class="headerlink" title="三、字符串的运算和函数"></a>三、字符串的运算和函数</h1><h2 id="1、运算符"><a href="#1、运算符" class="headerlink" title="1、运算符"></a>1、运算符</h2><h3 id="1）、加-乘"><a href="#1）、加-乘" class="headerlink" title="1）、加 +,  乘 *"></a>1）、加 +,  乘 *</h3><h3 id="2）、等-不等"><a href="#2）、等-不等" class="headerlink" title="2）、等 ==,  不等 !="></a>2）、等 ==,  不等 !=</h3><h3 id="3）、-gt-lt-gt-lt"><a href="#3）、-gt-lt-gt-lt" class="headerlink" title="3）、&gt;, &lt;, &gt;=, &lt;="></a>3）、&gt;, &lt;, &gt;=, &lt;=</h3><p>字符串比较大小是比较编码值的大小，一个字符一个字符的比较<br>判断字符是否是小写字母：’a’&lt;= char &lt;=’z’<br>判断字符是否是大写字母：’A’&lt;= char &lt;=’Z’<br>判断字符是否是字母：’A’&lt;= char &lt;=’Z’ or ‘a’&lt;= char &lt;=’z’<br>判断字符是否是中文：’\u4e00’ &lt;= char &lt;= ‘\u9fa5’<br>判断字符是否是数字：’0’ &lt;= char &lt;= ‘9’</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 练习：输入一个字符串，判断这个字符串是否是中文字符串（全是中文）</span></span><br><span class="line">value = input(<span class="string">'请输入：'</span>)</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> value:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">'\u4e00 &lt;= char &lt;=\u9fa5'</span>:</span><br><span class="line">        print(<span class="string">'不是中文字符串'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'是中文字符串'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2、in-和-not-in"><a href="#2、in-和-not-in" class="headerlink" title="2、in 和 not in"></a>2、in 和 not in</h2><p>字符串1 in 字符串2  -&gt;  判断字符串2中是否包含字符串1<br>print(‘a’ in ‘abcdf’)<br>print(‘abc’ in ‘abcdf’)   <strong>子串必须是连续的</strong></p>
<h2 id="3、相关函数"><a href="#3、相关函数" class="headerlink" title="3、相关函数"></a>3、相关函数</h2><p>①、len(字符串)<br>print(len(‘\tsdse\ndsdwds\u4e00’))<br>②、str(数据)<br>print(list(str([10,20,30])))<br>③、sorted(字符串) 从小到大排序<br>str1 = ‘python’<br>print(sorted(str1))<br>④、reversed(字符串)倒序</p>
<br>

<hr>
<h1 id="四、格式字符串"><a href="#四、格式字符串" class="headerlink" title="四、格式字符串"></a>四、格式字符串</h1><h2 id="1、格式占位符"><a href="#1、格式占位符" class="headerlink" title="1、格式占位符"></a>1、格式占位符</h2><h3 id="1）、语法：包含格式占位符的字符串-（值1，值2，值3，…）"><a href="#1）、语法：包含格式占位符的字符串-（值1，值2，值3，…）" class="headerlink" title="1）、语法：包含格式占位符的字符串 % （值1，值2，值3，…）"></a>1）、语法：包含格式占位符的字符串 % （值1，值2，值3，…）</h3><h3 id="2）、说明："><a href="#2）、说明：" class="headerlink" title="2）、说明："></a>2）、说明：</h3><p>%   -   固定写法<br>()    -   若值只有一个，可省略<br>值   -   任何有结果的表达式，值得个数和类型要与前面的占位符的个数和类型相同</p>
<p><strong>格式占位符 - 格式占位符使用的时候和字符串中变化的数据类型相关</strong></p>
<ul>
<li>&emsp;%s - 字符串（任何类型都可以）</li>
<li>&emsp;%d - 整型；</li>
<li>&emsp;%-Nd - 整型；N约束数字的长度，如果不够，空格来凑（后面）。如果超了，不能约束</li>
<li>&emsp;%-Nd - 整型；N约束数字的长度，如果不够，空格来凑（前面）。如果超了，不能约束</li>
<li>&emsp;%f - 浮点数；小数点后保留6位</li>
<li>&emsp;%.Nf - 浮点数；N约束小数点的位数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = input(<span class="string">'请输入姓名：'</span>)</span><br><span class="line">age = int(input(<span class="string">'请输入年纪：'</span>))</span><br><span class="line">print(<span class="string">'你好，我是'</span>+ name +<span class="string">'今年'</span>,str(age)+<span class="string">'岁'</span>)</span><br><span class="line">print(<span class="string">'你好，我是%s，今年%d，工资%s'</span> % (name, age, <span class="number">200</span>))</span><br></pre></td></tr></table></figure>

<h2 id="2、format"><a href="#2、format" class="headerlink" title="2、format"></a>2、format</h2><h3 id="1）、语法：一个带有-的字符串-format-值1，值2，…"><a href="#1）、语法：一个带有-的字符串-format-值1，值2，…" class="headerlink" title="1）、语法：一个带有{}的字符串.format(值1，值2，…)"></a>1）、语法：一个带有{}的字符串.format(值1，值2，…)</h3><h3 id="2）、用法："><a href="#2）、用法：" class="headerlink" title="2）、用法："></a>2）、用法：</h3><p><strong>①、大括号的个数和后面的数值个数一样</strong><br>print(‘我是{}，今年{}岁’.format(‘安’, 20))</p>
<p><strong>②、{N} - N从0开始以此增加、分别表示format中第0个值，第一个值。。。</strong><br>print(‘我是{0}，年纪是{1}，今年{1}岁’.format(‘安’, 20))<br>print(‘数据1：{1}，数据2：{0}，数据3：{1}，’.format(10, 20))</p>
<p><strong>③、[key]</strong><br>‘{key1},{key1}’.format(key1=值1，key2=值2)<br>print(‘我是{name}，年纪是{age}，今年{age}岁’.format(name=’安’, age=20))</p>
<p><strong>④、用列表给占位符赋值</strong><br>list1 = [10, 20, 30, 40]<br>print(‘{0[3]}, {0[2]}, {0[1]}’.format(list1))</p>
<p><strong>⑤、用字典给占位符赋值</strong><br>student = {‘name’: ‘小明’, ‘age’:20, ‘id’: ‘001’, ‘score’:100}<br>print(‘{name}今年{age}岁，学号:{id},考了{score}’.format(student))</p>
<p><strong>⑥、其他写法</strong><br>print(‘圆周率:{:.2f}’.format(3.141592654))</p>
<p><strong>- 约束宽度</strong><br>print(‘整数:{:0&gt;4d}’.format(25))<br>print(‘整数:{:+&gt;4d}’.format(26))<br>print(‘整数:{:-&lt;4d}’.format(27))</p>
<p><strong>- 数字分隔</strong><br>print(‘大整数:{:,}’.format(10000000000))</p>
<p><strong>- 百分比</strong><br>print(‘百分比:{:.1%}’.format(0.2))</p>
<br>

<hr>
<h1 id="五、字符串的相关操作"><a href="#五、字符串的相关操作" class="headerlink" title="五、字符串的相关操作"></a>五、字符串的相关操作</h1><h2 id="1、字符串-capitalize-将字符串的首字母变成大写字母"><a href="#1、字符串-capitalize-将字符串的首字母变成大写字母" class="headerlink" title="1、字符串.capitalize() - 将字符串的首字母变成大写字母"></a>1、字符串.capitalize() - 将字符串的首字母变成大写字母</h2><h2 id="2、center-ljust-rjust-zfill"><a href="#2、center-ljust-rjust-zfill" class="headerlink" title="2、center / ljust / rjust / zfill"></a>2、center / ljust / rjust / zfill</h2><p><strong>字符串.center(宽度，填充字符)</strong><br>print(‘abc’.center(5,’*‘))</p>
<p><strong>字符串.ljust(宽度，填充字符)</strong><br>print(‘abc’.ljust(5,’*‘))</p>
<p><strong>字符串.rjust(宽度，填充字符)</strong><br>print(‘abc’.rjust(5,’*‘))</p>
<p><strong>字符串.zfill(宽度) == 字符串.zfill(宽度,’0’)</strong><br>print(‘abc’.zfill(5))</p>
<h2 id="3、统计"><a href="#3、统计" class="headerlink" title="3、统计"></a>3、统计</h2><h3 id="1）、字符串1-count-字符串2"><a href="#1）、字符串1-count-字符串2" class="headerlink" title="1）、字符串1.count(字符串2)"></a>1）、字符串1.count(字符串2)</h3><h3 id="2）、字符串1-count-字符串2-开始下标-结束下标-统计开始到结束范围内字符串2出现的次数"><a href="#2）、字符串1-count-字符串2-开始下标-结束下标-统计开始到结束范围内字符串2出现的次数" class="headerlink" title="2）、字符串1.count(字符串2,开始下标,结束下标) - 统计开始到结束范围内字符串2出现的次数"></a>2）、字符串1.count(字符串2,开始下标,结束下标) - 统计开始到结束范围内字符串2出现的次数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str2 = <span class="string">'how are you? i am fine! thank you!'</span></span><br><span class="line">print(str2.count(<span class="string">'you'</span>))</span><br><span class="line">print(str2.count(<span class="string">'a'</span>))</span><br><span class="line">print(str2.count(<span class="string">'you'</span>, <span class="number">0</span>, <span class="number">15</span>))</span><br></pre></td></tr></table></figure>

<h2 id="4、判断str2是否以str1结尾"><a href="#4、判断str2是否以str1结尾" class="headerlink" title="4、判断str2是否以str1结尾"></a>4、判断str2是否以str1结尾</h2><p>print(str2[-len(str1):] == str1)</p>
<h2 id="5、字符串查找"><a href="#5、字符串查找" class="headerlink" title="5、字符串查找"></a>5、字符串查找</h2><p><strong>获取一个字符串在另一个字符串中第一次出现的位置</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str2 = <span class="string">'how are you? i am fine! thank you!'</span></span><br><span class="line">print(str2.index(<span class="string">'you'</span>))</span><br><span class="line">print(str2.find(<span class="string">'you'</span>))</span><br></pre></td></tr></table></figure>

<p>当字符串不存在的时候：index报错，find返回-1</p>
<h2 id="6、join"><a href="#6、join" class="headerlink" title="6、join"></a>6、join</h2><p><strong>字符串.join(序列) - 将序列中的元素用字符串连接在一起，产生新的字符串</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str3 = <span class="string">'+'</span>.join(<span class="string">'abc'</span>)</span><br><span class="line">print(str3)</span><br><span class="line">str4 = <span class="string">''</span>.join(<span class="string">'234cc'</span>)</span><br><span class="line">print(str4)</span><br><span class="line">str5 = <span class="string">''</span>.join(&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;)</span><br><span class="line">print(str5)</span><br></pre></td></tr></table></figure>

<h2 id="7、字符串替换"><a href="#7、字符串替换" class="headerlink" title="7、字符串替换"></a>7、字符串替换</h2><p><strong>字符串1.replace(字符串2，字符串3)——将字符串1中所有的字符串2都替换成字符串3</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str2 = <span class="string">'how are you? i am fine! thank you!'</span></span><br><span class="line">str2.replace(<span class="string">'you'</span>, <span class="string">'me'</span>)</span><br></pre></td></tr></table></figure>

<p><strong>字符串1.maketrans(字符串2，字符串3)——创建字符串2和字符串3—一对应的映射表</strong><br><strong>字符串1.translate(替换映射表) ——将字符串1中所有的字符串2都替换成字符串3</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">table = str.maketrans(<span class="string">'a'</span>,<span class="string">'b'</span>)</span><br><span class="line">new_str2 = str2.translate(table)</span><br><span class="line">print(new_str2)</span><br></pre></td></tr></table></figure>

<h2 id="8、切割"><a href="#8、切割" class="headerlink" title="8、切割"></a>8、切割</h2><p>字符串1.split(字符串2)——将字符串1中所有的字符串2作为切割点切成多分,切割点会被去掉并返回一个列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str2 = <span class="string">'how are you? i am fine! thank you!'</span></span><br><span class="line">print(str2.split(<span class="string">' '</span>))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础：9:函数基础</title>
    <url>/2018/06/17/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.9%20%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="一、认识函数"><a href="#一、认识函数" class="headerlink" title="一、认识函数"></a>一、认识函数</h1><h2 id="1、什么是函数"><a href="#1、什么是函数" class="headerlink" title="1、什么是函数"></a>1、什么是函数</h2><h3 id="1）、函数的定义：函数就是对实现某一特定功能的代码的封装"><a href="#1）、函数的定义：函数就是对实现某一特定功能的代码的封装" class="headerlink" title="1）、函数的定义：函数就是对实现某一特定功能的代码的封装"></a>1）、函数的定义：函数就是对实现某一特定功能的代码的封装</h3><h3 id="2）、函数的分类："><a href="#2）、函数的分类：" class="headerlink" title="2）、函数的分类："></a>2）、函数的分类：</h3><p>  ①、系统函数 - 语言系统自带的，可以直接调用的函数：print、len、chr、ord、input…<br>  ②、自定义函数 - 开发者自己声明的函数</p>
<br>

<hr>
<h1 id="二、函数的声明"><a href="#二、函数的声明" class="headerlink" title="二、函数的声明"></a>二、函数的声明</h1><h2 id="1、语法："><a href="#1、语法：" class="headerlink" title="1、语法："></a>1、语法：</h2><p><strong>def 函数名(参数列表)：<br>&emsp;函数说明文档<br>&emsp;函数体</strong></p>
<h2 id="2、说明："><a href="#2、说明：" class="headerlink" title="2、说明："></a>2、说明：</h2><ul>
<li><p>def———-&gt;关键字，固定写法</p>
</li>
<li><p>函数名———-&gt;和变量名的要求一样</p>
</li>
<li><p>():———-&gt;固定写法</p>
</li>
<li><p>参数列表———-&gt;又叫形参；（参数名1，参数名2，参数名3…）参数名就是变量名；将函数外面的数据传到函数里面</p>
</li>
<li><p>函数说明文档 ———-&gt;本质就是一段注释<br>（要求：①必须在第一行有效代码的前面；②需要使用三个双引号引起来的注释)</p>
</li>
<li><p>函数体———-&gt;和def保持一个缩进的一条或多条的代码；也是实现函数功能的代码。</p>
</li>
</ul>
<h2 id="3、声明函数的步骤（重要）"><a href="#3、声明函数的步骤（重要）" class="headerlink" title="3、声明函数的步骤（重要）"></a>3、声明函数的步骤（重要）</h2><p>①、确定函数的功能<br>②、函数名 见名知义<br>③、确定参数（形参），看实现函数的功能需不需要额外的数据，需要几个就设置几个形参<br>④、实现函数的功能<br>⑤、写说明文档</p>
<p><strong>注意：声明函数的时候不会执行函数体</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 声明一个函数，打印两个数的和</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diy_sum</span><span class="params">(num1, num2)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  (函数功能说明区)求两个数的和</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  print(num1 + num2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">diy_sum(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明一个函数求阶乘N!</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diy_factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">  pro = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    pro *= x</span><br><span class="line">  print(<span class="string">'%d的阶乘是：%d'</span> % (n, pro))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">diy_factorial(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<br>

<hr>
<h1 id="三、函数的调用"><a href="#三、函数的调用" class="headerlink" title="三、函数的调用"></a>三、函数的调用</h1><h2 id="1、语法：-1"><a href="#1、语法：-1" class="headerlink" title="1、语法："></a>1、语法：</h2><p><strong>函数（实参列表）</strong></p>
<h2 id="2、说明"><a href="#2、说明" class="headerlink" title="2、说明"></a>2、说明</h2><ul>
<li>函数———-&gt;已经声明的函数</li>
<li>()———-&gt;固定写法</li>
<li>实参列表———-&gt;需要传递到函数中使用的具体数据，用来给形参赋值的；写法：多个数据用逗号隔开；</li>
</ul>
<h2 id="3、函数的调用过程-重要"><a href="#3、函数的调用过程-重要" class="headerlink" title="3、函数的调用过程(重要)"></a>3、函数的调用过程(重要)</h2><p>①：回到函数声明的位置<br>②：传参—用实参给形参赋值(必须保证每个形参都有之，不能多也不能少)<br>③：执行函数体<br>④：确定返回值<br>⑤：回到函数调用的位置接着往后执行代码</p>
<br>

<hr>
<h1 id="四、参数"><a href="#四、参数" class="headerlink" title="四、参数"></a>四、参数</h1><h2 id="1、参数赋值"><a href="#1、参数赋值" class="headerlink" title="1、参数赋值"></a>1、参数赋值</h2><h3 id="1）、位置参数———-gt-让实参的值和形参的位置一一对应"><a href="#1）、位置参数———-gt-让实参的值和形参的位置一一对应" class="headerlink" title="1）、位置参数———-&gt;让实参的值和形参的位置一一对应"></a>1）、位置参数———-&gt;让实参的值和形参的位置一一对应</h3><h3 id="2）、关键字参数———-gt-调用函数的时候以‘形参名1-值1，形参名2-值2…’"><a href="#2）、关键字参数———-gt-调用函数的时候以‘形参名1-值1，形参名2-值2…’" class="headerlink" title="2）、关键字参数———-&gt;调用函数的时候以‘形参名1=值1，形参名2=值2…’"></a>2）、关键字参数———-&gt;调用函数的时候以‘形参名1=值1，形参名2=值2…’</h3><h3 id="3）、位置参数和关键字参数混用———-gt-混用的时候必须保证位置参数在关键字参数的前面，同时保证每个参数必须有值"><a href="#3）、位置参数和关键字参数混用———-gt-混用的时候必须保证位置参数在关键字参数的前面，同时保证每个参数必须有值" class="headerlink" title="3）、位置参数和关键字参数混用———-&gt;混用的时候必须保证位置参数在关键字参数的前面，同时保证每个参数必须有值"></a>3）、位置参数和关键字参数混用———-&gt;混用的时候必须保证位置参数在关键字参数的前面，同时保证每个参数必须有值</h3><h2 id="2、参数默认值"><a href="#2、参数默认值" class="headerlink" title="2、参数默认值"></a>2、参数默认值</h2><ul>
<li>声明函数的时候，可以通过’参数名=值’的形式给参数默认值；有默认值的参数在调用时可以不赋值</li>
<li>关键参数的使用场景：想要跳过前面有默认值的参数给后面的参数赋值时只能用关键字参数</li>
<li>有默认值的参数必须放在没有默认值的参数的后面</li>
</ul>
<h2 id="3、参数类型说明"><a href="#3、参数类型说明" class="headerlink" title="3、参数类型说明"></a>3、参数类型说明</h2><p>1）、给参数赋默认值，默认值是什么类型，就默认参数是什么类型<br>2）、在形参后面加冒号加类型名，<strong>形参:类型名</strong><br>3）、在形参括号后面加类型名，表示返回值的类型：   #   def diy_print2(a=1, b=5, c=30) -&gt; str:</p>
<h2 id="4、不定长参数"><a href="#4、不定长参数" class="headerlink" title="4、不定长参数"></a>4、不定长参数</h2><p><strong>声明函数的时候参数个数不确定</strong></p>
<p>①、<strong>声明函数时在参数名称前加星号*</strong>，这个参数就会变成一个元素，元组内的元素就是对应的实参；<br>  <strong>注意：</strong>a.只能使用位置参数赋值<br>&emsp;&emsp;&emsp;b.不定长参数后面如果有其他的定长参数，那么后面的参数必须使用位置参数赋值<br><strong>def func(*x):<br>  def func(name, *grade):<br>  def func(name, *grade, tel):</strong></p>
<p>②、<strong>声明函数时在参数名称前加两个星号**</strong>，这个参数就会变成一个字典(关键字:实参值)<br><strong>注意：a.只能使用关键字参数赋值<br>&emsp;&emsp;&emsp;b.*和**同时使用还是不定长参数，可以同时使用位置参数和关键字参数；(*要放到**前面)</strong></p>
<p>③、<strong>一个星和两个星一起用：</strong><br>  def func(*args, **kwargs):</p>
]]></content>
      <categories>
        <category>Python学录</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django入门之选课系统</title>
    <url>/2020/01/05/%E5%90%8E%E7%AB%AF/Django%E5%85%A5%E9%97%A8%E4%B9%8B%E9%80%89%E8%AF%BE%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>Django是高水准的Python编程语言驱动的一个开源框架</p>
<a id="more"></a>


<h1 id="一丶Django简述"><a href="#一丶Django简述" class="headerlink" title="一丶Django简述"></a>一丶Django简述</h1><p>Django 最初由2003年到2005年间由负责创建和维护报纸网站的网络团队开发。它是一个高级的 Python 网络框架，可以快速开发安全和可维护的网站。</p>
<h2 id="Django框架基本工作流程"><a href="#Django框架基本工作流程" class="headerlink" title="Django框架基本工作流程"></a>Django框架基本工作流程</h2><p>在传统的数据驱动网站中，Web应用程序会等待来自Web浏览器（或其他客户端）的 HTTP 请求。当接收到请求时，应用程序根据 URL 和可能的 POST 数据或 GET 数据中的信息确定需要的内容。根据需要，可以从数据库读取或写入信息，或执行满足请求所需的其他任务。然后，该应用程序将返回对Web浏览器的响应，通常通过将检索到的数据插入 HTML模板中的占位符来动态创建用于浏览器显示的 HTML 页面。</p>
<p>MVC架构模式<br>架构规范: 数据和显示要分离(模型和视图解耦合)<br>同一个模型可以渲染成不同的视图,同一个视图可以加载不同的模型</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">M</span>   --<span class="literal">-</span>&gt;   <span class="comment">model</span>          --<span class="literal">-</span>&gt;   <span class="comment">模型</span>     --<span class="literal">-</span>&gt;   <span class="comment">数据</span></span><br><span class="line"><span class="comment">V</span>   --<span class="literal">-</span>&gt;   <span class="comment">View</span>           --<span class="literal">-</span>&gt;   <span class="comment">视图</span>     --<span class="literal">-</span>&gt;   <span class="comment">数据显示</span></span><br><span class="line"><span class="comment">C</span>   --<span class="literal">-</span>&gt;   <span class="comment">Contyoller</span>     --<span class="literal">-</span>&gt;   <span class="comment">控制器</span>    --<span class="literal">-</span>&gt;   <span class="comment">连接数据和显示的中间商</span></span><br></pre></td></tr></table></figure>

<p>Django (MTV架构模式)网络应用程序通常将处理每个步骤的代码分组到单独的文件中;如图所示:</p>
<p><img src="https://github.com/anjhon1994/some_image/blob/master/Django-MTV%E6%A8%A1%E5%BC%8F%E5%9B%BE.png?raw=true" alt="DjangoMTV架构"></p>
<p>📌 URL映射器用于根据请求URL将HTTP请求重定向到相应的视图。URL映射器还可以匹配出现在URL中的字符串或数字的特定模式，并将其作为数据传递给视图功能。<br>📌 View:  视图 是一个请求处理函数，它接收HTTP请求并返回HTTP响应。视图通过模型访问满足请求所需的数据，并将响应的格式委托给  模板。<br>📌 Models:  模型 是定义应用程序数据结构的Python对象，并提供在数据库中管理（添加，修改，删除）和查询记录的机制。<br>📌 Templates: 模板 是定义文件（例如HTML页面）的结构或布局的文本文件，用于表示实际内容的占位符。一个视图可以使用HTML模板，从数据填充它动态地创建一个HTML页面模型。可以使用模板来定义任何类型的文件的结构; 它不一定是HTML！</p>
<br>
<hr>

<h1 id="二丶Django简单页面生成"><a href="#二丶Django简单页面生成" class="headerlink" title="二丶Django简单页面生成"></a>二丶Django简单页面生成</h1><h2 id="1-创建一个Django项目"><a href="#1-创建一个Django项目" class="headerlink" title="1. 创建一个Django项目"></a>1. 创建一个Django项目</h2><p>创建Django项目的方式很多,这里简单介绍三种</p>
  <!-- tab 方法一 -->
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">   django-admin   -   django包管理员工具</span><br><span class="line"></span><br><span class="line">1. 在命令提示符内(我用了Git)输入</span><br><span class="line">	~ django-admin startproject polls   # 创建一个新项目</span><br><span class="line">2. 使用PyCharm打开项目并创建虚拟环境</span><br><span class="line">	~ cd polls   # 进入项目文件夹</span><br><span class="line">	~ python3 -m venv venv   # 新建虚拟环境</span><br><span class="line">	~ <span class="string">"venv/Scripts/activate"</span>   # 激活虚拟环境</span><br><span class="line">3. 安装项目依赖项:</span><br><span class="line">	打开Pycharm底部的Terminal,输入</span><br><span class="line">	~ pip install django mysqlclient django-redis pillow requests</span><br><span class="line">	使用pip安装三方库时，可以通过如<span class="attribute">django</span>==1.11.27的方式来指定三方库的版本。</span><br><span class="line">4. 运行django项目</span><br><span class="line">	~ python manage.py runserver</span><br><span class="line">	~ python manage.py runserver 127.0.0.1:80   # 指定端口为80</span><br><span class="line">5. 添加项目运行快捷方式</span><br><span class="line">	<span class="builtin-name">Add</span> Configuration  ---&gt;  +  ---&gt;  Python  ---&gt; <span class="built_in"> Script </span>Path (manage.py)  --&gt;  Parameters (runserver)</span><br></pre></td></tr></table></figure>
  <!-- endtab -->
  <!-- tab 方法二 -->
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 用PyCharm创建一个普通的Python项目</span><br><span class="line"><span class="number">2.</span> 安装Django所需的依赖项</span><br><span class="line">    ~ pip install django==<span class="number">2.1</span><span class="number">.14</span> -i https:<span class="comment">//pypi.doubanio.com/simple</span></span><br><span class="line"><span class="number">3.</span> 把Python项目变成Django项目</span><br><span class="line">    ~ django-admin startproject polls .</span><br><span class="line"><span class="number">4.</span> 运行项目</span><br><span class="line">	~ python manage.py runserver</span><br></pre></td></tr></table></figure>
  <!-- endtab -->
  <!-- tab 方法三 -->
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">存在远端仓库时需要克隆项目到本地</span><br><span class="line"><span class="number">1</span>. 克隆</span><br><span class="line">    使用PyCharm新建页面的<span class="string">"get from version control"</span></span><br><span class="line">    ~ git <span class="keyword">clone</span> <span class="title">git</span>@gitee.com:anjhon/polls.git   <span class="comment"># 地址需要自行更换</span></span><br><span class="line"><span class="number">2</span>. 创建虚拟环境(项目中一般不会将虚拟环境纳入版本控制)</span><br><span class="line">    ~ Linux/macOS: source venv/bin/activate</span><br><span class="line">    ~ Windows: <span class="string">"venv/Scripts/activate"</span></span><br><span class="line"><span class="number">3</span>. 重建依赖项</span><br><span class="line">    ~ pip install -r requirements.txt   <span class="comment"># requirements文件为依赖项清单</span></span><br></pre></td></tr></table></figure>
  <!-- endtab -->


<p>创建好新项目之后就能看到飞升的小火箭了</p>
<p><img src="https://github.com/anjhon1994/some_image/blob/master/Django%E8%BF%90%E8%A1%8C%E5%9B%BE.Png?raw=true" alt="运行图"></p>
<h2 id="2-简单的文件配置"><a href="#2-简单的文件配置" class="headerlink" title="2. 简单的文件配置"></a>2. 简单的文件配置</h2><h3 id="设置语言时区"><a href="#设置语言时区" class="headerlink" title="设置语言时区"></a>设置语言时区</h3><figure class="highlight diff"><figcaption><span>polls/setting.py </span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="deletion">- LANGUAGE_CODE = 'en-us'</span></span><br><span class="line"><span class="addition">+ LANGUAGE_CODE = 'zh-hans'</span></span><br><span class="line"><span class="deletion">- TIME_ZONE = 'UTC'</span></span><br><span class="line"><span class="addition">+ TIME_ZONE = 'Asia/Chongqing'</span></span><br></pre></td></tr></table></figure>

<h3 id="设置tamplates文件夹路径"><a href="#设置tamplates文件夹路径" class="headerlink" title="设置tamplates文件夹路径"></a>设置tamplates文件夹路径</h3><figure class="highlight diff"><figcaption><span>polls/setting.py </span></figcaption><table><tr><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        'BACKEND': 	'django.template.backends.django.DjangoTemplates',</span><br><span class="line"><span class="deletion">-       'DIRS': [],</span></span><br><span class="line"><span class="addition">+       'DIRS': [os.path.join(BASE_DIR, 'templates')],</span></span><br><span class="line">        'APP_DIRS': True,</span><br><span class="line">	...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="3-创建Django应用"><a href="#3-创建Django应用" class="headerlink" title="3. 创建Django应用"></a>3. 创建Django应用</h2><p>在控制台输入:</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">方法一</span><br><span class="line">~ python manage.py startapp app</span><br><span class="line">方法二</span><br><span class="line">~ django-admin startapp app</span><br><span class="line">在新建好的应用文件夹下创建templates文件夹(用来存放前端页面)</span><br></pre></td></tr></table></figure>
<p>创建好应用后,应用文件夹视图如下:</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line">-- <span class="string">app</span></span><br><span class="line"><span class="string"> </span>    |<span class="built_in">--migrations</span></span><br><span class="line"><span class="built_in"></span>     |		|<span class="built_in">--__init__.py</span>   <span class="comment"># 一个空文件，告诉Python解释器这个目录应该被视为一个Python的包。</span></span><br><span class="line">     |<span class="built_in">--__init__.py</span>   </span><br><span class="line">     |<span class="built_in">--admin.py</span>   <span class="comment"># 可以用来注册模型，用于在Django的管理界面管理模型。</span></span><br><span class="line">     |<span class="built_in">--apps.py</span>   <span class="comment"># 当前应用的配置文件。</span></span><br><span class="line">     |<span class="built_in">--models.py</span>   <span class="comment"># 存放应用的数据模型，即实体类及其之间的关系（MVC/MTV中的M）。</span></span><br><span class="line">     |<span class="built_in">--tests.py</span>   <span class="comment"># 包含测试应用各项功能的测试类和测试函数。</span></span><br><span class="line">     |<span class="built_in">--views.py</span>   <span class="comment"># 处理请求并返回响应的函数（MVC中的C，MTV中的V）。</span></span><br></pre></td></tr></table></figure>
<p>最后别忘了配置一下新建的应用</p>
<figure class="highlight diff"><figcaption><span>polls/setting.py</span></figcaption><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    'django.contrib.admin',</span><br><span class="line">    'django.contrib.auth',</span><br><span class="line">    'django.contrib.contenttypes',</span><br><span class="line">    'django.contrib.sessions',</span><br><span class="line">    'django.contrib.messages',</span><br><span class="line">    'django.contrib.staticfiles',</span><br><span class="line"><span class="addition">+   'polls',</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="4-要怎样自定义一个页面呢"><a href="#4-要怎样自定义一个页面呢" class="headerlink" title="4. 要怎样自定义一个页面呢?"></a>4. 要怎样自定义一个页面呢?</h2><p>第一步: 配置url控制器</p>
<figure class="highlight diff"><figcaption><span>polls/urls.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path</span><br><span class="line">from app.views import index   # 这里导入了视图里的函数index</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path('admin/', admin.site.urls),</span><br><span class="line"><span class="addition">+   path('', index)   # 这里调用了视图里的函数index</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>第二部: 写视图函数</p>
<figure class="highlight diff"><figcaption><span>app/views.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from random import sample</span><br><span class="line">from django.http import HttpRequest</span><br><span class="line">from django.shortcuts import render</span><br><span class="line"></span><br><span class="line">def index(request: HttpRequest):   # 定义一个index函数</span><br><span class="line">    musics = ['嚣张', '让世间美好与你环环相扣', '无问', '膨胀', '野孩子', '海阔天空', '爱情买卖', '快乐男孩', ]</span><br><span class="line">    context = &#123;</span><br><span class="line">        'musics': sample(musics, 3),</span><br><span class="line">        'greeting': 'Hello, Django'</span><br><span class="line">    &#125;</span><br><span class="line">    return render(request, "index.html", context)   # 返回了一个html页面</span><br></pre></td></tr></table></figure>
<p>第三步: 编写前端模板页</p>
<figure class="highlight diff"><figcaption><span>templates/index.html</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; greeting &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;hr/&gt;</span><br><span class="line">&lt;!--    django模板页,可以使用django模板语法和模板指令生成动态内容  --&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &#123;% for music in musics %&#125;</span><br><span class="line">        &lt;li&gt;&#123;&#123; music &#125;&#125;&lt;/li&gt;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>好了,一个简单的网页产生了!</p>
<br>
<hr>

<h1 id="三丶Django制作简单的选课系统"><a href="#三丶Django制作简单的选课系统" class="headerlink" title="三丶Django制作简单的选课系统"></a>三丶Django制作简单的选课系统</h1><p>邓爷爷说: 实践才是检验真理的唯一标准</p>
<p>在第二节我们实现了简单网页,但是只是用到了视图和模板,并没有涉及到数据; 要知道,在真正的项目中,这是不可能存在的,所以本节我们将通过实操一个小型的项目来带大家快速熟悉Django框架</p>
<h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.  环境准备"></a>1.  环境准备</h2><p>①: 安装Python操作MySQL的依赖库</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">~ pip <span class="keyword">install</span> pymysql</span><br></pre></td></tr></table></figure>

<p>②: 设置数据库连接参数</p>
<figure class="highlight diff"><figcaption><span>polls/setting.py</span></figcaption><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    'default': &#123;</span><br><span class="line"><span class="deletion">-       'ENGINE': 'django.db.backends.sqlite3',</span></span><br><span class="line"><span class="addition">+       'ENGINE': 'django.db.backends.mysql',</span></span><br><span class="line"><span class="deletion">-       'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),</span></span><br><span class="line"><span class="addition">+       'NAME': 'anjhon',</span></span><br><span class="line"><span class="addition">+       'HOST': '0.0.0.0',   # 这里地址需要自行更改,可以连接本地数据库,参数为:localhost</span></span><br><span class="line"><span class="addition">+       'PORT': 3306,</span></span><br><span class="line"><span class="addition">+       'USER': 'anjhon',</span></span><br><span class="line"><span class="addition">+       'PASSWORD': '123456',</span></span><br><span class="line"><span class="addition">+       'CHARSET': 'utf8',</span></span><br><span class="line"><span class="addition">+       'TIME_ZONE': 'Asia/Chongqing',</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-创建数据模型"><a href="#2-创建数据模型" class="headerlink" title="2. 创建数据模型"></a>2. 创建数据模型</h2><h3 id="创建数据模型"><a href="#创建数据模型" class="headerlink" title="创建数据模型"></a>创建数据模型</h3><figure class="highlight diff"><figcaption><span>app/models.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class Subject(models.Model):</span><br><span class="line">    """学科模型类"""</span><br><span class="line">    nums = models.AutoField(primary_key=True, verbose_name='编号')   # 自增,主键</span><br><span class="line">    name = models.CharField(max_length=20, verbose_name='名称')   # 20长度的字符串</span><br><span class="line">    intro = models.CharField(max_length=1000, verbose_name='介绍')   # 1000长度的字符串</span><br><span class="line">    is_hot = models.BooleanField(default=False, verbose_name='是否热门')</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        db_table = 'tb_subject'</span><br><span class="line">        verbose_name = '学科'</span><br><span class="line">        verbose_name_plural = '学科'</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Teacher(models.Model):</span><br><span class="line">    """老师模型"""</span><br><span class="line">    nums = models.AutoField(primary_key=True, verbose_name='教师编号')</span><br><span class="line">    name = models.CharField(max_length=20, verbose_name='教师姓名')</span><br><span class="line">    sex = models.BooleanField(default=True, verbose_name='性别')</span><br><span class="line">    birth = models.DateField(verbose_name='教师生日')</span><br><span class="line">    photo = models.ImageField(upload_to='images', default='', max_length=512, verbose_name='头像')</span><br><span class="line">    intro = models.CharField(default='', max_length=1000, verbose_name='教师介绍')</span><br><span class="line">    good_count = models.PositiveIntegerField(default=0, verbose_name='好评数')</span><br><span class="line">    bad_count = models.IntegerField(default=0, verbose_name='差评数')</span><br><span class="line">    subject  = models.ForeignKey(to=Subject, on_delete=models.PROTECT, db_column='snums', verbose_name='所属学科')   # 该教师学科的名字</span><br><span class="line"></span><br><span class="line">    class Meta:   # 元信息,元数据(描述数据的数据)</span><br><span class="line">        db_table = 'tb_teacher'</span><br><span class="line">        verbose_name = '教师'</span><br><span class="line">        verbose_name_plural = '教师'</span><br></pre></td></tr></table></figure>

<p>参数小结:<br>    IntegerField   对应数据库中的integer类型，<br>    CharField   对应数据库的varchar类型，<br>    DecimalField   对应数据库的decimal类型，<br>    ForeignKey   用来建立多对一外键关联。<br>    primary_key   用于设置主键，<br>    max_length   用来设置字段的最大长度，<br>    db_column   用来设置数据库中与字段对应的列，<br>    verbose_name   则设置了Django后台管理系统中该字段显示的名称。</p>
<h3 id="将模型变成数据库内的表格"><a href="#将模型变成数据库内的表格" class="headerlink" title="将模型变成数据库内的表格"></a>将模型变成数据库内的表格</h3><figure class="highlight diff"><figcaption><span>Pycharm内的Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line"># 生成迁移文件</span><br><span class="line">~ python manage.py makemigrations polls</span><br><span class="line"># 执行迁移</span><br><span class="line">~ python manage.py migrate</span><br></pre></td></tr></table></figure>
<p>到这一步,我们的数据库里就已经生成好了学科和老师的数据表格,这时我们需要进入到Django自带的后台管理系统,管理数据;</p>
<p>扩展:<br>数据表建好以后,反向建模型到models.py文件:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">python</span> manage.<span class="keyword">py</span> inspectdb &gt; common/models.<span class="keyword">py</span></span><br></pre></td></tr></table></figure>

<h3 id="远端数据库设置"><a href="#远端数据库设置" class="headerlink" title="远端数据库设置"></a>远端数据库设置</h3><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">create database djangocase default charset utf8 collate utf8_bin;   ---&gt;   创建数据库</span><br><span class="line">grant all privileges on djangocase.<span class="symbol">*</span> to 'anjhon'<span class="meta">@'%';</span>   ---&gt;   给用户权限</span><br><span class="line"></span><br><span class="line">(venv) C:\djangocase&gt;</span><br><span class="line">    python manage.py migrate   ---&gt;   执行迁移</span><br><span class="line"></span><br><span class="line">use djangocase;   ---&gt;   切换数据库</span><br><span class="line">show tables;   ---&gt;   显示表格</span><br><span class="line">+----------------------------+</span><br><span class="line">|<span class="string"> Tables_in_djangocase       </span>|</span><br><span class="line">+----------------------------+</span><br><span class="line">|<span class="string"> auth_group                 </span>|</span><br><span class="line">|<span class="string"> auth_group_permissions     </span>|</span><br><span class="line">|<span class="string"> auth_permission            </span>|</span><br><span class="line">|<span class="string"> auth_user                  </span>|</span><br><span class="line">|<span class="string"> auth_user_groups           </span>|</span><br><span class="line">|<span class="string"> auth_user_user_permissions </span>|</span><br><span class="line">|<span class="string"> django_admin_log           </span>|</span><br><span class="line">|<span class="string"> django_content_type        </span>|</span><br><span class="line">|<span class="string"> django_migrations          </span>|</span><br><span class="line">|<span class="string"> django_session             </span>|</span><br><span class="line">|<span class="string"> jet_bookmark               </span>|</span><br><span class="line">|<span class="string"> jet_pinnedapplication      </span>|</span><br><span class="line">+----------------------------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">(venv) C:\polls&gt;</span><br><span class="line">	python manage.py createsuperuser   ---&gt;   创建超级管理员</span><br></pre></td></tr></table></figure>

<h2 id="3-后台管理"><a href="#3-后台管理" class="headerlink" title="3. 后台管理"></a>3. 后台管理</h2><p>①:  创建超级管理员账号</p>
<figure class="highlight diff"><figcaption><span>Pycharm内的Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line">~ python manage.py createsuperuser</span><br><span class="line">Username : anjhon</span><br><span class="line">Email address: anjhon@163.com</span><br><span class="line">Password:       # 密码不显示</span><br><span class="line">Password (again): </span><br><span class="line">Superuser created successfully.</span><br></pre></td></tr></table></figure>

<p>②:  注册模型</p>
<figure class="highlight diff"><figcaption><span>polls/admin.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from polls.models import Subject, Teacher</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SubjectAdmin(admin.ModelAdmin):</span><br><span class="line">    list_display = ('nums', 'name', 'intro', 'is_hot')   # 默认显示学科对象,该语句可以显示学科编号,名称,介绍.</span><br><span class="line">    list_display_links = ('name', 'nums', )</span><br><span class="line">    search_fields = ('name', )   # 可以按名字搜索</span><br><span class="line">    ordering = ('nums', )   # 根据nums排升序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TeacherAdmin(admin.ModelAdmin):</span><br><span class="line">    list_display = ('nums', 'name', 'sex', 'birth', 'intro', 'good_count', 'bad_count', 'subject')</span><br><span class="line">    search_fields = ('name', )</span><br><span class="line">    ordering = ('nums',)</span><br></pre></td></tr></table></figure>

<p>③: 登录管理员后台</p>
<figure class="highlight diff"><figcaption><span>Pycharm内的Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line"># 开启服务器</span><br><span class="line">~ python manage.py runserver</span><br><span class="line"># 访问</span><br><span class="line">http://127.0.0.1:8000/admin</span><br></pre></td></tr></table></figure>

<p>这里输入刚刚的超级管理员的密码就能登录了;不过由于界面实在不忍直视,所以我决定给他换个jet主题!</p>
<ol>
<li><p>安装jet</p>
<figure class="highlight diff"><figcaption><span>Pycharm内的Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line">~ pip install django-jet -i https://pypi.doubanio.com/simple</span><br></pre></td></tr></table></figure></li>
<li><p>添加应用</p>
<figure class="highlight diff"><figcaption><span>polls/settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line"><span class="addition">+   'jet',</span></span><br><span class="line">    'django.contrib.admin',</span><br><span class="line">    'django.contrib.auth',</span><br><span class="line">    'django.contrib.contenttypes',</span><br><span class="line">    'django.contrib.sessions',</span><br><span class="line">    'django.contrib.messages',</span><br><span class="line">    'django.contrib.staticfiles',</span><br><span class="line">    'polls',</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>注: jet要加到最前面,不然Django会先加载自带的主题,这样就没什么效果了</p>
</li>
<li><p>执行迁移：</p>
<figure class="highlight diff"><figcaption><span>Pycharm内的Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line">~ python manage.py migrate jet</span><br></pre></td></tr></table></figure></li>
<li><p>配置URL</p>
<figure class="highlight diff"><figcaption><span>polls/urls.py</span></figcaption><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path('admin/', admin.site.urls),</span><br><span class="line"><span class="addition">+   path('jet/', include('jet.urls', 'jet')),</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>大功告成!</p>
</li>
</ol>
<p>进入后台之后就可以添加老师和学科的数据了;<br>至此,数据准备完成!</p>
<h2 id="4-网页成型"><a href="#4-网页成型" class="headerlink" title="4. 网页成型"></a>4. 网页成型</h2><p>①: 同样的,先配置url</p>
<figure class="highlight diff"><figcaption><span>polls/urls.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from django.conf import settings</span><br><span class="line">from django.conf.urls.static import static</span><br><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path, include</span><br><span class="line">from polls.views import index, show_teachers, praise_or_criticize, \</span><br><span class="line">    login, get_captcha, logout</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path('jet/', include('jet.urls', 'jet')),</span><br><span class="line">    path('admin/', admin.site.urls),</span><br><span class="line">    path('', index),</span><br><span class="line"><span class="addition">+   path('teachers/', show_teachers),   # 教师信息页面</span></span><br><span class="line"><span class="addition">+   path('praise/', praise_or_criticize),   # 好评</span></span><br><span class="line"><span class="addition">+   path('criticize/', praise_or_criticize),   # 差评</span></span><br><span class="line"><span class="addition">+   path('login/', login),   # 登录</span></span><br><span class="line"><span class="addition">+   path('logout/', logout),   # 注销</span></span><br><span class="line"><span class="addition">+   path('captcha/', get_captcha),   # 验证码</span></span><br><span class="line">] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)</span><br></pre></td></tr></table></figure>
<p>②: 写视图函数</p>
<figure class="highlight diff"><figcaption><span>app/views.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from base64 import b64decode</span><br><span class="line">from django.http import JsonResponse, HttpResponse</span><br><span class="line">from django.shortcuts import render, redirect</span><br><span class="line">from polls.captcha import Captcha</span><br><span class="line">from polls.models import Subject, Teacher, User</span><br><span class="line">from polls.utils import random_text, to_md5_hex, check_username, check_password</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    """首页（获取所有学科）"""</span><br><span class="line">    queryset = Subject.objects.all()</span><br><span class="line">    context = &#123;</span><br><span class="line">        'subjects': queryset</span><br><span class="line">    &#125;</span><br><span class="line">    return render(request, 'subjects.html', context)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show_teachers(request):</span><br><span class="line">    """显示指定学科的老师"""</span><br><span class="line">    try:</span><br><span class="line">        sno = request.GET['sno']</span><br><span class="line">        subject = Subject.objects.get(no=sno)</span><br><span class="line">        queryset = Teacher.objects.filter(subject__no=sno)</span><br><span class="line">        context = &#123;</span><br><span class="line">            'subject': subject,</span><br><span class="line">            'teachers': queryset</span><br><span class="line">        &#125;</span><br><span class="line">        return render(request, 'teachers.html', context)</span><br><span class="line">    except (KeyError, ValueError, Subject.DoesNotExist):</span><br><span class="line">        return redirect('/')</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def praise_or_criticize(request):</span><br><span class="line">    """好评或差评"""</span><br><span class="line">    if request.session.get('userid') is None:</span><br><span class="line">        data = &#123;'code': 10002, 'message': '请先登录'&#125;</span><br><span class="line">    else:</span><br><span class="line">        tno = request.GET.get('tno', '0')</span><br><span class="line">        try:</span><br><span class="line">            teacher = Teacher.objects.get(no=tno)</span><br><span class="line">            if request.path.startswith('/praise'):</span><br><span class="line">                teacher.good_count += 1</span><br><span class="line">            else:</span><br><span class="line">                teacher.bad_count += 1</span><br><span class="line">            teacher.save()</span><br><span class="line">            data = &#123;'code': 10000, 'message': '操作成功'&#125;</span><br><span class="line">        except (ValueError, Teacher.DoesNotExist):</span><br><span class="line">            data = &#123;'code': 10001, 'message': '操作失败'&#125;</span><br><span class="line">    return JsonResponse(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def login(request):</span><br><span class="line">    """登录"""</span><br><span class="line">    backurl = request.GET.get('backurl', '')</span><br><span class="line">    hint = ''</span><br><span class="line">    if request.method == 'POST':</span><br><span class="line">        # 获取用户输入的验证码</span><br><span class="line">        code_from_user = request.POST.get('captcha', '0').lower()</span><br><span class="line">        # 获取用户输入的验证码</span><br><span class="line">        code_from_serv = request.session.get('code', '1').lower()</span><br><span class="line">        # 若用户验证码和服务器验证码相同,则进入登录流程</span><br><span class="line">        if code_from_user == code_from_serv:</span><br><span class="line">            # 获取用户输入的用户名</span><br><span class="line">            username = request.POST.get('username', '')</span><br><span class="line">            # 获取用户输入的密码</span><br><span class="line">            password = request.POST.get('password', '')</span><br><span class="line">            # 检查用户名和密码是否复合规范</span><br><span class="line">            if check_username(username) and check_password(password):</span><br><span class="line">                # 生成密码摘要</span><br><span class="line">                password = to_md5_hex(password)</span><br><span class="line">                # 从数据库获取用户信息对象保存到user中</span><br><span class="line">                user = User.objects.filter(username=username, password=password).first()</span><br><span class="line"></span><br><span class="line">                if user:   # 若匹配成功,将用户的信息保存到session对象中,方便cookie连接</span><br><span class="line">                    # 登录成功后为了记住这个登录成功的用户</span><br><span class="line">                    # 我们可以在服务器端保存和用户相关的信息</span><br><span class="line">                    # 我们可以将这些信息保存在Django框架提供的session对象中</span><br><span class="line">                    request.session['userid'] = user.no</span><br><span class="line">                    request.session['username'] = user.username</span><br><span class="line">                    backurl = request.POST.get('backurl')</span><br><span class="line">                    if backurl:</span><br><span class="line">                        backurl = b64decode(backurl).decode()</span><br><span class="line">                    else:</span><br><span class="line">                        backurl = '/'</span><br><span class="line">                    return redirect(backurl)</span><br><span class="line">                else:</span><br><span class="line">                    hint = '用户登录信息错误!'</span><br><span class="line">            else:</span><br><span class="line">                hint = '请输入登录信息!'</span><br><span class="line">        else:</span><br><span class="line">            hint = '请输入正确的验证码!'</span><br><span class="line">    context = &#123;</span><br><span class="line">        'hint': hint,</span><br><span class="line">        'backurl': backurl</span><br><span class="line">    &#125;</span><br><span class="line">    return render(request, 'login.html', context)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def logout(request):</span><br><span class="line">    # 清空session对象中的数据</span><br><span class="line">    request.session.flush()</span><br><span class="line">    # 重定向到主页面</span><br><span class="line">    return redirect('/')</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_captcha(request):</span><br><span class="line">    """获取验证码图片"""</span><br><span class="line">    code = random_text()</span><br><span class="line">    image_data = Captcha.instance().generate(code)</span><br><span class="line">    request.session['code'] = code</span><br><span class="line">    return HttpResponse(image_data, content_type='image/png')</span><br></pre></td></tr></table></figure>

<p>③: 网页模板<br>首页学科页</p>
<figure class="highlight diff"><figcaption><span>templates/subjects.html</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        body &#123;</span><br><span class="line">            width: 920px;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">        &#125;</span><br><span class="line">        .subject &#123;</span><br><span class="line">            margin: 20px 20px;</span><br><span class="line">        &#125;</span><br><span class="line">        .sname &#123;</span><br><span class="line">            font: bold 28px Arial;</span><br><span class="line">        &#125;</span><br><span class="line">        a &#123;</span><br><span class="line">            color: blue;</span><br><span class="line">            text-decoration: none;</span><br><span class="line">        &#125;</span><br><span class="line">        .nav &#123;</span><br><span class="line">            float: right;</span><br><span class="line">            margin-top: 20px;</span><br><span class="line">        &#125;</span><br><span class="line">        .nav+h2 &#123;</span><br><span class="line">            clear: both;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class="nav"&gt;</span><br><span class="line">        &#123;% if request.session.userid %&#125;</span><br><span class="line">        &#123;&#123; request.session.username &#125;&#125;</span><br><span class="line">        &lt;a href="/logout/"&gt;注销&lt;/a&gt;</span><br><span class="line">        &#123;% else %&#125;</span><br><span class="line">        &lt;a href="/login/"&gt;登录&lt;/a&gt;&amp;nbsp;</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">        &lt;a href=""&gt;注册&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;h2&gt;所有学科&lt;/h2&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &#123;% for subject in subjects %&#125;</span><br><span class="line">    &lt;div class="subject"&gt;</span><br><span class="line">        &lt;p class="sname"&gt;</span><br><span class="line">            &lt;a href="/teachers/?sno=&#123;&#123; subject.no &#125;&#125;"&gt;&#123;&#123; subject.name &#125;&#125;&lt;/a&gt;</span><br><span class="line">            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br><span class="line">            &#123;% if subject.is_hot %&#125;</span><br><span class="line">            &lt;img src='/static/images/hot-icon-small.png'&gt;</span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123; subject.intro &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>教师信息页</p>
<figure class="highlight diff"><figcaption><span>templates/teachers.html</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;老师信息&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        body &#123;</span><br><span class="line">            width: 920px;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">        &#125;</span><br><span class="line">        .teacher &#123;</span><br><span class="line">            clear: both;</span><br><span class="line">        &#125;</span><br><span class="line">        .photo &#123;</span><br><span class="line">            margin-top: 20px;</span><br><span class="line">            width: 140px;</span><br><span class="line">            height: 140px;</span><br><span class="line">            border-radius: 70px 70px 70px 70px;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        .content &#123;</span><br><span class="line">            margin-left: 60px;</span><br><span class="line">            width: 580px;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        .keyinfo &#123;</span><br><span class="line">            font: bold 18px Arial;</span><br><span class="line">        &#125;</span><br><span class="line">        .back &#123;</span><br><span class="line">            float: right;</span><br><span class="line">            margin-top: 20px;</span><br><span class="line">        &#125;</span><br><span class="line">        .back&gt;a &#123;</span><br><span class="line">            text-decoration: none;</span><br><span class="line">            color: blue;</span><br><span class="line">        &#125;</span><br><span class="line">        .back+h2 &#123;</span><br><span class="line">            clear: both;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class="back"&gt;</span><br><span class="line">        &lt;a href="/"&gt;返回首页&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; subject.name &#125;&#125;学科老师信息&lt;/h2&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &#123;% for teacher in teachers %&#125;</span><br><span class="line">    &lt;div class="teacher"&gt;</span><br><span class="line">        &lt;div class="photo"&gt;</span><br><span class="line">            &lt;img src="&#123;&#123; teacher.photo.url &#125;&#125;" width="140"&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class="content"&gt;</span><br><span class="line">            &lt;p class="keyinfo"&gt;</span><br><span class="line">                &#123;&#123; teacher.name &#125;&#125;&amp;nbsp;&amp;nbsp;</span><br><span class="line">                &#123;&#123; teacher.sex | yesno:"男, 女" &#125;&#125;&amp;nbsp;&amp;nbsp;</span><br><span class="line">                &#123;&#123; teacher.birth &#125;&#125;</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">                &#123;&#123; teacher.intro &#125;&#125;</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">            &lt;p class="comment"&gt;</span><br><span class="line">                &lt;a href="/praise/?tno=&#123;&#123; teacher.no &#125;&#125;"&gt;好评&lt;/a&gt;（&lt;span&gt;&#123;&#123; teacher.good_count &#125;&#125;&lt;/span&gt;）&amp;nbsp;&amp;nbsp;</span><br><span class="line">                &lt;a href="/criticize/?tno=&#123;&#123; teacher.no &#125;&#125;"&gt;差评&lt;/a&gt;（&lt;span&gt;&#123;&#123; teacher.bad_count &#125;&#125;&lt;/span&gt;）</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    &lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    // $()函数中的箭头函数是页面加载完成之后要执行的回调函数</span><br><span class="line">    $(() =&gt; &#123;</span><br><span class="line">        let flag = true</span><br><span class="line">        // 通过$(选择器)获取页面元素绑定点击事件</span><br><span class="line">        // on方法的第一个参数是事件名 第二个参数是事件回调函数</span><br><span class="line">        // 事件回调函数的参数evt是代表事件的对象</span><br><span class="line">        $('.comment&gt;a').on('click', (evt) =&gt; &#123;</span><br><span class="line">            // 阻止事件默认行为（避免直接刷新页面）</span><br><span class="line">            evt.preventDefault()</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                // 实现函数节流</span><br><span class="line">                flag = false</span><br><span class="line">                setTimeout(() =&gt; &#123; flag = true &#125;, 2000)</span><br><span class="line">                // 通过事件对象获取事件源并由$函数转成jQuery对象</span><br><span class="line">                let anchor = $(evt.target)</span><br><span class="line">                // 通过jQuery对象的getJSON方法发起Ajax请求</span><br><span class="line">                // 第一个参数是请求的URL</span><br><span class="line">                // 第二个参数是请求完成之后要执行的回调函数</span><br><span class="line">                $.getJSON(anchor.attr('href'), (json) =&gt; &#123;</span><br><span class="line">                    if (json.code == 10000) &#123; // 投票成功</span><br><span class="line">                        // 获取与a标签相邻的span标签</span><br><span class="line">                        let span = anchor.next()</span><br><span class="line">                        // 将span标签的值加1再写回span标签</span><br><span class="line">                        span.text(parseInt(span.text()) + 1)</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        alert(json.message)</span><br><span class="line">                        if (json.code == 10002) &#123;</span><br><span class="line">                            location.href = '/login/?backurl=' + btoa('/teachers/?sno=&#123;&#123; subject.no &#125;&#125;')</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alert('操作太频繁')</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>登录页</p>
<figure class="highlight diff"><figcaption><span>templates/login.html</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;用户登录&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #container &#123;</span><br><span class="line">            width: 920px;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">        &#125;</span><br><span class="line">        .input, form+a &#123;</span><br><span class="line">            margin: 30px 10px;</span><br><span class="line">            width: 400px;</span><br><span class="line">            height: 32px;</span><br><span class="line">        &#125;</span><br><span class="line">        .input&gt;input &#123;</span><br><span class="line">            border: none;</span><br><span class="line">            outline: none;</span><br><span class="line">            border-bottom: 1px dotted darkgray;</span><br><span class="line">            width: 180px;</span><br><span class="line">        &#125;</span><br><span class="line">        .input:last-child&gt;input &#123;</span><br><span class="line">            border: none;</span><br><span class="line">            background-color: red;</span><br><span class="line">            color: white;</span><br><span class="line">            width: 80px;</span><br><span class="line">            height: 25px;</span><br><span class="line">        &#125;</span><br><span class="line">        .input&gt;label &#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            width: 80px;</span><br><span class="line">            text-align: right;</span><br><span class="line">        &#125;</span><br><span class="line">        .input:last-child &#123;</span><br><span class="line">            text-align: center;</span><br><span class="line">            border: none;</span><br><span class="line">            margin-left: -20px;</span><br><span class="line">        &#125;</span><br><span class="line">        .input&gt;img &#123;</span><br><span class="line">            vertical-align: middle;</span><br><span class="line">        &#125;</span><br><span class="line">        a &#123;</span><br><span class="line">            text-decoration: none;</span><br><span class="line">            color: blue;</span><br><span class="line">        &#125;</span><br><span class="line">        .hint &#123;</span><br><span class="line">            font-size: 12px;</span><br><span class="line">            color: red;</span><br><span class="line">            height: 20px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id="container"&gt;</span><br><span class="line">        &lt;h2&gt;用户登录&lt;/h2&gt;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">        &lt;p class="hint"&gt;&#123;&#123; hint &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;form action="/login/?backurl=&#123;&#123; backurl &#125;&#125;" method="post"&gt;</span><br><span class="line">            &#123;% csrf_token %&#125;</span><br><span class="line">            &lt;div class="input"&gt;</span><br><span class="line">                &lt;label&gt;用户名：&lt;/label&gt;</span><br><span class="line">                &lt;input type="text" name="username"&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class="input"&gt;</span><br><span class="line">                &lt;label&gt;密码：&lt;/label&gt;</span><br><span class="line">                &lt;input type="password" name="password"&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class="input"&gt;</span><br><span class="line">                &lt;label&gt;验证码：&lt;/label&gt;</span><br><span class="line">                &lt;input type="text" name="captcha"&gt;</span><br><span class="line">                &lt;img id="code" src="/captcha/" height="33"&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class="input"&gt;</span><br><span class="line">                &lt;input type="submit" value="登录"&gt;</span><br><span class="line">                &lt;input type="reset" value="重置"&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">        &lt;a href="/"&gt;返回首页&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    $(() =&gt; &#123;</span><br><span class="line">        $('#code').on('click', (evt) =&gt; &#123;</span><br><span class="line">            $(evt.target).attr('src', '/captcha/?' + Math.random())</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>页面布局完成!</p>
<p>④:  补充<br>在项目目录下新建文件夹static, 专门用来存放静态资源,在static下创建css, js, image文件夹,分别用来存放样式表, js文件, 图片资源<br>为了让html文件能够找到保存静态资源的文件夹，还需要修改Django项目的配置文件settings.py</p>
<figure class="highlight diff"><figcaption><span>polls/settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="addition">+ STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static'), ]</span></span><br><span class="line">  STATIC_URL = '/static/'</span><br></pre></td></tr></table></figure>
<p>最后在使用时需要在html文件中较前的位置加入代码</p>
<figure class="highlight diff"><figcaption><span>引用本地静态文件</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="addition">+&#123;% load staticfiles %&#125;</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">	&lt;meta charset="utf-8"&gt;</span><br><span class="line">	&lt;title&gt;&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5-再补充一点"><a href="#5-再补充一点" class="headerlink" title="5. 再补充一点"></a>5. 再补充一点</h2><h3 id="cookie和session的关系"><a href="#cookie和session的关系" class="headerlink" title="cookie和session的关系"></a>cookie和session的关系</h3><p>HTTP协议是无连接无状态协议   —&gt;<br>两次请求之间不会保存用户的任何数据;<br>再次请求服务器的时候服务器无法得知请求是来自哪个用户的请求;<br>一般情况下服务器应用都需要记住用户来为用户提供更好的服务;<br>如果希望服务器记住用户可以使用以下三种辅助方式:</p>
<ol>
<li>URL重写<a href="http://www.baidu.com/?uid=xxxxxx" target="_blank" rel="noopener">http://www.baidu.com/?uid=xxxxxx</a></li>
<li>隐藏域(隐式表单域)   —&gt;   埋点<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;<span class="keyword">input</span> <span class="keyword">type</span>="hidden"<span class="type">name</span>="uid"<span class="keyword">value</span>="xxxxxx"&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li>
<li>浏览器本地存储<br> ~ cookie   —&gt;   浏览器中的零食文件,可以保存键值对;cookie中的数据在发起HTTP请求时会自动加载到请求头中<br> ~ window.localStorage / window.sessionStorage</li>
</ol>
<p>request.session   —&gt;   存储登录成功的用户信息,session是服务器内的一个对象<br>cookie   -—-&gt;   用户浏览器临时文件   -—-&gt;   cookie中保存了session的ID</p>
<h3 id="编码小知识"><a href="#编码小知识" class="headerlink" title="编码小知识"></a>编码小知识</h3><p>通常如果一样东西需要编码，说明这样东西并不适合传输。原因多种多样，如Size过大，包含隐私数据，对于Url来说，之所以要进行编码，是因为Url中有些字符会引起歧义。</p>
<h4 id="BASE64编码"><a href="#BASE64编码" class="headerlink" title="BASE64编码"></a>BASE64编码</h4><p>用64个文字符号表示任意二进制数据<br>原理：将原来的三字节每6个比特一组变成四个字节<br>用A-Z、a-z、0-9、+和/一共64个字符来代表一个字节</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">base64编码:</span><br><span class="line">python内</span><br><span class="line">from base64 import b64encode, b64decode</span><br><span class="line"><span class="function"><span class="title">b64encode</span><span class="params">(<span class="string">'...'</span>.encode()</span></span>) ---&gt;  base64编码</span><br><span class="line"><span class="function"><span class="title">b64decode</span><span class="params">(b<span class="string">'...'</span>)</span></span>  ---&gt;  base64解码</span><br><span class="line"></span><br><span class="line">JavaScript内</span><br><span class="line"><span class="function"><span class="title">btoa</span><span class="params">(<span class="string">'url'</span>)</span></span>   ---&gt;   编码</span><br><span class="line"><span class="function"><span class="title">atob</span><span class="params">(<span class="string">'...'</span>)</span></span>   ---&gt;   解码</span><br></pre></td></tr></table></figure>
<h4 id="百分号编码-Url编码"><a href="#百分号编码-Url编码" class="headerlink" title="百分号编码(Url编码)"></a>百分号编码(Url编码)</h4><p>使用%百分号加上两位的字符(十六进制0~F)。URL编码默认使用的字符集是US-ASCII。例如 a 在US-ASCII码中对应的字节是0x61，那么URL编码之后得到的就 是%61，我们在地址栏上输入;又如@符号在ASCII字符集中对应的字节为0x40，经过URL编码之后得到的是%40。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">from urllib<span class="selector-class">.parse</span> import quote</span><br><span class="line"><span class="function"><span class="title">quote</span><span class="params">(<span class="string">'经理人数据统计表.xls'</span>)</span></span>  编码</span><br><span class="line"><span class="function"><span class="title">unquote</span><span class="params">(<span class="string">'...'</span>)</span></span>   解码</span><br></pre></td></tr></table></figure>


<h4 id="常用知识点"><a href="#常用知识点" class="headerlink" title="常用知识点"></a>常用知识点</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">python manage.py runserver   <span class="comment">---&gt;   运行django服务器</span></span><br><span class="line">python manage.py createsuperuser   <span class="comment">---&gt;   创建超级管理员账号</span></span><br><span class="line">python manage.py makemigrations polls   <span class="comment">---&gt;  迁移文件</span></span><br><span class="line">python manage.py migrate   <span class="comment">---&gt;  执行迁移</span></span><br><span class="line"></span><br><span class="line">Teacher.objects.<span class="keyword">filter</span>(nums=tnums).first()   <span class="comment">---&gt;   获取nums和tnums相等的教师的所有信息</span></span><br><span class="line"></span><br><span class="line">request.path   <span class="comment">---&gt;   得到请求路径</span></span><br><span class="line">request.<span class="keyword">method</span>   <span class="comment">---&gt;   得到请求方法</span></span><br><span class="line">request.POST.<span class="keyword">get</span>(<span class="string">'username'</span>, <span class="string">''</span>)   <span class="comment">---&gt;   获取post请求提供的username对应的值,若没有username对应的值则获取空串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> JsonResponse(data)   <span class="comment">---&gt;   直接返回json格式的数据</span></span><br><span class="line">render(request, )   <span class="comment">---&gt;   渲染页面,必定有request参数</span></span><br><span class="line">redirect()   <span class="comment">---&gt;   页面重定向</span></span><br><span class="line"></span><br><span class="line">pip install -r requirements.txt   <span class="comment">---&gt;   根据依赖项文件安装依赖</span></span><br><span class="line">pip <span class="keyword">freeze</span> &gt; requirements.txt   <span class="comment">---&gt;    重写依赖项清单</span></span><br></pre></td></tr></table></figure>


<h2 id="6-最后小结"><a href="#6-最后小结" class="headerlink" title="6. 最后小结"></a>6. 最后小结</h2><h3 id="项目流程"><a href="#项目流程" class="headerlink" title="项目流程"></a>项目流程</h3><p>django-admin startproject 项目名称   —&gt;   创建项目<br>git init   —&gt;   将项目文件夹初始化成git仓库<br>vim .gitignore   —&gt;   创建.gitignore文件,将不进行版本控制的文件名放进去,<br>gitignore.io   —&gt;   版本忽略文件生成网站<br>vim requirements.txt   —&gt;   创建项目依赖项文件</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">加入项目需要的依赖项</span><br><span class="line"><span class="attribute">Django</span>==2.2.9</span><br><span class="line"><span class="attribute">django-jet</span>==1.0.8</span><br><span class="line"><span class="attribute">django-redis</span>==4.11.0</span><br><span class="line"><span class="attribute">mysqlclient</span>==1.4.6</span><br><span class="line"><span class="attribute">pytz</span>==2019.3</span><br><span class="line"><span class="attribute">redis</span>==3.3.11</span><br><span class="line"><span class="attribute">sqlparse</span>==0.3.0</span><br></pre></td></tr></table></figure>

<h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><pre><code>git add .
git status
git commit -m &apos;项目初始版本&apos;
git status
git log
git tag v0.1
git remote add origin git@gitee.com:anjhon1994/djangocase.git   # 地址关联
git remote remove origin   # 取消关联
rm -rf .git   # 取消仓库初始化
git push -u origin master   # 推送
git remote -v   # 查看远端仓库的地址</code></pre><br>
<hr>



<p>🌞相关文档连接:<br>    <a href="https://gitee.com/anjhon1994/Django1906" target="_blank" rel="noopener">点击下载本文完整代码</a><br>    <a href="https://developer.mozilla.org/zh-CN/docs/learn/Server-side/Django/Introduction" target="_blank" rel="noopener">MDN-Django介绍</a><br>    <a href="https://github.com/jackfrued/Python-100-Days/blob/master/Day91-100/95.%E4%BD%BF%E7%94%A8Django%E5%BC%80%E5%8F%91%E5%95%86%E4%B8%9A%E9%A1%B9%E7%9B%AE.md" target="_blank" rel="noopener">大佬详细教程</a></p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>后端</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django进阶</title>
    <url>/2020/01/12/%E5%90%8E%E7%AB%AF/Django%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>Django进阶和API接口</p>
<a id="more"></a>

<h1 id="一丶-工欲善其事必先利其器"><a href="#一丶-工欲善其事必先利其器" class="headerlink" title="一丶 工欲善其事必先利其器"></a>一丶 工欲善其事必先利其器</h1><h2 id="1-pip全局使用豆瓣镜像设置"><a href="#1-pip全局使用豆瓣镜像设置" class="headerlink" title="1. pip全局使用豆瓣镜像设置"></a>1. pip全局使用豆瓣镜像设置</h2><h3 id="windows系统中"><a href="#windows系统中" class="headerlink" title="windows系统中"></a>windows系统中</h3><p>①在c盘—&gt;用户—&gt;anjhon—&gt;文件夹中创建pip文件夹<br>②在pip文件夹中创建pip.ini文件<br>③在pip.ini文件中添加以下代码</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">global</span>]</span><br><span class="line"><span class="built_in">index</span>-url=http<span class="variable">s:</span>//pypi.doubanio.<span class="keyword">com</span>/simple</span><br></pre></td></tr></table></figure>

<h3 id="git中"><a href="#git中" class="headerlink" title="git中"></a>git中</h3><p>cd ~   (进入用户组目录)<br>进入.pip文件夹(没有就创建)<br>创建pip.conf文件<br>在文件内添加以下代码</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">global</span>]</span><br><span class="line"><span class="built_in">index</span>-url=http<span class="variable">s:</span>//pypi.doubanio.<span class="keyword">com</span>/simple</span><br></pre></td></tr></table></figure>

<h2 id="2-调试工具Debug-Tool-Bar安装"><a href="#2-调试工具Debug-Tool-Bar安装" class="headerlink" title="2. 调试工具Debug-Tool-Bar安装"></a>2. 调试工具Debug-Tool-Bar安装</h2><ol>
<li>安装：<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install </span>django-<span class="built_in">debug</span>-toolbar</span><br></pre></td></tr></table></figure></li>
<li>添加app<figure class="highlight diff"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">'debug_toolbar',</span><br></pre></td></tr></table></figure></li>
<li>添加中间键<figure class="highlight diff"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">'debug_toolbar.middleware.DebugToolbarMiddleware',</span><br></pre></td></tr></table></figure></li>
<li>配置前端效果：<figure class="highlight diff"><figcaption><span>setting.py</span></figcaption><table><tr><td class="code"><pre><span class="line">DEBUG_TOOLBAR_CONFIG = &#123;</span><br><span class="line">    # 引入jQuery库</span><br><span class="line">    'JQUERY_URL': 'https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js',</span><br><span class="line">    # 工具栏是否折叠</span><br><span class="line">    'SHOW_COLLAPSED': True,</span><br><span class="line">    # 是否显示工具栏</span><br><span class="line">    'SHOW_TOOLBAR_CALLBACK': lambda x: True,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>路由配置<figure class="highlight diff"><figcaption><span>urls.py</span></figcaption><table><tr><td class="code"><pre><span class="line">if settings.DEBUG:</span><br><span class="line">    import debug_toolbar</span><br><span class="line">	urlpatterns.insert(0, path('__debug__/', include(debug_toolbar.urls)))</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h1 id="二丶-Django用法进阶"><a href="#二丶-Django用法进阶" class="headerlink" title="二丶 Django用法进阶"></a>二丶 Django用法进阶</h1><h2 id="1-django自带分页器"><a href="#1-django自带分页器" class="headerlink" title="1. django自带分页器"></a>1. django自带分页器</h2><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"># 导入分页工具</span><br><span class="line">from django.core.paginator <span class="keyword">import</span> Paginator</span><br><span class="line"></span><br><span class="line"># 调用分页器函数会返回一个对象</span><br><span class="line">page_obj = = Paginator(obj_list, per_page)</span><br><span class="line">	obj_list是需要分页的内容</span><br><span class="line">	per_page是每页的内容数量,一般为int类型</span><br><span class="line">	</span><br><span class="line"># 对象的使用方法</span><br><span class="line"><span class="function"><span class="title">page_obj</span>.has_previous  ---&gt;</span>  是否存在前一页（布尔值）</span><br><span class="line"><span class="function"><span class="title">page_obj</span>.has_next  ---&gt;</span>  是否存在下一页（布尔值）</span><br><span class="line"><span class="function"><span class="title">page_obj</span>.previous_page_number  ---&gt;</span>  前一页的页码（数值）</span><br><span class="line"><span class="function"><span class="title">page_obj</span>.next_page_number  ---&gt;</span>  下一页的页码（数值）</span><br><span class="line"><span class="function"><span class="title">page_obj</span>.number  ---&gt;</span>  当前页的页码（数值）</span><br><span class="line"><span class="function"><span class="title">page_obj</span>.get_page(<span class="built_in">page</span>)  ---&gt;</span>  ???</span><br><span class="line"><span class="function"><span class="title">page_obj</span>.<span class="built_in">page</span>(3)  ---&gt;</span>  访问指定页面</span><br><span class="line"><span class="function"><span class="title">page2</span>.start_index()  ---&gt;</span>  从<span class="number">1</span>开始计数的当前页的第一个对象</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="function"><span class="title">page2</span>.end_index()  ---&gt;</span>  从<span class="number">1</span>开始计数的当前页最后<span class="number">1</span>个对象</span><br><span class="line"><span class="function"><span class="title">paginator</span>.page_range  ---&gt;</span>  页码范围（迭代对象）</span><br><span class="line"><span class="function"><span class="title">paginator</span>.num_pages  ---&gt;</span>  页面总数量（数值）</span><br></pre></td></tr></table></figure>

<h2 id="2-查询-查询结果是集合类型的对象"><a href="#2-查询-查询结果是集合类型的对象" class="headerlink" title="2. 查询(查询结果是集合类型的对象)"></a>2. 查询(查询结果是集合类型的对象)</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Entry.objects.all()   ---&gt;   查询所有记录</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定查询:only</span></span><br><span class="line">queryset = Teacher.objects.filter(<span class="attribute">subject__no</span>=sno).only('', <span class="string">''</span>, <span class="string">''</span>)</span><br><span class="line"><span class="comment"># 排除查询:defer</span></span><br><span class="line">queryset = Teacher.objects.filter(<span class="attribute">subject__no</span>=sno).defer('', <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 空值查询:</span></span><br><span class="line">District.objects.filter(<span class="attribute">pid__null</span>=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 条件查询:</span></span><br><span class="line">Entry.objects.filter(<span class="attribute">num</span>=3)   ---&gt;   查询<span class="attribute">num</span>=3的数据记录</span><br><span class="line">Entry.objects.exclude(<span class="attribute">num</span>=3)   ---&gt;   查询<span class="attribute">num</span>=3的数据记录</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用切片的方法可以进行范围取值,相当于SQL语句中的LIMIT和OFFSET子句</span></span><br><span class="line">Entry.objects.all()[:5]   ---&gt;   返回前5个对象</span><br><span class="line">Entry.objects.all()[5:10]   ---&gt;   返回第6个到第10个对象</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键字查询:</span></span><br><span class="line">1) 精确查询: __exact (默认就是精准查询,可以不写)</span><br><span class="line">Entry.objects.<span class="builtin-name">get</span>(<span class="attribute">headline__exact</span>=<span class="string">"Cat bites dog"</span>)</span><br><span class="line">2) 模糊查询</span><br><span class="line">__contains：是否包含</span><br><span class="line">__startswith: 以指定值开头</span><br><span class="line">__endswith：以指定值结尾</span><br><span class="line">3) 空查询</span><br><span class="line">isnull：是否为<span class="literal">null</span></span><br><span class="line">4) 范围查询</span><br><span class="line"><span class="keyword">in</span>：是否包含在范围内</span><br><span class="line">5) 比较查询</span><br><span class="line">gt、gte、lt、lte：大于、大于等于、小于、小于等于</span><br><span class="line">6) 日期查询</span><br><span class="line">year、month、day、week_day、hour、minute、second：对日期时间类型的属性进行运算</span><br><span class="line">7) 不区分大小写: __iexact</span><br><span class="line">Entry.objects.<span class="builtin-name">get</span>(<span class="attribute">name__iexact</span>=<span class="string">"beatles blog"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Q对象查询</span></span><br><span class="line">在查询的条件中需要组合条件时(例如两个条件“且”或者“或”)。我们可以使用Q()查询对象</span><br><span class="line"><span class="keyword">from</span> django.db.models import Q</span><br><span class="line">Q(<span class="attribute">question__startswith</span>=<span class="string">'What'</span>)</span><br><span class="line">可以在Q()对象的前面使用字符“~”来代表意义“非”</span><br><span class="line">可以使用 “&amp;”或者“|”还有括号来对条件进行分组从而组合成更加复杂的查询逻辑</span><br><span class="line">Q(<span class="attribute">question__startswith</span>=<span class="string">'Who'</span>) | Q(<span class="attribute">question__startswith</span>=<span class="string">'What'</span>)</span><br><span class="line">例:</span><br><span class="line">	queryset = Record.objects.filter(Q(<span class="attribute">car__carno__startswith</span>=carno) | Q(<span class="attribute">car__owner__contains</span>=carno)).select_related('car').order_by('-offend_time')[(page - 1) * size:page * size]</span><br><span class="line">	context[<span class="string">'records'</span>] = queryset</span><br><span class="line">	# .select_related(<span class="string">'car'</span>)   在Q对象中car__carno已经实现连表查询,这时再用.select_related(<span class="string">'car'</span>)语法连同car一起查询</span><br><span class="line">	</span><br><span class="line">	.prefetch_related(<span class="string">'...'</span>)   ---&gt;   多对多顺带查询</span><br><span class="line">	.select_related(<span class="string">'...'</span>)   ---&gt;   一对多顺带查询</span><br><span class="line">	避免1+n出现</span><br></pre></td></tr></table></figure>

<h2 id="3-Vue"><a href="#3-Vue" class="headerlink" title="3. Vue"></a>3. Vue</h2><figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml">1. 属性:</span></span><br><span class="line"><span class="xml">1) el属性  -   字符串，传选择器(一般写id选择器), 将当前创建的Vue对象和html中的标签进行关联</span></span><br><span class="line"><span class="xml">2) data属性  -  通过对象的属性提供数据</span></span><br><span class="line"><span class="xml">3) methods属性 -  通过对象属性提供方法</span></span><br><span class="line"><span class="xml">4) computed属性 -  属性值必须函数, 函数的返回值就是使用属性的值</span></span><br><span class="line"><span class="xml">5) created钩子 - 在实例被创建之后被调用</span></span><br><span class="line"><span class="xml">	</span></span><br><span class="line"><span class="xml">2. Vue指令</span></span><br><span class="line"><span class="xml">1) 标签内容  -  </span><span class="template-variable">&#123;&#123;Vue属性名&#125;&#125;</span></span><br><span class="line"><span class="xml">2) 标签属性  -  v-bind:标签属性 = 'Vue属性名'</span></span><br><span class="line"><span class="xml">3) if语句   -  v-if='Vue属性名' (如果Vue属性值是true对应的标签就显示，否则就隐藏)</span></span><br><span class="line"><span class="xml">4) 循环结构  -  v-for = '变量 in 类型是数组的Vue属性'</span></span><br><span class="line"><span class="xml">5) 双向绑定  -  v-model='Vue属性名' (一般在表单标签中有效)</span></span><br><span class="line"><span class="xml">6) 事件绑定  -  v-on:事件名</span></span><br><span class="line"></span><br><span class="line"><span class="xml">3. 补充</span></span><br><span class="line"><span class="xml">1) 可以直接在标签内用 @事件名 的方法绑定事件,并直接调用事件函数</span></span><br><span class="line"><span class="xml">	例:<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"prevPage()"</span>&gt;</span>上一页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">2) 缩写</span></span><br><span class="line"><span class="xml">v-bind 缩写</span></span><br><span class="line"><span class="xml">	<span class="comment">&lt;!-- 完整语法 --&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="comment">&lt;!-- 缩写 --&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">v-on 缩写</span></span><br><span class="line"><span class="xml">	<span class="comment">&lt;!-- 完整语法 --&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="comment">&lt;!-- 缩写 --&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="4-字段映射器bpmapper-将数据库的查询对象转换成字典"><a href="#4-字段映射器bpmapper-将数据库的查询对象转换成字典" class="headerlink" title="4. 字段映射器bpmapper:  将数据库的查询对象转换成字典"></a>4. 字段映射器bpmapper:  将数据库的查询对象转换成字典</h2><p>1) 在应用文件夹下新建映射器文件 : mappers.py</p>
<figure class="highlight diff"><figcaption><span>app/mappers.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from bpmappers import RawField, DelegateField</span><br><span class="line">from bpmappers.djangomodel import ModelMapper</span><br><span class="line">from polls.models import Subject, Teacher</span><br><span class="line"></span><br><span class="line">class SubjectMapper(ModelMapper):</span><br><span class="line">    """学科映射器"""</span><br><span class="line">    isHot = RawField('is_hot')</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        model = Subject</span><br><span class="line">        exclude = ('is_hot', )</span><br><span class="line">        </span><br><span class="line">    exclude = ()   ---&gt;   排除某些字段</span><br><span class="line">	fields = ()   ---&gt;   包含某些字段</span><br><span class="line">	fields = '__all__'   ---&gt;   序列化所有字段</span><br><span class="line">	isHot = RawField('is_hot')   ---&gt;   将后端的is_hot映射成前端的isHot</span><br><span class="line">	car = DelegateField(Car)   ---&gt;   将car字段委托Car类查询映射</span><br></pre></td></tr></table></figure>
<p>2) 调用映射器</p>
<figure class="highlight diff"><figcaption><span>app/views.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from polls.mappers import SubjectMapper</span><br><span class="line"></span><br><span class="line">def show_subjects(request):</span><br><span class="line">    """获取所有学科"""</span><br><span class="line">    queryset = Subject.objects.all()</span><br><span class="line">    subjects = [SubjectMapper(subject).as_dict()   # 调用映射器函数将查询对象变成有序字典</span><br><span class="line">                for subject in queryset]</span><br><span class="line">    return JsonResponse(subjects, safe=False)</span><br></pre></td></tr></table></figure>

<p>JsonResponse默认只能返回字典,若想返回列表需要给一个参数safe=False</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">return <span class="constructor">JsonResponse(<span class="params">subjects</span>, <span class="params">safe</span>=False)</span></span><br></pre></td></tr></table></figure>

<p>列表生成式语法: (性能比列表追加元素要好)</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">records = [RecordMapper(<span class="keyword">record</span>).as_dict()</span><br><span class="line">           <span class="keyword">for</span> <span class="keyword">record</span> <span class="keyword">in</span> page_obj.object_list]</span><br><span class="line"># 从page_obj.object_list中取元素<span class="keyword">record</span>, 将<span class="keyword">record</span>传给RecordMapper().as_dict()转换成字典再添加到records里面</span><br></pre></td></tr></table></figure>


<h2 id="5-fetch请求"><a href="#5-fetch请求" class="headerlink" title="5.  fetch请求"></a>5.  fetch请求</h2><p>基本语法:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'http://example.com/movies.json'</span>)   <span class="comment"># 返回一个包含响应结果的promise</span></span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span><span class="params">(response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> response.json();</span><br><span class="line">  &#125;)   <span class="comment"># 用.json()方法获取到的包含json数据的对象</span></span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span><span class="params">(myJson)</span> </span>&#123;</span><br><span class="line">    console.log(myJson);</span><br><span class="line">  &#125;);   <span class="comment"># 获取到json文件里的真实数据</span></span><br></pre></td></tr></table></figure>
<p>实例:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">let app = new Vue(&#123;</span><br><span class="line">			el: <span class="string">'#app'</span>,</span><br><span class="line">			<span class="keyword">data</span>: &#123;</span><br><span class="line">				<span class="string">'searched'</span>: <span class="literal">false</span>,</span><br><span class="line">				records: [],</span><br><span class="line">				current_page: <span class="number">1</span>,</span><br><span class="line">				total_page: <span class="number">0</span>,</span><br><span class="line">				carno: <span class="string">''</span></span><br><span class="line">				</span><br><span class="line">			&#125;,</span><br><span class="line">			methods: &#123;</span><br><span class="line">				search()&#123;</span><br><span class="line">					let url = <span class="string">'/search/?carno='</span> + <span class="keyword">this</span>.carno + <span class="string">'&amp;page='</span> + <span class="keyword">this</span>.current_page</span><br><span class="line">					fetch(url).then(resp =&gt; resp.json()).then(json =&gt; &#123;</span><br><span class="line">						<span class="keyword">this</span>.searched = json.searched;</span><br><span class="line">						<span class="keyword">this</span>.records = json.records;</span><br><span class="line">						<span class="keyword">this</span>.current_page = json.current_page;</span><br><span class="line">						<span class="keyword">this</span>.total_page = json.total_page</span><br><span class="line">					&#125;)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">	# 注:<span class="keyword">this</span>代表app对象</span><br></pre></td></tr></table></figure>


<h2 id="6-配置redis数据库作为缓存"><a href="#6-配置redis数据库作为缓存" class="headerlink" title="6. 配置redis数据库作为缓存"></a>6. 配置redis数据库作为缓存</h2><h3 id="1-redis配置-添加以下代码"><a href="#1-redis配置-添加以下代码" class="headerlink" title="1. redis配置(添加以下代码)"></a>1. redis配置(添加以下代码)</h3><figure class="highlight diff"><figcaption><span>project/settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line"># 添加缓存(可以配多组)</span><br><span class="line">CACHES = &#123;</span><br><span class="line">    # 默认缓存</span><br><span class="line">    'default': &#123;</span><br><span class="line">        # 用什么来做缓存</span><br><span class="line">        'BACKEND': 'django_redis.cache.RedisCache',</span><br><span class="line">        'LOCATION': [</span><br><span class="line">            # 可以一主多从</span><br><span class="line">            'redis://49.233.152.190:6379/0',   # 主机用来写</span><br><span class="line">            'redis://49.233.152.190:6379/0',   # 从机用来读(可以有多个)</span><br><span class="line">        ],</span><br><span class="line">        # 区别命名</span><br><span class="line">        'KEY_PREFIX': 'django19062',</span><br><span class="line">        'OPTIONS': &#123;</span><br><span class="line">            'CLIENT_CLASS': 'django_redis.client.DefaultClient',</span><br><span class="line"></span><br><span class="line">            # 池化技术(提前连接好,要用时借出去,用完还回来)用空间换时间</span><br><span class="line">            'CONNECTION_POOL_KWARGS': &#123;</span><br><span class="line">                # 最大连接数</span><br><span class="line">                'max_connections': 512,</span><br><span class="line">            &#125;,</span><br><span class="line">            'PASSWORD': '119148',</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 会话缓存(会话放到缓存的好处:  性能好,不用手动清理,利于水平扩展)</span><br><span class="line">    'session': &#123;</span><br><span class="line">        # 用什么来做缓存</span><br><span class="line">        'BACKEND': 'django_redis.cache.RedisCache',</span><br><span class="line">        'LOCATION': [</span><br><span class="line">            # 可以一主多从</span><br><span class="line">            'redis://49.233.152.190:6379/1',   # 主机用来写</span><br><span class="line">            # 'redis://49.233.152.190:6379/0',   # 从机用来读(可以有多个)</span><br><span class="line">        ],</span><br><span class="line">        # 键的前缀</span><br><span class="line">        'KEY_PREFIX': 'django19062',</span><br><span class="line">        'OPTIONS': &#123;</span><br><span class="line">            'CLIENT_CLASS': 'django_redis.client.DefaultClient',</span><br><span class="line"></span><br><span class="line">            # 池化技术(提前连接好,要用时借出去,用完还回来)用空间换时间</span><br><span class="line">            'CONNECTION_POOL_KWARGS': &#123;</span><br><span class="line">                # 最大连接数</span><br><span class="line">                'max_connections': 1024,</span><br><span class="line">            &#125;,</span><br><span class="line">            'PASSWORD': '119148',</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 配置使用缓存来支持用户会话</span><br><span class="line">SESSION_ENGINE = 'django.contrib.sessions.backends.cache'</span><br><span class="line"># 会话数据放在哪一组缓存中</span><br><span class="line">SESSION_CACHE_ALIAS = 'session'</span><br><span class="line"># 设置会话保存的时长(单位秒)</span><br><span class="line">SESSION_CACHE_AGE = 86400  # 86400秒为1天</span><br></pre></td></tr></table></figure>

<h3 id="2-为视图函数-添加缓存机制"><a href="#2-为视图函数-添加缓存机制" class="headerlink" title="2. 为视图函数 添加缓存机制"></a>2. 为视图函数 添加缓存机制</h3><figure class="highlight diff"><figcaption><span>app/views.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="addition">+ 	@cache_page(timeout=3600, cache='default')</span></span><br><span class="line">    def show_subjects(request):</span><br><span class="line">        """获取所有学科"""</span><br><span class="line">        queryset = Subject.objects.all()</span><br><span class="line">        subjects = [SubjectMapper(subject).as_dict()</span><br><span class="line">                    for subject in queryset]</span><br><span class="line">        return JsonResponse(subjects, safe=False)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="addition">+   @cache_page(timeout=300, cache='default')</span></span><br><span class="line">    def show_teachers(request):</span><br><span class="line">        """获取指定学科的老师"""</span><br><span class="line">        try:</span><br><span class="line">            sno = request.GET['sno']</span><br><span class="line">            subject = Subject.objects.get(no=sno)</span><br><span class="line">            queryset = Teacher.objects\</span><br><span class="line">                .filter(subject__no=sno).defer('subject')</span><br><span class="line">            teachers = [TeacherMapper(teacher).as_dict()</span><br><span class="line">                        for teacher in queryset]</span><br><span class="line">            data = &#123;</span><br><span class="line">                'subject': SubjectSimpleMapper(subject).as_dict(),</span><br><span class="line">                'teachers': teachers</span><br><span class="line">            &#125;</span><br><span class="line">            return JsonResponse(data)</span><br><span class="line">        except (KeyError, ValueError, Subject.DoesNotExist):</span><br><span class="line">            pass</span><br></pre></td></tr></table></figure>
<p>如你所见,添加缓存机制只需调用一个装饰器函数即可;在调用时需要传参,timeout为超时时间,在固定时间后缓存自动清除;cache选择缓存组;</p>
<h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h3><p>开启django服务,访问前端页面,然后观察控制台</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"># 第一次请求时在控制台中会使用<span class="keyword">select</span>语句在mysql中查询数据</span><br><span class="line">(<span class="number">0.289</span>) <span class="keyword">SELECT</span> <span class="symbol">`tb_subject`</span>.<span class="symbol">`no`</span>, <span class="symbol">`tb_subject`</span>.<span class="symbol">`name`</span>, <span class="symbol">`tb_subject`</span>.<span class="symbol">`intro`</span>, <span class="symbol">`tb_subject`</span>.<span class="symbol">`is_hot`</span> <span class="keyword">FROM</span> <span class="symbol">`tb_subject`</span> <span class="keyword">WHERE</span> <span class="symbol">`tb_subject`</span>.<span class="symbol">`no`</span> = <span class="number">1</span>; args=(1,)</span><br><span class="line">(0.358) <span class="keyword">SELECT</span> <span class="symbol">`tb_teacher`</span>.<span class="symbol">`no`</span>, <span class="symbol">`tb_teacher`</span>.<span class="symbol">`name`</span>, <span class="symbol">`tb_teacher`</span>.<span class="symbol">`sex`</span>, <span class="symbol">`tb_teacher`</span>.<span class="symbol">`birth`</span>, <span class="symbol">`tb_teacher`</span>.<span class="symbol">`photo`</span>, <span class="symbol">`tb_teacher`</span>.<span class="symbol">`intro`</span>, <span class="symbol">`tb_teacher`</span>.<span class="symbol">`good_count`</span>, <span class="symbol">`tb_teacher`</span>.<span class="symbol">`bad_count`</span> <span class="keyword">FROM</span> <span class="symbol">`tb_teacher`</span> <span class="keyword">WHERE</span> <span class="symbol">`tb_teacher`</span>.<span class="symbol">`sno`</span> = <span class="number">1</span>; args=(1,)</span><br><span class="line"></span><br><span class="line"># 再次刷新页面时直接从缓存中获取数据</span><br><span class="line">[08/Jan/2020 22:02:14] "GET /teachers/?sno=1 HTTP/1.1" 200 5605</span><br><span class="line">[08/Jan/2020 22:02:14] "GET /media/images/yuting.png HTTP/1.1" 304 0</span><br><span class="line">[08/Jan/2020 22:02:14] "GET /media/images/luohao.png HTTP/1.1" 304 0</span><br></pre></td></tr></table></figure>

<p>实时数据缓存到redis<br>在需要实时显示并且并发量较大时(例如简单的投票),若直接从sql数据库中取值则会大大增加数据库的压力,同时有一条请求在操作数据库的时候就会锁定该数据,完成后下一个请求才能操作.<br>此时将投票信息添加到缓存,再在缓存内添加定时任务,定时推送缓存的数据到数据库保存,这是一种牺牲暂时一致性,获取最终一致性和提高性能的方法</p>
<h1 id="三丶-API-应用程序编程接口"><a href="#三丶-API-应用程序编程接口" class="headerlink" title="三丶 API  -  应用程序编程接口"></a>三丶 API  -  应用程序编程接口</h1><p>自己定义的函数也是一种API接口<br>网络API   -   通过HTT请求一个URL获得数据</p>
<p>RESTful API</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">REpresentational State Transfer   <span class="comment">---&gt;   表述性状态转移</span></span><br><span class="line">REST架构两大特点: 无状态和幂等性</span><br><span class="line">HTTP协议请求行 <span class="keyword">GET</span> / POST / <span class="keyword">DELETE</span> / PUT / PATCH</span><br><span class="line">新建   <span class="comment">---&gt;   POST-不需要幂等性</span></span><br><span class="line">查看   <span class="comment">---&gt;   GET</span></span><br><span class="line">更新   <span class="comment">---&gt;   PUT/PATCH</span></span><br><span class="line">删除   <span class="comment">---&gt;   DELETE</span></span><br></pre></td></tr></table></figure>

<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作:"></a>1. 准备工作:</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) 安装djangorestframework</span><br><span class="line">pip <span class="keyword">install </span>djangorestframework</span><br><span class="line">pip <span class="keyword">install </span>drf-<span class="keyword">extensions</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">2) </span>在<span class="keyword">INSTALLED_APPS注册rest_framework</span></span><br><span class="line"><span class="keyword">INSTALLED_APPS </span>= [</span><br><span class="line">    <span class="string">'rest_framework'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="2-API接口"><a href="#2-API接口" class="headerlink" title="2. API接口"></a>2. API接口</h2><h3 id="1-FBV-基于函数的视图"><a href="#1-FBV-基于函数的视图" class="headerlink" title="1) FBV   -   基于函数的视图"></a>1) FBV   -   基于函数的视图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># urls.py   控制器</span></span><br><span class="line">path(<span class="string">'agent/'</span>, get_agent),</span><br><span class="line"></span><br><span class="line"><span class="comment"># serializers.py  映射器</span></span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> common.models <span class="keyword">import</span> Agent</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgentSimpleSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Agent</span><br><span class="line">        exclude = (<span class="string">'estates'</span>, )</span><br><span class="line">        </span><br><span class="line"><span class="comment"># view视图函数:</span></span><br><span class="line"><span class="meta">@api_view(('GET', ))   # 指定请求,其他请求没效果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_agent</span><span class="params">(request)</span>:</span></span><br><span class="line">    queryset = Agent.objects.all().defer(<span class="string">'estates'</span>)</span><br><span class="line">    serializer = AgentSimpleSerializer(queryset, many=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>


<h3 id="2-CBV-基于类的视图"><a href="#2-CBV-基于类的视图" class="headerlink" title="2) CBV   -   基于类的视图"></a>2) CBV   -   基于类的视图</h3><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="comment"># urls.py   控制器</span></span><br><span class="line">	path('estate/', EstatesView.as_view()),</span><br><span class="line">	path('estate/<span class="variable">&lt;int:pk&gt;</span>/', EstatesView.as_view())   <span class="comment"># pk参数是一种约定,不能修改</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="comment"># serializers.py  映射器</span></span><br><span class="line"><span class="keyword">from</span> rest_framework import serializers</span><br><span class="line"><span class="keyword">from</span> common.models import E<span class="keyword">state</span></span><br><span class="line">class E<span class="keyword">state</span>Serializer(serializers.ModelSerializer):</span><br><span class="line">    class Meta:</span><br><span class="line">        model = E<span class="keyword">state</span></span><br><span class="line">        exclude = ('agents', 'district')</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># exclude = ()   ---&gt;   排除某些字段</span></span><br><span class="line">	<span class="comment"># fields = ()   ---&gt;   包含某些字段</span></span><br><span class="line">	<span class="comment"># fields = '__all__'   ---&gt;   序列化所有字段</span></span><br><span class="line">	<span class="comment"># isHot = RawField('is_hot')   ---&gt;   将后端的is_hot映射成前端的isHot</span></span><br><span class="line">	<span class="comment"># car = DelegateField(Car)   ---&gt;   将car字段委托Car类查询映射</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment"># view.py :</span></span><br><span class="line">class EstatesView(ListAPIView, RetrieveAPIView):</span><br><span class="line">    queryset = E<span class="keyword">state</span>.objects.<span class="literal">all</span>().defer('district', 'agents')</span><br><span class="line">    serializer_class = E<span class="keyword">state</span>Serializer</span><br><span class="line">    <span class="comment"># 将请求单个数据和请求多个数据分开</span></span><br><span class="line">    def get(<span class="literal">self</span>, request, *args, **kwargs):</span><br><span class="line">        if 'pk' <span class="keyword">in</span> kwargs:</span><br><span class="line">            cls = RetrieveAPIView   <span class="comment"># 单</span></span><br><span class="line">        else:</span><br><span class="line">            cls = ListAPIView   <span class="comment"># 多</span></span><br><span class="line">        return cls.get(<span class="literal">self</span>, request, *args, **kwargs)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 父类的选择       </span></span><br><span class="line">        CreateAPIView   ---&gt;   新增</span><br><span class="line">        ListAPIView   ---&gt;   查询所有</span><br><span class="line">        RetrieveAPIView   ---&gt;   查询单个</span><br><span class="line">        DestroyAPIView   ---&gt;   删除</span><br><span class="line">        UpdateAPIView   ---&gt;   修改</span><br><span class="line">        ListCreateAPIView</span><br><span class="line">        RetrieveUpdateAPIView</span><br><span class="line">        RetrieveDestroyAPIView</span><br><span class="line">        RetrieveUpdateDestroyAPIView</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">🚩 全套接口视图集</span><br><span class="line">📌 view.py : </span><br><span class="line"><span class="keyword">from</span> rest_framework.viewsets import ModelViewSet</span><br><span class="line">class HouseTypeViewSet(ModelViewSet):</span><br><span class="line">    queryset = HouseType.objects.<span class="literal">all</span>()</span><br><span class="line">    serializer_class = HouseTypeSerializer</span><br><span class="line">    </span><br><span class="line">📌 urls.py : </span><br><span class="line">urlpatterns = [</span><br><span class="line">	...</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 路由器</span></span><br><span class="line">router = SimpleRouter()   <span class="comment"># 简单路由</span></span><br><span class="line">router.register('housetypes', HouseTypeViewSet)   <span class="comment"># 注册</span></span><br><span class="line">urlpatterns += router.urls   <span class="comment"># 添加</span></span><br></pre></td></tr></table></figure>

<h4 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试:"></a>接口测试:</h4><p>1:  三方库: requests </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">json</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">resp = requests.<span class="keyword">get</span>(<span class="string">'http://localhost:8000/api/estates/'</span>)</span><br><span class="line">estates = <span class="type">json</span>.loads(resp.text)</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">index</span>, estate <span class="keyword">in</span> enumerate(estates):</span><br><span class="line">    print(<span class="keyword">index</span>, estate)</span><br></pre></td></tr></table></figure>
<p>2: Postman和Postwomam软件</p>
<h2 id="3-DRF-分页"><a href="#3-DRF-分页" class="headerlink" title="3. DRF 分页"></a>3. DRF 分页</h2><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">P<span class="function"><span class="title">ageNumberPagination</span>   ---&gt;</span>   按页码分页</span><br><span class="line">L<span class="function"><span class="title">imitoffsetPagination</span>   ---&gt;</span>   跳过N条,查第N+<span class="number">1</span>条</span><br><span class="line">CursorPagination</span><br></pre></td></tr></table></figure>
<p>1) 自定义分页</p>
<figure class="highlight diff"><figcaption><span>setting.py</span></figcaption><table><tr><td class="code"><pre><span class="line">中间键后面添加以下代码(全部实现分页)</span><br><span class="line"></span><br><span class="line"># DRF配置文件</span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    # 按页码分页</span><br><span class="line">	'DEFAULT_PAGINATION_CLASS':'rest_framework.pagination.PageNumberPagination',</span><br><span class="line">    'PAGE_SIZE': 5,</span><br><span class="line">&#125;</span><br><span class="line"># 若单个视图类不想分页可以加以下代码:</span><br><span class="line">	pagination_class = None</span><br></pre></td></tr></table></figure>
<p>2) 游标分页</p>
<figure class="highlight diff"><figcaption><span>app/views.py</span></figcaption><table><tr><td class="code"><pre><span class="line"># 定义游标分页类</span><br><span class="line">class EstatePagination(CursorPagination):</span><br><span class="line">    page_size_query_param = 'size' # 自定义单页显示记录数</span><br><span class="line">    max_page_size = 20   # 单页最多记录数</span><br><span class="line">    ordering = 'estateid'   # 按楼盘id分页</span><br><span class="line"># 在视图类里面调用</span><br><span class="line">pagination_class = EstatePagination</span><br></pre></td></tr></table></figure>


<h2 id="4-DRF缓存"><a href="#4-DRF缓存" class="headerlink" title="4. DRF缓存"></a>4. DRF缓存</h2><p>依赖项drf-extensions==0.5.0 为DRF提供缓存扩展</p>
<p>1)  django里的装饰器@method_decorator可以将装饰函数的装饰器变成可以装饰类方法的装饰器</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@method_decorator</span>(decorator=cache_page(<span class="number">500</span>), name=<span class="string">'list'</span>)</span><br><span class="line"><span class="variable">@method_decorator</span>(decorator=cache_page(<span class="number">120</span>), name=<span class="string">'retrieve'</span>)</span><br><span class="line">class HouseTypeViewSet(ModelViewSet):</span><br><span class="line">    queryset = HouseType.objects.all()</span><br><span class="line">    serializer_class = HouseTypeSerializer</span><br><span class="line">    # 拒绝分页</span><br><span class="line">    pagination_class = None</span><br></pre></td></tr></table></figure>
<p>2)  导入混入类做缓存</p>
<figure class="highlight diff"><figcaption><span>setting.py</span></figcaption><table><tr><td class="code"><pre><span class="line"># 缓存混入类</span><br><span class="line">REST_FRAMEWORK_EXTENSIONS = &#123;</span><br><span class="line">    'DEFAULT_CACHE_RESPONSE_TIMEOUT': 120,</span><br><span class="line">    'DEFAULT_USE_CACHE': 'default',</span><br><span class="line">    'DEFAULT_OBJECT_CACHE_KEY_FUNC': 'rest_framework_extensions.utils.default_object_cache_key_func',</span><br><span class="line">    'DEFAULT_LIST_CACHE_KEY_FUNC': 'rest_framework_extensions.utils.default_list_cache_key_func',</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight diff"><figcaption><span>app/views.py</span></figcaption><table><tr><td class="code"><pre><span class="line"># 导入混入类:</span><br><span class="line">from rest_framework_extensions.cache.mixins import CacheResponseMixin</span><br><span class="line"></span><br><span class="line"># 让视图类继承混入类:</span><br><span class="line">class EstatesView(CacheResponseMixin):   </span><br><span class="line"># 带Mixin的类是混入类,混入类必须写在前面</span><br></pre></td></tr></table></figure>


<h2 id="5-接口数据的筛选和排序"><a href="#5-接口数据的筛选和排序" class="headerlink" title="5. 接口数据的筛选和排序"></a>5. 接口数据的筛选和排序</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装django filter</span></span><br><span class="line">pip <span class="keyword">install</span> django-filter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件添加应用</span></span><br><span class="line"><span class="string">'django_filters'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入DjangoFilterBackend</span></span><br><span class="line"><span class="keyword">from</span> django_filters.rest_framework <span class="keyword">import</span> DjangoFilterBackend</span><br><span class="line"></span><br><span class="line"><span class="comment"># DjangoFilterBackend帮忙筛数据</span></span><br><span class="line">filter_backends = (DjangoFilterBackend, OrderingFilter)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--------------- 直接查询 ------------------</span></span><br><span class="line"><span class="comment"># 设置筛选条件</span></span><br><span class="line">filter_fields = (<span class="string">'district'</span>, )</span><br><span class="line"><span class="comment"># 设置排序字段</span></span><br><span class="line">ordering_fields = (<span class="string">'hot'</span>, <span class="string">'estateid'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--------- 自定义一个类来指定查询条件-----------</span></span><br><span class="line"><span class="comment"># ①: 自定义类:</span></span><br><span class="line"><span class="keyword">class</span> EstateFilterSet(django_filters.FilterSet):</span><br><span class="line">    minhot = django_filters.NumberFilter(field_name=<span class="string">'hot'</span>, lookup_expr=<span class="string">'gte'</span>)</span><br><span class="line">    maxhot = django_filters.NumberFilter(field_name=<span class="string">'hot'</span>, lookup_expr=<span class="string">'lte'</span>)</span><br><span class="line">    keyword = django_filters.CharFilter(method=<span class="string">'filter_by_keyword'</span>)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    <span class="keyword">def</span> filter_by_keyword(queryset, <span class="keyword">key</span>, <span class="keyword">value</span>):</span><br><span class="line">        queryset = queryset.filter(Q(name__contains=<span class="keyword">value</span>) | Q(intro__contains=<span class="keyword">value</span>))</span><br><span class="line">        <span class="keyword">return</span> queryset</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment"># ②: 导入定义好的类</span></span><br><span class="line"><span class="keyword">from</span> common.utils <span class="keyword">import</span> EstateFilterSet</span><br><span class="line"></span><br><span class="line"><span class="comment"># ③: 在视图类里面使用(注,使用时要放到filter_backends后面)</span></span><br><span class="line">filter_backends = (DjangoFilterBackend, OrderingFilter)</span><br><span class="line">filterset_class = EstateFilterSet</span><br></pre></td></tr></table></figure>



<h2 id="6-接口限流-限制接口的访问频率"><a href="#6-接口限流-限制接口的访问频率" class="headerlink" title="6. 接口限流:  限制接口的访问频率"></a>6. 接口限流:  限制接口的访问频率</h2><p>原理: 在缓存(Redis)内记录IP地址,并记录访问次数,当请求超过阈值则限制访问</p>
<figure class="highlight diff"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    # 限流配置</span><br><span class="line">    'DEFAULT_THROTTLE_CLASSES': (</span><br><span class="line">        'rest_framework.throttling.AnonRateThrottle',</span><br><span class="line">    ),</span><br><span class="line">    'DEFAULT_THROTTLE_RATES': &#123;</span><br><span class="line">        'anon': '5/min',</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若不想限流,可以在视图类里面加入以下代码:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">throttle_classes</span> = ()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>后端</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>常用指令集</title>
    <url>/2019/01/20/%E5%90%8E%E7%AB%AF/Linux%E5%92%8CGit%E5%91%BD%E4%BB%A4%E9%9B%86/</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><strong>对本地实施版本控制并同步到服务器:</strong></p>
<ol>
<li>git init   —&gt;   将普通文件夹变成版本仓库</li>
<li>git add .   —&gt;   将文件从工作区同步到暂存区</li>
<li>git commit -m ‘项目描述信息’   —&gt;   将文件提交到本地仓库</li>
<li>git status   —&gt;  查看当前的执行状态(经常用)</li>
<li>git log   —&gt;   查看版本</li>
<li>git reflog   —&gt;   </li>
<li>git reset –hard 版本号   —&gt;   去到指定版本</li>
<li>git tag v0.1 —&gt; 添加版本号0.1</li>
<li>git remote add origin <url>   —&gt;   绑定远端仓库</li>
<li>git remote -v   —&gt;   查看是否已经连接远端仓库</li>
<li>git push -u origin master   —&gt;   将本地代码推到服务器仓库(第一次绑定才需要加 -U 为了指定上行流,要把代码推到哪里去)</li>
<li>git pull</li>
<li>git pull –allow-unrelated-histories origin master   —&gt;   当远端和本地版本不同时,将远端的东西pull下来和本地合并</li>
<li>git reset –hard HEAD^   —&gt;   回到上一版本</li>
<li>git clone –depth=1 gitegitee.com:jackfrued/djangocase.git djangocse2    —&gt;   克隆djangocase,只克隆最新版本–depth=1, 重命名为djangocase2, </li>
<li>git remote remove origin ： 删除与远端仓库的关联</li>
<li>git revert 版本号    ： 可以修改版本信息</li>
<li>git diff</li>
<li>在空文件夹内加.gitkeep文件,则空文件夹在版本控制时不会被忽略</li>
</ol>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grep</span> -vE   ---&gt;   -v表示不搜什么,E表示正则表达式</span><br><span class="line">感叹号加历史记录的编号   -&gt;   将历史命令重新执行一遍</span><br><span class="line">!v   -&gt;   将历史记录中最近的以v开头的命令执行一遍</span><br><span class="line"><span class="keyword">history</span> -<span class="keyword">c</span>   -&gt;   将历史记录全部清除</span><br><span class="line">alias <span class="string">'ll=ls -l'</span>   -&gt;   命令别名</span><br><span class="line">unalias <span class="keyword">ll</span>   -&gt;   取消别名</span><br><span class="line">yum <span class="keyword">update</span>   -&gt;   更新库内能更新的包</span><br><span class="line">nohup <span class="keyword">make</span> &gt;&gt; ~/install.<span class="built_in">log</span> &amp;   -&gt;   将程序放到后台运行,并且不接受中断信号</span><br><span class="line">chmod <span class="keyword">u</span>+<span class="keyword">x</span>,g+<span class="keyword">x</span>,<span class="keyword">o</span>+<span class="keyword">x</span> test.<span class="keyword">py</span>  =  chmod <span class="number">755</span> test.<span class="keyword">py</span></span><br><span class="line">etc目录是专门放配置文件的</span><br><span class="line">在.<span class="keyword">py</span>文件内加入以下代码,写了文件名就能执行文件</span><br><span class="line">#!/usr/bin/<span class="keyword">python3</span> </span><br><span class="line"># -*- codin<span class="variable">g:</span> utf-<span class="number">8</span> -*-</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查看当前登录的用户信息</span><br><span class="line">who   看所有</span><br><span class="line"><span class="keyword">w</span>   能看到最详细的登录信息</span><br><span class="line">who <span class="keyword">am</span> i   看自己</span><br><span class="line">whoami   看自己用户名</span><br><span class="line"><span class="keyword">last</span>   查看最近登录的用户</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 关机系列</span><br><span class="line">shutdown   关机</span><br><span class="line">shutdown now   立即关机</span><br><span class="line">shutdown -r   重启</span><br><span class="line">shutdown -h   关机后关闭电源</span><br><span class="line">halt   关机关电源</span><br><span class="line">reboot   重启</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 其他</span><br><span class="line">logout   登出</span><br><span class="line"><span class="keyword">cal</span>   查看日历</span><br><span class="line">date   查看当前时间</span><br><span class="line">man   查看命令帮助手册</span><br><span class="line">su(switch user) 用户名   切换用户</span><br><span class="line"><span class="keyword">exit</span>   退出当前用户</span><br><span class="line">adduser / passwd / userdel   创建用户(-g指定分组) / 修改密码 / 删除用户</span><br><span class="line">date / <span class="keyword">cal</span>   查看时间</span><br><span class="line"><span class="keyword">write</span> / <span class="keyword">wall</span> / mesg   发消息</span><br><span class="line">clear   清屏</span><br><span class="line">man / info / --<span class="keyword">help</span>   参看帮助</span><br><span class="line"><span class="keyword">history</span>   历史命令</span><br><span class="line">    -<span class="keyword">c</span>   清除历史命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 文件相关命令</span><br><span class="line"><span class="number">1</span>. <span class="keyword">pwd</span></span><br><span class="line"><span class="number">2</span>. <span class="keyword">cd</span></span><br><span class="line"><span class="number">3</span>. <span class="keyword">ls</span></span><br><span class="line">    -<span class="keyword">l</span>   长格式查看</span><br><span class="line">    -<span class="keyword">a</span>   所有文件</span><br><span class="line">    -R   递归查看</span><br><span class="line">    -d   只看文件夹</span><br><span class="line"><span class="number">4</span>. <span class="keyword">cat</span> </span><br><span class="line">    -n   给文件添加行号查看</span><br><span class="line"><span class="number">5</span>. touch   创建空文件</span><br><span class="line"><span class="number">6</span>. <span class="built_in">mkdir</span>   创建文件夹</span><br><span class="line">    -<span class="keyword">p</span>   创建父文件夹</span><br><span class="line"><span class="number">7</span>. rm   删除</span><br><span class="line">    -<span class="keyword">f</span>   强制删除</span><br><span class="line">    -r   递归删除</span><br><span class="line"><span class="number">8</span>. rmdir   删除空文件夹</span><br><span class="line"><span class="number">9</span>. wget   通过网络获取文件</span><br><span class="line">    - O   下下来重命名</span><br><span class="line">    - 例 wget http<span class="variable">s:</span>//www.baidu.<span class="keyword">com</span></span><br><span class="line"><span class="number">10</span>. gzip / gunzip   压缩 / 解压缩</span><br><span class="line"><span class="number">11</span>. xz</span><br><span class="line">    -<span class="keyword">z</span> 压缩</span><br><span class="line">    -d 解压缩</span><br><span class="line"><span class="number">12</span>. tar </span><br><span class="line">    -xvf 解归档</span><br><span class="line">    -cvf 归档</span><br><span class="line"><span class="number">13</span>. <span class="keyword">sort</span> 排序</span><br><span class="line"><span class="number">14</span>. uniq 文件去重</span><br><span class="line"><span class="number">15</span>. more 分页查看文件</span><br><span class="line"><span class="number">16</span>. <span class="keyword">cp</span></span><br><span class="line"><span class="keyword">cp</span> 文件名 路径   拷贝文件到路径</span><br><span class="line"><span class="keyword">cp</span> 文件名 路径+文件名   拷贝文件到路径并重命名</span><br><span class="line"><span class="keyword">cp</span> -r 文件夹 路径   拷贝文件夹到路径</span><br><span class="line"><span class="number">17</span>. mv</span><br><span class="line">mv 文件名 路径   移动文件到路径</span><br><span class="line">mv 文件夹 路径   移动文件夹到路径</span><br><span class="line">mv 文件名 路径+文件名   移动文件到路径并重命名</span><br><span class="line">mv 文件名<span class="number">1</span> 文件名<span class="number">2</span>   重命名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| 管道:将多个进程连接起来,将上一个命令的输出作为下一个命令的输入</span><br><span class="line">&gt; 重定向</span><br><span class="line">&gt;&gt; 追加重定向</span><br><span class="line"><span class="number">2</span>&gt; 错误输出重定向</span><br><span class="line"><span class="number">2</span>&gt;&gt; 错误追加输出重定向</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="keyword">vim</span>编辑器的使用</span><br><span class="line">dd   删除一行</span><br><span class="line"><span class="number">100</span> dd   删除<span class="number">100</span>行</span><br><span class="line">:<span class="keyword">set</span> <span class="keyword">nu</span>    显示行号</span><br><span class="line">:<span class="keyword">set</span> nonu   不显示行号</span><br><span class="line">:<span class="keyword">set</span> <span class="keyword">ts</span>=<span class="number">4</span>   设置<span class="keyword">tabl</span>键为<span class="number">4</span>个空格</span><br><span class="line">uu   撤销</span><br><span class="line"></span><br><span class="line"><span class="keyword">vim</span>的三种模式:</span><br><span class="line">- 命令模式-按键代表命令   ---i或者<span class="keyword">a</span>---&gt;编辑模式</span><br><span class="line">                        ---:或者/--&gt;未行模式</span><br><span class="line">    ~ G - 光标移到文件末尾 / <span class="number">500</span>G - 光标移到第<span class="number">500</span>行 / gg-光标移到行首 / hjkL-左下右上（前面可以加数字）</span><br><span class="line">    ~ CtrL+<span class="keyword">y</span> / Ctrl+<span class="keyword">e</span>  - 移动一行</span><br><span class="line">    ~ CtrL+<span class="keyword">f</span> / Ctrl+<span class="keyword">b</span>  - 翻一页</span><br><span class="line">    ~ <span class="number">0</span> - 光标到行首 / $ - 光标到行尾 / <span class="keyword">w</span> - 光标移到下一个单词</span><br><span class="line">    ~ dd - 删除光标所在行 / <span class="number">100</span>dd - 从光标所在行向下删除<span class="number">100</span>行</span><br><span class="line">    ~ yy - 复制光标所在行 / <span class="number">10</span>yy - 从光标所在行开始复制<span class="number">10</span>行</span><br><span class="line">    ~ <span class="keyword">p</span> - 粘贴 / <span class="number">5</span><span class="keyword">p</span>-粘贴<span class="number">5</span>遍</span><br><span class="line">    ~ <span class="keyword">u</span> - 撤销 / ctrl+r - 恢复</span><br><span class="line">- 编辑模式-键入内容   ---Esc---&gt;命令模式</span><br><span class="line">- 末行模式-搜索/配置/执行系统命令   ---Enter---&gt;命令模式</span><br><span class="line">    ~ <span class="keyword">set</span> <span class="keyword">nu</span>-显示行号-<span class="keyword">set</span> nonu</span><br><span class="line">    ~ <span class="keyword">syntax</span> <span class="keyword">on</span>-显示高亮语法-<span class="keyword">syntax</span> off</span><br><span class="line">    ~ <span class="keyword">set</span> <span class="keyword">ts</span>=<span class="number">4</span>-修改制表键的空格数</span><br><span class="line">    ~ <span class="keyword">set</span> ruler-显示光标所在的位置-<span class="keyword">set</span> noruler</span><br><span class="line"></span><br><span class="line"><span class="keyword">vim</span>配置</span><br><span class="line">创建文件 .vimrc</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">nu</span>   设位置行号</span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span>   语法高亮</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">ts</span>=<span class="number">4</span>   设置制表键为<span class="number">4</span>个空格</span><br><span class="line"><span class="keyword">set</span> expandtab   将制表键转换成空格</span><br><span class="line"><span class="keyword">set</span> autoindent   自动缩进</span><br><span class="line"><span class="keyword">set</span> ruler   显示光标</span><br><span class="line"><span class="keyword">set</span> nohls   设置高亮</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 题外话</span><br><span class="line">配置<span class="keyword">python3</span>环境变量</span><br><span class="line"><span class="number">1</span>. 注册PATH环境变量</span><br><span class="line"><span class="keyword">cd</span>~</span><br><span class="line"><span class="keyword">vim</span>.bash_profile</span><br><span class="line">PATH=...：/usr/Local/python37/bin</span><br><span class="line"><span class="number">2</span>. 激活环境变量</span><br><span class="line"><span class="keyword">source</span>.bash_profile</span><br><span class="line"><span class="number">3</span>. 测试安装是否成功</span><br><span class="line"><span class="keyword">python3</span>--<span class="keyword">version</span></span><br><span class="line"></span><br><span class="line">## 命令别名</span><br><span class="line">alias <span class="keyword">ll</span>=<span class="string">'ls -l'</span>   将<span class="keyword">ls</span> -<span class="keyword">l</span> 命名为<span class="keyword">ll</span></span><br><span class="line">unalias <span class="keyword">ll</span>   取消别名</span><br><span class="line"></span><br><span class="line"><span class="keyword">vim</span>宏操作</span><br><span class="line">~ 录制宏: <span class="keyword">qa</span>（<span class="keyword">a</span>是寄存器的名字）- 在录制宏是左下角会显示 recoding</span><br><span class="line">~ 结束录制: q</span><br><span class="line">~ 播放宏: @a（<span class="keyword">a</span>是寄存器的名字）- 前面可以加数值,表示播放几遍</span><br></pre></td></tr></table></figure>



<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">select</span> user,host from mysql.user;   ---&gt;</span>   查询所有的用户和登录主机</span><br><span class="line"><span class="function"><span class="title">select</span> current_user();   ---&gt;</span>   查询当前用户</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">mysql</span> -u root -p   ---&gt;</span>   登录mysql数据库</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">redis</span>-server --requirepass 119148 --port 6379 &gt;&gt; redis.<span class="built_in">log</span> &amp;   ---&gt;</span>   启动redis服务器,设置连接密码,指定redis端口,将日志文件写到redis.<span class="built_in">log</span>文件,并且后台运行</span><br><span class="line"><span class="function"><span class="title">redis</span>-cli   ---&gt;</span>   登录redis</span><br><span class="line"><span class="function"><span class="title">auth</span>:   ---&gt;</span>   输入密码</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>git</tag>
        <tag>配置</tag>
        <tag>技术文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用指令</title>
    <url>/2019/12/22/%E5%90%8E%E7%AB%AF/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>Linux常用指令集</p>
<a id="more"></a>

<h1 id="1-cd指令-进入文件夹"><a href="#1-cd指令-进入文件夹" class="headerlink" title="1. cd指令  -  进入文件夹"></a>1. cd指令  -  进入文件夹</h1><p><strong>cd</strong>   ——&gt;文件夹路径（路径可以是绝对地址也可以是相对地址）-进入到指定路径对应的文件夹<br><strong>cd  ..</strong>  ——&gt;返回上层目录<br><strong>cd  /</strong>   ——&gt;进入系统根目录<br><strong>cd  ~</strong>  ——&gt;进入电脑根目录</p>
<h1 id="2-ls指令-显示当前目录中的内容"><a href="#2-ls指令-显示当前目录中的内容" class="headerlink" title="2. ls指令  -  显示当前目录中的内容"></a>2. ls指令  -  显示当前目录中的内容</h1><p><strong>ls</strong>   ——&gt;直接显示当前文件夹中的内容的名字（隐藏文件和文件夹`        看不到）<br><strong>ls  -l</strong>   ——&gt;直接显示当前文件夹中的内容的名字（隐藏文件和文件夹看不到）<br><strong>ls  -lh</strong>   ——&gt;显示当前文件夹中的内容和内容的基本信息（隐藏文件和文件夹看不到）<br><strong>ls  -a</strong>   ——&gt;显示当前文件夹中所有的内容（包括隐藏文件）<br><strong>ls  -R</strong>   ——&gt;递归显示当前目录以及当前目录下所有的子目录中的内容<br><strong>ls  -r</strong>   ——&gt;内容倒序显示<br><strong>ls  -S/-t</strong>  ——&gt;显示文件夹中的内容，并且内容按大小/时间从大到小排序<br><strong>ls  -Sr</strong>   ——&gt;按文件大小从小到大排序<br><strong>ls  -Srlh</strong>   ——&gt;按文件大小从小到大排序，并且显示内容的基本信息</p>
<h1 id="3-pwd指令"><a href="#3-pwd指令" class="headerlink" title="3. pwd指令"></a>3. pwd指令</h1><p><strong>pwd</strong>   ——&gt;查看当前目录的绝对路径</p>
<h1 id="4-文件操作"><a href="#4-文件操作" class="headerlink" title="4.文件操作"></a>4.文件操作</h1><h2 id="1-touch指令-新建文件"><a href="#1-touch指令-新建文件" class="headerlink" title="1)touch指令  新建文件"></a>1)touch指令  新建文件</h2><p><strong>touch 文件路径文件名</strong>——&gt;在指定位置创建指定文件</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">touch <span class="keyword">a</span>.txt-在当前目录下新建一个文件<span class="keyword">a</span>.txt</span><br><span class="line">touch ../<span class="keyword">a</span>.txt   <span class="comment">------&gt;在当前目录的上层目录新建一个文件a.txt</span></span><br><span class="line">touch /home/<span class="keyword">a</span>/<span class="keyword">a</span>.txt   <span class="comment">------&gt;在根目录下home目录中的a目录里面创建一个文件a.txtl</span></span><br></pre></td></tr></table></figure>
<h2 id="2-cat指令-查看文件内容-读文件"><a href="#2-cat指令-查看文件内容-读文件" class="headerlink" title="2)cat指令  查看文件内容(读文件)"></a>2)cat指令  查看文件内容(读文件)</h2><p><strong>cat 文件路径文件名</strong>   ——&gt;读取指定路径对应的文件的内容</p>
<h2 id="3-vim指令"><a href="#3-vim指令" class="headerlink" title="3)vim指令"></a>3)vim指令</h2><p><strong>vim 文件路径文件名</strong>   ——&gt;使用vim打开文件</p>
<h1 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5.文件操作"></a>5.文件操作</h1><p><strong>mkdir  新文件夹路径文件夹名</strong>   ——&gt;在指定位置创建文件夹,若没有会报错<br><strong>mkdir  -p  新文件夹路径文件夹名</strong>   ——&gt;在指定路径创建指定文件夹,若没有就创建<br><strong>mkdir -p  a/{b,c,…}/{d,e,f,g,…}</strong>   ——&gt;在当前位置创建a,在a内创建多个文件夹,在多个文件夹内再创建多个相同的文件夹</p>
<h1 id="6-删除文件和文件夹"><a href="#6-删除文件和文件夹" class="headerlink" title="6.删除文件和文件夹"></a>6.删除文件和文件夹</h1><h2 id="1-rm指令-删除文件和文件夹"><a href="#1-rm指令-删除文件和文件夹" class="headerlink" title="1)rm指令  删除文件和文件夹"></a>1)rm指令  删除文件和文件夹</h2><p><strong>rm 文件路径文件名</strong>   ——&gt;删除指定文件（删除的时候会循环是否确定删除，y-同意，n-不同意）<br><strong>rm  -f  文件路径文件名</strong>   ——&gt;删除指定文件（删除的时候不询问）<br><strong>rm  -r  文件夹路径文件夹名</strong>   ——&gt;删除指定文件夹</p>
<h2 id="2-rmdir指令-删除空文件夹"><a href="#2-rmdir指令-删除空文件夹" class="headerlink" title="2)rmdir指令  删除空文件夹"></a>2)rmdir指令  删除空文件夹</h2><p><strong>rmdir 文件夹路径</strong>——&gt;删除空文件夹</p>
<h1 id="7拷贝和移动"><a href="#7拷贝和移动" class="headerlink" title="7拷贝和移动"></a>7拷贝和移动</h1><h2 id="1-拷贝"><a href="#1-拷贝" class="headerlink" title="1)拷贝"></a>1)拷贝</h2><p><strong>cp 文件路径1 文件路径2</strong>——&gt;将文件1中的内容复制粘贴到文件2（如果文件2不存，会自动创建；如果存在会询问是否覆盖）<br><strong>cp 文件路径 文件夹路径</strong>——&gt;将指定文件复制粘贴到指定文件夹中<br><strong>cp -r 文件夹路径1 文件夹路径2</strong>——&gt;将文件夹1复制粘贴到文件夹2中</p>
<h2 id="2-移动"><a href="#2-移动" class="headerlink" title="2)移动"></a>2)移动</h2><p><strong>mv 文件路径1 文件路径2</strong>   ——&gt;将文件1移动到文件2所在的位置<br><strong>mv 文件名1 文件名2 **  ——&gt;将文件1重命名为文件2(若两个文件同时存在同一文件夹中,则重命名后文件2会被删除,文件1会被重命名)<br>**mv 文件路径 文件夹路径</strong>   ——&gt;将文件直接移动到指定文件夹中<br>*<em>mv 文件夹路径1 文件夹路径2 *</em>  ——&gt;将文件夹1移动到文件夹2中</p>
<h1 id="8获取指令的历史记录"><a href="#8获取指令的历史记录" class="headerlink" title="8获取指令的历史记录"></a>8获取指令的历史记录</h1><p><strong>history</strong>   ——&gt;显示当前系统已经执行过的所有指令</p>
<blockquote>
<p>如果想要显示历史记录的时候显示指令执行的时间需要修改~/.bashrc文件：<br>export HISTTIMEFORMAT=”[%y-%m-%d_%T%M%S]”<br>修改完成后需要通过指令：source ~/.bashrc去执行这个配置文件，最后历史记录的时间才会生效</p>
</blockquote>
<h1 id="9创建链接"><a href="#9创建链接" class="headerlink" title="9创建链接"></a>9创建链接</h1><h2 id="1-创建软链接"><a href="#1-创建软链接" class="headerlink" title="1)创建软链接"></a>1)创建软链接</h2><p><strong>ln -s 源文件路径  入口文件位置</strong>    ——&gt; 给源文件在指定位置创建一个软链接(软连接本质就是用来保存源文件绝对地址的一个文件)</p>
<blockquote>
<p>注:源文件路径必须是绝对路径,如果删除或者移动源文件，软连接会直接无效</p>
</blockquote>
<h2 id="2-创建硬链接"><a href="#2-创建硬链接" class="headerlink" title="2)创建硬链接"></a>2)创建硬链接</h2><p><strong>ln 源文件路径  硬连接文件地址</strong>   —–&gt;给源文件在指定位置创建一个硬链接硬链接的本质就是源文件内容的另外一个引用(相当于文件的另一个文件名)，所以删除或者移动源文件硬链接仍然有效，只是删除硬链接会变成普通文件</p>
<h1 id="10进程相关指令"><a href="#10进程相关指令" class="headerlink" title="10进程相关指令"></a>10进程相关指令</h1><h2 id="1-ps指令"><a href="#1-ps指令" class="headerlink" title="1)ps指令"></a>1)ps指令</h2><p><strong>ps</strong>   ——&gt;查看当前进程状态<br><strong>ps -aux</strong>   ——&gt;查看当前进程所有状态<br><strong>ps grep  进程名/id</strong>   ——&gt;根据进程名/进程ID查看指定进程</p>
<h2 id="2-top指令"><a href="#2-top指令" class="headerlink" title="2)top指令"></a>2)top指令</h2><p><strong>top</strong>  ——&gt;实时查看当前所有的进程信息和系统信息<br><strong>top -p PID1,PID2,…</strong>   ——&gt;实时监测指定的进程</p>
<h2 id="3-free指令"><a href="#3-free指令" class="headerlink" title="3)free指令"></a>3)free指令</h2><p><strong>free</strong>   ——&gt;显示当前系统的内存信息，显示的时候以kb为单位<br><strong>free  -单位</strong>   ——&gt;显示当前系统的内存信息，以指定单位来显示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span> -m    - 显示当前系统的内存信息，以Mb为单位</span><br></pre></td></tr></table></figure>

<h2 id="4-kill指令"><a href="#4-kill指令" class="headerlink" title="4)kill指令"></a>4)kill指令</h2><p><strong>kill 进程ID</strong>   ——&gt;杀掉指定ID对应的进程<br>kill -1/-9/-15进程ID   ——&gt;以指定的方式杀掉进程(-1表示不间断重启；-9表示强制杀死进程；-15表示正常结束进程)<br><strong>pkill  进程名</strong>   ——&gt;杀死指定进程名对应的进程（中间可以加-1/-9/-15）<br><strong>killall  进程名</strong>   ——&gt;杀死和进程名相关的所有进程</p>
<h2 id="5-uptime指令"><a href="#5-uptime指令" class="headerlink" title="5)uptime指令"></a>5)uptime指令</h2><p><strong>uptime</strong>   ——&gt;查看系统的基本信息(启动时间等)</p>
<h1 id="11用户管理"><a href="#11用户管理" class="headerlink" title="11用户管理"></a>11用户管理</h1><p>一个Linux操作系统可以有多个用户（user），也可以有多个用户组（group）；<br><strong>users</strong>   ——&gt;查看当前用户<br><strong>groups</strong>   ——&gt;查看当前分组<br><strong>groupadd  分组名</strong>   ——&gt;创建分组(管理员才能创建;可以通过查看/etc/group文件来查看当前系统所有的分组)<br><strong>useradd  用户名</strong>    ——&gt;创建指定用户(1.用户创建成功后系统会自动在/home目录下创建一个和用户名同名的文件夹;2.会自动创建和用户名同名的分组,并且将当前用户添加到这个分组中)<br><strong>useradd  -G  分组1,分组2…   用户名</strong>  ——&gt;创建指定用户,并且将用户添加到指定分组<br><strong>usermod  -G  分组1,分组2   用户名</strong>——&gt;修改用户分组<br><strong>password  用户名</strong>   ——&gt;修改用户密码(需要root权限)<br><strong>su  用户名</strong>   ——&gt;切换账号(root登录的时候切换不需要密码)<br><strong>exit</strong>   ——&gt;退出当前账号</p>
<p>sudo  -在命令前sudo是以管理员身份执行指令<br>注意：不是所有的用户都可以通过sudo来以管理员身份执行指令，如果想要能够使用sudo必须添加配置<br>  ①.  ubuntu：将需要有管理员身份的账号添加到sudo分组中<br>  ②.  redhat和contos：在/etc/sudoers配置文件中添加代码：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Allow root to run any commands anywhere</span></span><br><span class="line"><span class="attribute">root</span> <span class="literal">ALL</span>=（<span class="literal">ALL</span>）<span class="literal">ALL</span>#（默认有的）</span><br><span class="line"><span class="attribute">xiaoming</span> <span class="literal">ALL</span>=（<span class="literal">ALL</span>）<span class="literal">ALL</span>#（自己添加的，xiaoming是用户名）</span><br></pre></td></tr></table></figure>

<h1 id="12文件权限"><a href="#12文件权限" class="headerlink" title="12文件权限"></a>12文件权限</h1><p>默认情况下文件和文件夹的权限:文件所有者有读写权限,同组用户和其他用户都是只读权限.</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>所有者权限</th>
<th>同组用户权限</th>
<th>其他用户权限</th>
</tr>
</thead>
<tbody><tr>
<td>d（目录）</td>
<td>rwx</td>
<td>r–</td>
<td>—</td>
</tr>
<tr>
<td>-（文件）</td>
<td>rwx</td>
<td>r–</td>
<td>—</td>
</tr>
<tr>
<td>l（连接）</td>
<td>rwx</td>
<td>r–</td>
<td>—</td>
</tr>
</tbody></table>
<p><strong>chmod  权限值  文件路径</strong>   ——&gt;将指定文件的权限修改成指定值<br><strong>chmod  [a,u,g,o]/[+-]/[r,w,x] 文件地址</strong>   ——&gt;给指定文件对应指定用户添加或者删除指定权限(a-所有用户,u-文件所有者,g-同组用户,o-其他用户;+表示添加权限,表示删除权限;r-表示读权限,w表示写权限,x表示执行权限)</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">chmod</span> a-<span class="keyword">x</span> 文件地址  <span class="comment">#删除所有用户的执行权限</span></span><br><span class="line"><span class="keyword">chmod</span> u+w 文件地址  <span class="comment">#给文件所有者添加写的权限</span></span><br></pre></td></tr></table></figure>

<h1 id="13日志管理"><a href="#13日志管理" class="headerlink" title="13日志管理"></a>13日志管理</h1><h2 id="1-查看文件"><a href="#1-查看文件" class="headerlink" title="1)查看文件"></a>1)查看文件</h2><p><strong>cat 文件</strong>   ——&gt;直接查看文件所有内容(查看文件内容的时候可以加参数-n，让内容在显示的时候显示行号)</p>
<p><strong>head  -N 文件地址文件名</strong>   ——&gt;显示指定文件前N行内容<br><strong>tail -N 文件地址文件名</strong>   ——&gt;显示指定文件后N行内容</p>
<p><strong>less  文件</strong>   ——&gt;按页显示文件内容(通过快捷键控制内容显示过程;文件内容不会打印到shel/终端里)<br><strong>less -N 文件</strong>   ——&gt;按页显示文件内容,每次翻页的时候翻N行<br><strong>more 文件</strong>   ——&gt;按页显示文件内容(通过快捷键控制内容显示过程;文件内容会打印到shell/终端里)<br><strong>more -N 文件</strong>   ——&gt;按页显示文件内容,每次翻页的时候翻N行</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">快捷键:</span><br><span class="line">按<span class="keyword">j向下一行</span></span><br><span class="line"><span class="keyword">按k向上一行</span></span><br><span class="line"><span class="keyword">按f向下翻一页</span></span><br><span class="line"><span class="keyword">按b向上翻一页</span></span><br><span class="line"><span class="keyword">按g到全文开头</span></span><br><span class="line"><span class="keyword">按G到全文结尾</span></span><br><span class="line"><span class="keyword">按Q退出</span></span><br></pre></td></tr></table></figure>

<h2 id="2-文件处理"><a href="#2-文件处理" class="headerlink" title="2)文件处理"></a>2)文件处理</h2><p>凡是有的打印结果的指令,我们都可以通过相关指令对应结果进行处理<br>如果需要对某一个指令的结果使用另外的指令进行二次处理的时候，就需要用到<strong>管道 |</strong></p>
<p><strong>sort-排序</strong><br>sort   ——&gt;从小到大排序(将一行内容作为一个字符串,按字符串大小对应内容进行排序,默认不区分大小写)</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">cat <span class="keyword">a</span>.txt | <span class="built_in">sort</span>   <span class="comment">------&gt;对a.txt的文件内容从小到大排序显示</span></span><br><span class="line"></span><br><span class="line">参数:</span><br><span class="line">-r  <span class="comment">------&gt; 逆序</span></span><br><span class="line">-nk <span class="number">1</span>  <span class="comment">------&gt;数值大小排序</span></span><br><span class="line">-nk <span class="number">2</span>  <span class="comment">------&gt;字符大小排序(默认)</span></span><br><span class="line">cat <span class="keyword">a</span>.txt|<span class="built_in">sort</span> -nk <span class="number">1</span>  <span class="comment">------&gt;对a.txt的文件内容按数字大小从小到大排序</span></span><br><span class="line">cat <span class="keyword">a</span>.txt|<span class="built_in">sort</span> -rnk <span class="number">1</span>  <span class="comment">------&gt;对a.txt的文件内容按数字大小从大到小排序</span></span><br><span class="line">cat <span class="keyword">a</span>.txt|<span class="built_in">sort</span> -nk <span class="number">2</span>  <span class="comment">------&gt;对a.txt的文件内容按字符大小从小到大排序(默)</span></span><br><span class="line">cat <span class="keyword">a</span>.txt|<span class="built_in">sort</span> -rnk <span class="number">2</span>  <span class="comment">------&gt;对a.txt的文件内容按字符大小从大到小排序</span></span><br></pre></td></tr></table></figure>

<p><strong>uniq-去重</strong><br>uniq   ——&gt;只能将紧挨着的相同行去掉重复的(如果需要去掉所有重复的行,先排序将相同的行放到一起)</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">cat <span class="keyword">a</span>.txt | unkq   <span class="comment">------&gt;去掉a.txt文件内容中相邻重复的行</span></span><br><span class="line">cat <span class="keyword">a</span>.txt | sortluniq   <span class="comment">------&gt;去掉a.txt文件内容中所有重复的行</span></span><br><span class="line">-c   <span class="comment">------&gt;重复欠数</span></span><br></pre></td></tr></table></figure>

<p><strong>awk-获取列</strong><br>awk ‘{print $N}’   ——&gt;获取内容中第N列的数据</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">historylawk '&#123;print $<span class="number">2</span>&#125;'------&gt;获取历史记录第<span class="number">2</span>列的内容</span><br><span class="line">historylawk'&#123;print $<span class="number">2</span>,$<span class="number">3</span>&#125;'------&gt;获取历史记录第<span class="number">2</span>列和第<span class="number">3</span>列的内容</span><br></pre></td></tr></table></figure>

<blockquote>
<p>练习:<br>history | awk ‘{print $4}’|sort|uniq -c|sort -rnk 1|head -5<br>显示最常用的指令和使用次数</p>
</blockquote>
<h2 id="3-输出重定向"><a href="#3-输出重定向" class="headerlink" title="3)输出重定向"></a>3)输出重定向</h2><p><strong>执行有打印结果的指令  &gt;  文件地址</strong>   ——&gt;将指定指令执行的结果保存到指定文件中(先清除原文件内容再添加)<br><strong>执行有打印结果的指令  &gt;&gt;  文件地址</strong>   ——&gt;将指定指令执行的结果保存到指定文件中(直接将结果追加到原文件中)</p>
<blockquote>
<p>history &gt; a.txt   ——&gt;将当前历史记录直接保存到a.txt文件中</p>
<p>将最常用的3个指令及其使用次数保存到a.txt文件中<br>history l awk’{print $4}’lsort luniq-c I sort-rnk 1 I head-n3&gt;a.txt</p>
</blockquote>
<h2 id="4-统计"><a href="#4-统计" class="headerlink" title="4)统计"></a>4)统计</h2><p>wc   -c/-w/-l  文件地址   ——&gt;统计指定文件中字符/单词/行的数量</p>
<h2 id="5-查找"><a href="#5-查找" class="headerlink" title="5)查找"></a>5)查找</h2><ul>
<li><strong>查找文件内容  grep</strong></li>
</ul>
<p>①:  <strong>grep  内容  文件地址文件名</strong>   ——&gt;在指定文件中查找指定内容(返回文件中所有包含指定内容的行)</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">grep you <span class="keyword">a</span>.txt  <span class="comment">------&gt;获取a.txt中包含you的所有的行</span></span><br><span class="line"></span><br><span class="line">grep的参数:</span><br><span class="line">-n  <span class="comment">------&gt;显示结果的时候显示行号</span></span><br><span class="line">-i  <span class="comment">------&gt;查找内容的时候忽略大小写</span></span><br><span class="line">-E  <span class="comment">------&gt;按正则表达式进行匹配</span></span><br><span class="line">		 使用方法: grep -E <span class="string">'正则表达式'</span> 文件</span><br><span class="line">注意:Linux操作系统中正则表达式不支持:\d,\D,\w,\w,\s,\S,\b,\B;其他语法都支持</span><br><span class="line">-v  <span class="comment">------&gt;忽略字段</span></span><br><span class="line">         grep you <span class="keyword">a</span>.txt-v<span class="comment">------&gt;获取a.txt中不包含you的所有的行</span></span><br></pre></td></tr></table></figure>

<p>②:  <strong>执行有打印结果的指令  |</strong><br>  *<em>grep 内容 *</em>  ——&gt;在指令执行结果中查找指定内容</p>
<p>③:  <strong>grep  -r  内容  文件夹地址</strong>   ——&gt;在指定文件夹中所有的文件内容中查找指定内容</p>
<ul>
<li><strong>查找文件名   find</strong></li>
</ul>
<p>①:  <strong>find  文件夹路径  -name  文件名</strong>   ——&gt;在指定文件夹下按文件名找指定文件</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">找指定文件名</span><br><span class="line"><span class="builtin-name">find</span> dirl -name <span class="string">'test1.py'</span>  #在文件夹dir1找名字是test1.py的文件</span><br><span class="line"><span class="builtin-name">find</span> dirl -name <span class="string">'*.txt'</span>  #在文件夹dir1找后缀是txt的所有文件</span><br><span class="line"><span class="builtin-name">find</span> dirl -name <span class="string">' test*. txt'</span></span><br><span class="line"><span class="builtin-name">find</span> dirl -name <span class="string">' test*'</span></span><br><span class="line"><span class="builtin-name">find</span> dirl -name <span class="string">'*c. txt'</span></span><br></pre></td></tr></table></figure>

<p>②:  <strong>find  文件夹路径  -size  +/-文件大小</strong>   ——&gt;在指定文件夹下找文件大小满足条件的所有的文件</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span> dirl -<span class="built_in">size</span> +<span class="number">4</span>k------&gt;查找在文件夹dir1中所有大于<span class="number">4</span>k的文件</span><br><span class="line"><span class="built_in">find</span> dirl -<span class="built_in">size</span> -<span class="number">4</span>k------&gt;查找在文件夹dir1中所有小于<span class="number">4</span>k的文件</span><br><span class="line"><span class="built_in">find</span> dirl -<span class="built_in">size</span> +<span class="number">5</span>k -<span class="built_in">size</span> -<span class="number">10</span>k ------&gt;查找在文件夹dir1中所有大于<span class="number">5</span>k并且小于<span class="number">10</span>k的文件(文件大小如果是小数,算</span><br><span class="line">的时候向上取整)</span><br><span class="line"><span class="built_in">find</span> dirl -<span class="built_in">size</span> +<span class="number">4</span>k -<span class="built_in">name</span> <span class="string">'*.txt'</span>------&gt;查找在文件夹dir1中所有大于<span class="number">4</span>k的txt文件</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>查指令</strong></li>
</ul>
<p><strong>which 指令名</strong>    ——&gt;精确查找当前指令对应的文件的路径<br><strong>whereis  指令名</strong>   ——&gt;查找和指定指令相关的所有的文件的路径<br><strong>man  指令名</strong>   ——&gt;获取指定指定的使用手册<br><strong>指令名  –help</strong>   ——&gt;获取指定指令的帮助文档</p>
<h1 id="14网络管理"><a href="#14网络管理" class="headerlink" title="14网络管理"></a>14网络管理</h1><p><strong>ifconfig</strong>   ——&gt;查看网卡状态<br><strong>netstat  -natp</strong>   ——&gt;查看网络连接状态<br><strong>netstat  -natp | grep</strong>  端口号   ——&gt;查看指定端口的网络连接状态</p>
<p><strong>ping ip地址</strong>   ——&gt;给指定地址的服务器发送数据(主要用来检测当前网络通不通)<br><strong>ping  -i  时间(秒)  IP地址</strong>   ——&gt;每隔指定时间ping一次（时间可以是小数）<br><strong>ping  -c  次数  IP地址</strong>   ——&gt;ping指定次数(不限制次数的时候会不断的ping)</p>
<p><strong>wget 地址</strong>——&gt;下载</p>
<h1 id="15压缩和归档"><a href="#15压缩和归档" class="headerlink" title="15压缩和归档"></a>15压缩和归档</h1><p>压缩可以让文件变小,一般在需要传输前都会先对文件进行压缩.注意,压缩指令只针对文件有效,并且一次只能压缩一个文件.<br>归档可以将一个文件夹变成一个文件(tar文件)</p>
<h2 id="1-归档和解归档"><a href="#1-归档和解归档" class="headerlink" title="1)归档和解归档"></a>1)归档和解归档</h2><p><strong>tar  -cvf  归档后文件存放的地址(归档后的文件名)  需要归档的文件</strong>   ——&gt;将文件进行归档操作(既可以对文件进行归档也可以对文件夹归档)<br><strong>tar -xvf  归档文件地址</strong>   ——&gt;将指定的归档文件解归档</p>
<h2 id="2-压缩和解压缩"><a href="#2-压缩和解压缩" class="headerlink" title="2)压缩和解压缩"></a>2)压缩和解压缩</h2><p><strong>gzip  文件地址   *<em>——&gt;压缩指定文件(压缩后会生成一个gz文件,并且会删除原文件)<br>*</em>gzip  -c  需要压缩的文件地址文件名  &gt;  压缩文件地址</strong>   ——&gt;将指定文件压缩到指定位置,并且保留原文件<br><strong>gzip  -d  压缩文件地址</strong>   ——&gt;解压指定文件(解压完成后会删除原压缩文件)<br><strong>gzip  -l   压缩文件地址</strong>   ——&gt;列出压缩文件中的内容</p>
<p><strong>xz 文件地址</strong>   ——&gt;压缩指定文件(压缩文件后缀是xz)<br><strong>xz  -d  压缩文件地址</strong>   ——&gt;解压指定文件</p>
<p><strong>gunzip  压缩文件地址</strong>    ——&gt;解压指定文件(解压完成后会删除原压缩文件)</p>
<h1 id="16包管理工具-软件安装"><a href="#16包管理工具-软件安装" class="headerlink" title="16包管理工具(软件安装)"></a>16包管理工具(软件安装)</h1><p>包管理工具: yum</p>
<ul>
<li>yum search: 搜索软件包,例如yum search nginx.</li>
<li>yun list installed:列出已经安装的软件包,例如yum list installed I grep z1ib.</li>
<li>yum instal1:安装软件包,例如yum insta11 nginx.</li>
<li>yum remove:删除软件包,例如yum remove nginx.</li>
<li>yum update:更新软件包,例如yum update可以更新所有软件包,而yum update tar只会更新tar.</li>
<li>yum check-update:检查有哪些可以更新的软件包.</li>
<li>yum info:显示软件包的相关信息,例如yum info nginx.</li>
</ul>
<p>源代码构建安装软件:</p>
<ol>
<li>wget  安装包的路径        -下载安装包</li>
<li>gunzip/tar  压缩包         - 解压、解归档</li>
<li>(设置安装路径)</li>
<li>cd 安装包目录 执行: make &amp;&amp; make install       -编译安装包程序</li>
<li>给可执行文件添加软连接到usr/bin目录下            -添加快捷方式</li>
</ol>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="meta">#源代码构建python3.x</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># yum install gcc     (安装编译环境)</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz    (下载安装包)</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># gunzip Python-3.6.5.tgz     (解压)</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># tar -xvf Python-3.6.5.tar    (解归档)</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># cd Python-3.6.5            (进入安装包)</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># ./configure --prefix=/usr/local/python36 --enable-optimizations   (设置安装路径)</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel    (安装相关依赖库)</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># make &amp;&amp; make install       (编译执行安装文件)</span></span><br><span class="line">...</span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># ln -s /usr/local/python36/bin/python3.6 /usr/bin/python3      (给python指令文件创建快捷方式python3)</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># python3 --version</span></span><br><span class="line">Python <span class="number">3.6</span><span class="number">.5</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># python3 -m pip install -U pip     (安装pip)</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># ln -s /usr/local/python36/bin/pip /usr/bin/pip3      (给pip指令创建快捷方式pip3)</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># pip3 --version</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux定时任务</title>
    <url>/2019/12/20/%E5%90%8E%E7%AB%AF/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>通过制定 <code>crontab -e</code> 编辑和开启定时任务</p>
<a id="more"></a>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个完整的定时任务，需要确定时间和任务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.时间</span></span><br><span class="line"> .---------------- minute (0 - 59)   # 分</span><br><span class="line"> |  .------------- hour (0 - 23)     # 时</span><br><span class="line"> |  |  .---------- day of month (1 - 31)  # 日</span><br><span class="line"> |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...  # 月</span><br><span class="line"> |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line"> |  |  |  |  |</span><br><span class="line"> *  *  *  *  * user-name  command to be executed</span><br><span class="line"></span><br><span class="line"> * * * * *   		- 每分钟执行一次任务(每隔一分钟)</span><br><span class="line"> */1 * * * *        - 每分钟执行一次任务(每隔一分钟)</span><br><span class="line"> */2 * * * *        - 每2分钟执行一次任务(每隔2分钟)</span><br><span class="line"> * */1 * * *        - 每隔1小时</span><br><span class="line"> * * */1 * *        - 每隔1天</span><br><span class="line"> * * * */2 *        - 每隔两个月</span><br><span class="line"> * * * *  fri       - 每周五执行任务</span><br><span class="line"></span><br><span class="line"> 30 * * * *         - 时间点到30分的时候做</span><br><span class="line"> 0  * * * *         - 时间点到整点的时候执行任务</span><br><span class="line"> 30 2 * * *         - 时间到 02:30 的时候执行任务</span><br><span class="line"> 0  12 28 * *       - 每月28号12:00执行任务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.任务</span></span><br><span class="line">写Linux指令, 指令如果有结果，结果看不到</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用指令</title>
    <url>/2019/12/22/%E5%90%8E%E7%AB%AF/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>git的基本常用指令集</p>
<a id="more"></a>
<h1 id="1-基本指令"><a href="#1-基本指令" class="headerlink" title="1.基本指令"></a>1.基本指令</h1><p>git init        ——&gt;新建git仓库<br>git add 文件/文件夹       ——&gt;  将文件添加到缓存区中<br>git add -A   ——&gt;  添加所有内容到缓存区中</p>
<p>git status      ——&gt;    查看git状态<br>git commit -m  ‘提交信息’       ——&gt;  将缓存区中的内容全部提交到git本地仓库中<br>git log        ——&gt; 查看提交日志 </p>
<p>git reset  – hard   HEAD       ——&gt;   让工作目录中的内容和仓库中的内容保持一致<br>git reset  –hard HEAD^  ——&gt;  回到上一个版本<br>git  reset  – hard 版本号  ——&gt;  回到指定的版本 </p>
<p>git checkout  文件名   ——&gt;  从暂存区中恢复工作目录中的内容(让工作区中的指定文件，回到上次提交的时候的状态) </p>
<p>git clone <url>    ——&gt;  将服务器上的项目(仓库)克隆 (使用https地址需要输入密码，使用ssh地址需要添加公钥) </p>
<p>git remote add origin 地址    ——&gt;  关联远程仓库(只需要关联一次)</p>
<p>git push [-u] origin master   ——&gt;  提交(-u在第一次提交分支的时候才用) </p>
<p>git push   ——&gt;  将本地仓库的内容提交到远程仓库master分支上</p>
<p>git push origin 分支名     ——&gt;  将本地仓库的内容提交到远程仓库对应的分支上, 如果分支不存在会自动创建</p>
<p>git pull   ——&gt;  将远程仓库中的内容更新到本地仓库和工作区中</p>
<h1 id="2-分之管理"><a href="#2-分之管理" class="headerlink" title="2.分之管理"></a>2.分之管理</h1><p>创建仓库会默认给我们创建一个master分之,这个分之一般作为提交和发布分之;开发一般会自己创建一个develop分之，用来开发和测试;多人协作的时候还可能根据不同的人或者(不同的功能)创建不同的分之，用来独立开发 </p>
<p>常见分之： master(主要是合并develop), develop(主要合并下面的其他分支), 功能/人员分之(开发)  </p>
<p>git branch [-a]   ——&gt;查看分之<br>git branch 分之名——&gt;创建分之<br>git checkout   分支名——&gt;  切换分之<br>git checkout -b 分之名    ——&gt;切换并创建新的分之<br>git diff  分之1  分之2——&gt;查看两个分之之间的差异<br>git merge 分之名——&gt;让当前分之和指定分之进行合并</p>
<p>注意: 切换分之、push、pull，这些操作前要保证工作区是clean<br>怎么避免冲突：  不要发生多个分之对同一个文件在同一个版本下进行修改(和同伴确认和商量)</p>
]]></content>
      <categories>
        <category>Git &amp; Shell</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>技术文档</tag>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中python相关软件安装记录</title>
    <url>/2019/01/20/%E5%90%8E%E7%AB%AF/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>Linux中的Python, MySQL, Redis, Nginx安装,基础环境配置</p>
<a id="more"></a>

<h1 id="Linux基本配置"><a href="#Linux基本配置" class="headerlink" title="Linux基本配置"></a>Linux基本配置</h1><h2 id="配置vim编辑器"><a href="#配置vim编辑器" class="headerlink" title="配置vim编辑器"></a>配置vim编辑器</h2><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">vim .vimrc</span><br><span class="line">    <span class="keyword">set</span> nu   <span class="comment"># 行号</span></span><br><span class="line">    <span class="keyword">set</span> ts=<span class="number">4</span>   <span class="comment"># 设置制表键空格数量</span></span><br><span class="line">    <span class="keyword">set</span> autoindent   <span class="comment"># 自动缩进</span></span><br><span class="line">    <span class="keyword">set</span> expandtab   <span class="comment"># 制表键自动变空格</span></span><br><span class="line">    <span class="keyword">set</span> ruler   <span class="comment"># 显示光标位置</span></span><br><span class="line">    <span class="keyword">set</span> nohls   <span class="comment"># 选中的代码不高亮</span></span><br><span class="line">    syntax <span class="keyword">on</span>   <span class="comment"># 语法高亮</span></span><br></pre></td></tr></table></figure>

<h2 id="查看命令别名"><a href="#查看命令别名" class="headerlink" title="查看命令别名"></a>查看命令别名</h2><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~</span><br><span class="line">vim <span class="string">.bashrc</span></span><br></pre></td></tr></table></figure>

<h2 id="修改用户名前的一长串"><a href="#修改用户名前的一长串" class="headerlink" title="修改用户名前的一长串"></a>修改用户名前的一长串</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">vim /etc/bashrc</span><br><span class="line"><span class="number">41</span>行删除@\h</span><br></pre></td></tr></table></figure>


<h1 id="后端相关的开发工具安装"><a href="#后端相关的开发工具安装" class="headerlink" title="后端相关的开发工具安装"></a>后端相关的开发工具安装</h1><h2 id="Linux软件安装方法"><a href="#Linux软件安装方法" class="headerlink" title="Linux软件安装方法"></a>Linux软件安装方法</h2><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">1. 包管理工具 </span><br><span class="line">    -<span class="ruby"> yum CentOS</span></span><br><span class="line"><span class="ruby">        ~ yum search nginx   ---&gt;   查看安装库内是否已经安装nginx</span></span><br><span class="line"><span class="ruby">        ~ yum install nginx   ---&gt;   安装</span></span><br><span class="line"><span class="ruby">        ~ yum erase nginx / yum remove nginx   ---&gt;   卸载</span></span><br><span class="line"><span class="ruby">        ~ yum info nginx   ---&gt;   查看软件信息</span></span><br><span class="line"><span class="ruby">        ~ yum list installed <span class="params">| grep nginx   ---&gt;   查看是否已经安装</span></span></span><br><span class="line"><span class="ruby">    - rpm Redhat</span></span><br><span class="line"><span class="ruby">        ~ rpm -ivh 下载的rpm包文件名</span></span><br><span class="line"><span class="ruby">        ~ rpm -e</span></span><br><span class="line"><span class="ruby">        ~ rpm -qa</span></span><br><span class="line"><span class="ruby">    - apt Ubuntu</span></span><br><span class="line"><span class="ruby"><span class="number">2</span>. 源代码构建安装</span></span><br></pre></td></tr></table></figure>

<h2 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">yum</span> <span class="string">install -y nginx</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">start nginx</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">stop nginx</span></span><br></pre></td></tr></table></figure>
<h2 id="MariaDB安装-MySQL-5-x-的一个分支-和5-x版本基本相同"><a href="#MariaDB安装-MySQL-5-x-的一个分支-和5-x版本基本相同" class="headerlink" title="MariaDB安装(MySQL 5.x 的一个分支,和5.x版本基本相同)"></a>MariaDB安装(MySQL 5.x 的一个分支,和5.x版本基本相同)</h2><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">yum</span> install -y <span class="keyword">mariadb </span><span class="keyword">mariadb-server</span></span><br><span class="line"><span class="keyword">systemctl </span>start <span class="keyword">mariadb</span></span><br><span class="line"><span class="keyword">mysql </span>-u root</span><br></pre></td></tr></table></figure>
<h2 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 清除掉所有跟mariadb相关的东西</span><br><span class="line">  yum list installed | grep mariadb | awk <span class="string">'&#123;print $1&#125;'</span> | xargs yum erase -y</span><br><span class="line"><span class="number">2.</span> 清理之前的数据和日志文件（如果存在）</span><br><span class="line">  rm -rf /var/lib/mysql</span><br><span class="line">  rm -f /var/log/mysqld.log</span><br><span class="line"><span class="number">3.</span> 下载MySQL官方提供的RPM包并解归档</span><br><span class="line">  wget https:<span class="comment">//dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.28-1.el7.x86_64.rpm-bundle.tar</span></span><br><span class="line">  tar -xvf mysql<span class="number">-5.7</span><span class="number">.28</span><span class="number">-1.</span>el7.x86_64.rpm-bundle.tar</span><br><span class="line"><span class="number">4.</span> 安装依赖库</span><br><span class="line">  yum install -y libaio</span><br><span class="line"><span class="number">5.</span> 使用rpm包管理工具安装MySQL</span><br><span class="line">  rpm -ivh mysql-community-common<span class="number">-5.7</span><span class="number">.28</span><span class="number">-1.</span>el7.x86_64.rpm</span><br><span class="line">  rpm -ivh mysql-community-libs<span class="number">-5.7</span><span class="number">.28</span><span class="number">-1.</span>el7.x86_64.rpm</span><br><span class="line">  rpm -ivh mysql-community-client<span class="number">-5.7</span><span class="number">.28</span><span class="number">-1.</span>el7.x86_64.rpm</span><br><span class="line">  rpm -ivh mysql-community-server<span class="number">-5.7</span><span class="number">.28</span><span class="number">-1.</span>el7.x86_64.rpm</span><br><span class="line"><span class="number">6.</span> 启动服务查看随机密码</span><br><span class="line">  systemctl start mysqld</span><br><span class="line">  cat /var/log/mysqld.log | grep password</span><br><span class="line"><span class="number">7.</span> 用客户端工具连接MySQL</span><br><span class="line">  mysql -u root -p</span><br><span class="line"><span class="number">8.</span> 修改root用户口令</span><br><span class="line">  <span class="keyword">set</span> global validate_password_policy=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">set</span> global validate_password_length=<span class="number">6</span>;</span><br><span class="line">  alter user <span class="string">'root'</span>@<span class="string">'localhost'</span> identified by <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">安装Redis官方最新版</span><br><span class="line">wget http:<span class="comment">//download.redis.io/releases/redis-5.0.7.tar.gz</span></span><br><span class="line">gunzip redis<span class="number">-5.0</span><span class="number">.7</span>.tar.gz</span><br><span class="line">tar -xvf redis<span class="number">-5.0</span><span class="number">.7</span>.tar</span><br><span class="line">cd redis<span class="number">-5.0</span><span class="number">.7</span></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h2 id="GIt安装"><a href="#GIt安装" class="headerlink" title="GIt安装"></a>GIt安装</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">安装Git官方最新版</span><br><span class="line">wget https:<span class="comment">//mirrors.edge.kernel.org/pub/software/scm/git/git-2.24.1.tar.xz</span></span><br><span class="line">xz -d git<span class="number">-2.24</span><span class="number">.1</span>.tar.xz</span><br><span class="line">tar -xf git<span class="number">-2.24</span><span class="number">.1</span>.tar</span><br><span class="line">cd git<span class="number">-2.24</span><span class="number">.1</span></span><br><span class="line">yum install -y curl libcurl-devel</span><br><span class="line">./configure --prefix=/usr/local</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h2 id="Python3安装"><a href="#Python3安装" class="headerlink" title="Python3安装"></a>Python3安装</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 安装依赖项</span><br><span class="line">    yum install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel</span><br><span class="line"><span class="number">2.</span> 下载Python3源代码</span><br><span class="line">    wget https:<span class="comment">//www.python.org/ftp/python/3.7.6/Python-3.7.6.tar.xz</span></span><br><span class="line"><span class="number">3.</span> 解压缩和解归档</span><br><span class="line">    xz -d Python<span class="number">-3.7</span><span class="number">.6</span>.tar.xz</span><br><span class="line">    tar -xvf Python<span class="number">-3.7</span><span class="number">.6</span>.tar</span><br><span class="line"><span class="number">4.</span> 执行安装前的配置</span><br><span class="line">    cd Python<span class="number">-3.7</span><span class="number">.6</span></span><br><span class="line">    ./configure --prefix=/usr/local/python37 --enable-optimizations</span><br><span class="line"><span class="number">5.</span> 构建和安装</span><br><span class="line">    make &amp;&amp; make install</span><br><span class="line"><span class="number">6.</span> 注册环境变量</span><br><span class="line">    vim ~/.bash_profile</span><br><span class="line">        PATH=$PATH:/usr/local/python37/bin</span><br><span class="line">        export PATH</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>技术文档</tag>
        <tag>Linux软件</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>shell编程</title>
    <url>/2019/12/23/%E5%90%8E%E7%AB%AF/shell%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>Shell脚本，是一种为shell编写的脚本程序。</p>
<a id="more"></a>


<h1 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h1><p>Shell脚本，是一种为shell编写的脚本程序。</p>
<p>Shell编程跟JavaScript、Python编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p>
<p>Linux的Shell种类有很多，我们主要用的是Bourne Shell(/usr.bin/sh或/bin/sh)</p>
<h1 id="1-创建shell文件"><a href="#1-创建shell文件" class="headerlink" title="1.创建shell文件"></a>1.创建shell文件</h1><p>原则上shell程序可以写在任何文件中，但是一般会在shell文件后加后缀.sh表示当前文件是一个shell文件<br>shell需要可执行权限，所以创建好的shell文件需要添加x权限</p>
<h1 id="2-基础语法"><a href="#2-基础语法" class="headerlink" title="2.基础语法"></a>2.基础语法</h1><h2 id="1）注释"><a href="#1）注释" class="headerlink" title="1）注释"></a>1）注释</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 单行注释</span></span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">多行注释1</span><br><span class="line">多行注释2</span><br><span class="line">多行注释3</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h2 id="2）输出和输入"><a href="#2）输出和输入" class="headerlink" title="2）输出和输入"></a>2）输出和输入</h2><p>echo指令就相当于python中的print函数(默认会换行)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo  输出内容  </span><br><span class="line">echo -n 输出内容     # 输出的时候不换行</span><br></pre></td></tr></table></figure>

<p>printf指令（输出不能换行）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> 输出内容</span><br></pre></td></tr></table></figure>

<p>输入指令:<br>read 变量名    – 输入内容，并且将输入的结果保存在变量中</p>
<h2 id="3）变量"><a href="#3）变量" class="headerlink" title="3）变量"></a>3）变量</h2><h3 id="a-声明变量的语法-变量名-值"><a href="#a-声明变量的语法-变量名-值" class="headerlink" title="a. 声明变量的语法:   变量名=值"></a>a. 声明变量的语法:   变量名=值</h3><p>说明:  a. 变量名和=, =和值之间不能有空格<br>​       b. 变量名的要求和python变量名要求一样</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name='小明'</span><br><span class="line">age=18</span><br><span class="line">stu_name=小红</span><br></pre></td></tr></table></figure>

<h3 id="b-使用变量"><a href="#b-使用变量" class="headerlink" title="b. 使用变量:"></a>b. 使用变量:</h3><p>​         $变量<br>​         ${变量}</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">age=18</span><br><span class="line">echo $age</span><br><span class="line">age2=$&#123;age&#125;</span><br></pre></td></tr></table></figure>

<h3 id="c-只读变量"><a href="#c-只读变量" class="headerlink" title="c. 只读变量"></a>c. 只读变量</h3><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gender='男'</span><br><span class="line">readonly gender</span><br><span class="line">gender='女'     # test.sh: line 17: gender: readonly variable</span><br></pre></td></tr></table></figure>

<h3 id="d-删除变量"><a href="#d-删除变量" class="headerlink" title="d. 删除变量"></a>d. 删除变量</h3><p>使用 unset 命令可以删除变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name='yuting'</span><br><span class="line">unset name</span><br></pre></td></tr></table></figure>

<h2 id="4）获取linux指令结果"><a href="#4）获取linux指令结果" class="headerlink" title="4）获取linux指令结果"></a>4）获取linux指令结果</h2><p>在shell脚本中可以直接写linux指令，在执行shell脚本的时候这些指令可以直接获取</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls     # ls指令</span><br><span class="line">ls  -lh      # ls指令，并且设置参数</span><br><span class="line">touch a.txt    # 创建a.txt文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取指令结果: 变量=$(指令)  /   变量=`指令`</span></span><br><span class="line">lsresult=$(ls)    #将ls指令的结果保存到变量lsresult中</span><br><span class="line">currnet_path=`pwd`</span><br></pre></td></tr></table></figure>



<h1 id="3-shell字符串"><a href="#3-shell字符串" class="headerlink" title="3.shell字符串"></a>3.shell字符串</h1><p>shell中的字符串可以用单引号也可以使用双引号甚至可以不用引号。但是单引号中不能出现单引号字符，加\也不行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">str1='abc'</span><br><span class="line">str2="abc"</span><br><span class="line">str3=abc</span><br><span class="line">str4='abc\n123'		#支持转义字符,但是不支持编码字符</span><br><span class="line">str5="abc\n123"</span><br><span class="line"></span><br><span class="line">age=18</span><br><span class="line">str6="年龄是$age"    #双引号里面可以出现变量,单引号不行</span><br></pre></td></tr></table></figure>

<h2 id="1）字符串拼接"><a href="#1）字符串拼接" class="headerlink" title="1）字符串拼接"></a>1）字符串拼接</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">str1="hello"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">单引号拼接</span></span><br><span class="line">str2=''$&#123;str1&#125;',world!'</span><br><span class="line">str3=''$str1',world!'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">双引号拼接</span></span><br><span class="line">str4="$&#123;str1&#125;,world!"</span><br><span class="line">str5=""$str1",world!"</span><br></pre></td></tr></table></figure>

<h2 id="2）获取字符串长度"><a href="#2）获取字符串长度" class="headerlink" title="2）获取字符串长度"></a>2）获取字符串长度</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">str1="abcd"</span><br><span class="line">echo $&#123;#str1&#125;    # 输出4</span><br></pre></td></tr></table></figure>

<h2 id="3）字符串提取"><a href="#3）字符串提取" class="headerlink" title="3）字符串提取"></a>3）字符串提取</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 字符串:下标:个数   --从字符串中指定下标开始获取指定个数字符,返回一个新的字符串</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 字符串:下标:1   -- 获取字符串中指定下标对应的字符</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 字符串:下标     -- 从指定下标开始获取到字符串最后</span></span><br><span class="line">string='hello world'</span><br><span class="line">echo $&#123;string:1:4&#125;    # ello</span><br></pre></td></tr></table></figure>



<h1 id="4-shell数组"><a href="#4-shell数组" class="headerlink" title="4.shell数组"></a>4.shell数组</h1><p>在 Shell 中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 数组名=(元素1 元素2 元素3 ...)</span></span><br><span class="line">names=(小明 小红 大黄 Tom)</span><br><span class="line">names2=(</span><br><span class="line">'小明'</span><br><span class="line">'小红'</span><br><span class="line">'大黄'</span><br><span class="line">'Tom'</span><br><span class="line">)</span><br><span class="line">names3[0]=小明</span><br><span class="line">names3[1]=小红</span><br><span class="line">names3[2]=大黄</span><br><span class="line">names3[3]=Tom</span><br></pre></td></tr></table></figure>
<h2 id="1）获取数组元素：-数组-下标"><a href="#1）获取数组元素：-数组-下标" class="headerlink" title="1）获取数组元素：${数组[下标]}"></a>1）获取数组元素：${数组[下标]}</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $&#123;names[1]&#125;    # 小红</span><br></pre></td></tr></table></figure>

<h2 id="2）获取数组的长度"><a href="#2）获取数组的长度" class="headerlink" title="2）获取数组的长度"></a>2）获取数组的长度</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nums=(100 200 300 400)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取数组长度</span></span><br><span class="line">length=$&#123;#nums[@]&#125;</span><br><span class="line">length=$&#123;#nums[*]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取数组指定下标对应的元素的长度</span></span><br><span class="line">length2=$&#123;#num[n]&#125;</span><br></pre></td></tr></table></figure>



<h1 id="5-运算符"><a href="#5-运算符" class="headerlink" title="5.运算符"></a>5.运算符</h1><p>shell中支持的运算符有:  算术运算符、关系运算符、布尔运算符、字符串运算符</p>
<h2 id="1）算术运算符：-，-，-，-，"><a href="#1）算术运算符：-，-，-，-，" class="headerlink" title="1）算术运算符：+，-，*，/，%"></a>1）算术运算符：+，-，*，/，%</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果想要在shell完成数值运算，运算的语法:  `expr 运算表达式`; 并且运算符两边必须加空格</span></span><br><span class="line">re1=10+20</span><br><span class="line">echo $&#123;re1&#125;    # 10+20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.加法运算</span></span><br><span class="line">re2=`expr 10 + 20`    </span><br><span class="line">echo $&#123;re2&#125;    # 30</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.减法运算</span></span><br><span class="line">re3=`expr 10 - 20`</span><br><span class="line">echo $&#123;re3&#125;	   # -10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.乘法运算</span></span><br><span class="line">re4=`expr 10 \* 20`   # 注意:使用*作为乘法运算符的时候需要前面加\</span><br><span class="line">echo $&#123;re4&#125; 	# 200</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.除法运算</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 小数除法运算: `<span class="built_in">echo</span> <span class="string">"scale=小数点位数;数值1 / 数值2"</span>|bc`</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 整数除法运算: `expr 数值1 / 数值2`</span></span><br><span class="line">re5=`echo "scale=2;7 / 3"|bc`</span><br><span class="line">echo $re5</span><br><span class="line"></span><br><span class="line">re6=`expr 5 / 2`</span><br><span class="line">echo $re6</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5.求余数</span></span><br><span class="line">re7=`expr 10 % 3`</span><br><span class="line"></span><br><span class="line">re8=`echo "10.2 + 5.1"|bc`</span><br><span class="line">echo $re8</span><br></pre></td></tr></table></figure>

<h2 id="2）-关系运算符-比较运算符-，比较的是数字大小"><a href="#2）-关系运算符-比较运算符-，比较的是数字大小" class="headerlink" title="2） 关系运算符(比较运算符)，比较的是数字大小"></a>2） 关系运算符(比较运算符)，比较的是数字大小</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -eq  ---  等于,相当于 ==</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -ne  ---  不等于,相当于!=</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -gt  ---  大于</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -lt  ---  小于</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -ge  ---  大于等于</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -le  ---  小于等于</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用语法: [ 值1 关系运算符 值2 ]</span></span><br><span class="line">a=100</span><br><span class="line">b=10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关系运算符要配合<span class="keyword">if</span>语句或者循环语句使用</span></span><br><span class="line">if [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">	echo a大于b</span><br><span class="line">else </span><br><span class="line">	echo a不大于b</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="3）布尔运算符-逻辑运算符"><a href="#3）布尔运算符-逻辑运算符" class="headerlink" title="3）布尔运算符(逻辑运算符)"></a>3）布尔运算符(逻辑运算符)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> !    --  逻辑非运算</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -o   --  逻辑或运算</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -a   --  逻辑与运算</span></span><br><span class="line"></span><br><span class="line">age=18</span><br><span class="line">score=95</span><br><span class="line"><span class="meta">#</span><span class="bash"> 参加比赛的条件：分数大于90分并且年龄大于等于18岁</span></span><br><span class="line">if [ $age -ge 18 -a $score -gt 90 ]</span><br><span class="line">then</span><br><span class="line">	echo 可以参见比赛</span><br><span class="line">else</span><br><span class="line">	echo 不能参加比赛</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="4）字符串运算符"><a href="#4）字符串运算符" class="headerlink" title="4）字符串运算符"></a>4）字符串运算符</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> [ 字符串1 = 字符串2 ]    -- 判断两个字符串是否相等</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [ 字符串1 != 字符串2 ]   -- 不相等</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [ -z 字符串]   -- 判断字符串长度是否为0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [ -n <span class="string">"字符串"</span> ]    -- 判断字符串长度是否不为0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [ $ 字符串 ]   -- 判断字符串是否是空串</span></span><br><span class="line"></span><br><span class="line">a="abc"</span><br><span class="line">b="123"</span><br><span class="line"></span><br><span class="line">if [ $a = $b ]</span><br><span class="line">then</span><br><span class="line">    echo a和b相等</span><br><span class="line">else</span><br><span class="line">    echo a和b不相等</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">a=""</span><br><span class="line">if [ -n "$&#123;a&#125;" ]</span><br><span class="line">then</span><br><span class="line">    echo a的长度不为0</span><br><span class="line">else</span><br><span class="line">    echo a的长度为0</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h1 id="6-if语句"><a href="#6-if语句" class="headerlink" title="6. if语句"></a>6. if语句</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">语法1：</span><br><span class="line">if 条件语句</span><br><span class="line">then</span><br><span class="line">    满足条件执行的代码</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">语法2:</span><br><span class="line">if 条件语句</span><br><span class="line">then</span><br><span class="line">    满足条件执行的代码</span><br><span class="line">else</span><br><span class="line">    不满足条件执行的代码</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">语法3：</span><br><span class="line">if 条件语句1</span><br><span class="line">then </span><br><span class="line">    代码块1</span><br><span class="line">elif 条件语句2</span><br><span class="line">then</span><br><span class="line">    代码块2</span><br><span class="line">elif 条件语句3</span><br><span class="line">then </span><br><span class="line">    代码块3</span><br><span class="line">else</span><br><span class="line">    代码块N</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h1 id="7-for循环"><a href="#7-for循环" class="headerlink" title="7. for循环"></a>7. for循环</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">for 变量 in 序列</span><br><span class="line">do</span><br><span class="line">    循环体</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 遍历字符串</span></span><br><span class="line">for char in "hello word"</span><br><span class="line">do</span><br><span class="line">    echo 循环体char: $&#123;char&#125;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 遍历数组</span></span><br><span class="line">arr1=(10 20 "abc")</span><br><span class="line">for x in $&#123;arr1[@]&#125;</span><br><span class="line">do</span><br><span class="line">    echo 循环体2x: $&#123;x&#125;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 遍历多个值</span></span><br><span class="line">for x in 10 20 "你好" 123</span><br><span class="line">do</span><br><span class="line">    echo 循环体3：$&#123;x&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h1 id="8-while循环"><a href="#8-while循环" class="headerlink" title="8. while循环"></a>8. while循环</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">while 条件语句</span><br><span class="line">do</span><br><span class="line">    循环体</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 遍历字符串</span></span><br><span class="line">str1="helloWorld!"</span><br><span class="line">index=0</span><br><span class="line">len=$&#123;#str1&#125;</span><br><span class="line">while [ $index -lt $len ]</span><br><span class="line">do</span><br><span class="line">    echo $&#123;str1:$&#123;index&#125;:1&#125;</span><br><span class="line">    index=`expr $&#123;index&#125; + 1`</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算1+2+3+...+100</span></span><br><span class="line">num=1</span><br><span class="line">sum=0</span><br><span class="line">while [ $&#123;num&#125; -le 100 ]</span><br><span class="line">do</span><br><span class="line">    sum=`expr $&#123;sum&#125; + $&#123;num&#125;`</span><br><span class="line">    num=`expr $&#123;num&#125; + 1`</span><br><span class="line">done</span><br><span class="line">echo 1+2+3+...+100 = $&#123;sum&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 死循环</span></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    read -p "请输入一个数字:" num</span><br><span class="line">    if [ $&#123;num&#125; == 100 ]</span><br><span class="line">    then</span><br><span class="line">        break</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h1 id="9-函数"><a href="#9-函数" class="headerlink" title="9.函数"></a>9.函数</h1><h2 id="1）函数的声明和调用"><a href="#1）函数的声明和调用" class="headerlink" title="1）函数的声明和调用"></a>1）函数的声明和调用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.函数的声明</span></span><br><span class="line">声明的语法：</span><br><span class="line">函数名()&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用函数语法:  函数名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">声明函数</span></span><br><span class="line">func1()&#123;</span><br><span class="line">    echo 你好函数1</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">调用函数</span></span><br><span class="line">func1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.有参数的函数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 声明的时候不需要形参, 直接在函数体中通过<span class="string">'$&#123;N&#125;'</span>来获取第N个实参</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用的时候:  函数名 实参1 实参2 实参3 ...</span></span><br><span class="line">func2()&#123;</span><br><span class="line">    echo 函数2被调用</span><br><span class="line">    echo 第一个参数: $&#123;1&#125;</span><br><span class="line">    echo 第二个参数: $&#123;2&#125;</span><br><span class="line">    echo 第三个参数: $&#123;3&#125; </span><br><span class="line">&#125;</span><br><span class="line">func2 10 20 "abc"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.函数的返回值</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">return</span> 数字   - 数字的范围是0~255</span></span><br><span class="line">func3()&#123;</span><br><span class="line">    echo 函数3被调用</span><br><span class="line">    return 256</span><br><span class="line">    #a=`expr 100 + 200`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func3</span><br><span class="line">echo $&#123;?&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git &amp; Shell</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>shell</tag>
        <tag>脚本</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis及其应用</title>
    <url>/2019/12/27/%E5%90%8E%E7%AB%AF/radis/</url>
    <content><![CDATA[<p>非关系型数据库Redis<br>Redis是为了实现高速缓存服务,减小MySQL数据库的压力</p>
<a id="more"></a>


<h1 id="Linux服务起停"><a href="#Linux服务起停" class="headerlink" title="Linux服务起停"></a>Linux服务起停</h1><p>CentOS<br>    systemctl start 服务名   -&gt;   启动<br>    systemctl stop 服务名   -&gt;   停止<br>    systemctl restart 服务名   -&gt;   重启<br>    systemctl status 服务名   -&gt;   查看状态<br>    systemctl enable 服务名   -&gt;   开机自启<br>    systemctl disable 服务名   -&gt;   禁止自启</p>
<p>Ubuntu<br>    service 服务名 start   -&gt;   启动</p>
<h1 id="进程查杀"><a href="#进程查杀" class="headerlink" title="进程查杀"></a>进程查杀</h1><p>ps -ef | grep “”  -&gt;  搜索全部包含字符串的内容<br>ps -ef | grep “” | grep -v “grep” -&gt;  搜索全部包含字符串的内容并且过滤掉包含grep的内容<br>ps -ef | grep -E正则表达式  -&gt;  搜索全部包含符合正则表达式的内容<br>xargs  -&gt;  将列变成行<br>ps -ef | grep “redis-server” | grep -v “grep” | awk ‘{print $2}’ | xargs kill  -&gt;  精准查杀进程</p>
<p>pkill 进程名  -&gt;  根据名字杀掉进程<br>killall 进程名  -&gt;  根据名字杀掉进程</p>
<h1 id="redis命令"><a href="#redis命令" class="headerlink" title="redis命令"></a>redis命令</h1><p>ttl key ——&gt; 查看key的存活时间<br>set key value ex N ——&gt; 设置key的存活时间为N秒<br>set key value px N ——&gt; 设置key的存活时间为N毫秒<br>shutdown  ——&gt; 关闭redis服务器<br>shutdown save ——&gt; 保存并关闭redis服务器<br>save ——&gt; 保存<br>bgsave ——&gt; 后台保存<br>dbsize ——&gt; 查看数据库大小<br>keys *  ——&gt; 获取所有的key<br>keys ta*  ——&gt; 获取ta开头的key</p>
<p><strong>redis默认开启了16个数据库</strong><br>select 0-15 ——&gt; 切换数据库<br>flushdb ——&gt; 清空当前数据库<br>flushall ——&gt; 清空所有数据库</p>
<p>type keyp ——&gt; 判断key的类型</p>
<h1 id="redis的数据类型"><a href="#redis的数据类型" class="headerlink" title="redis的数据类型"></a>redis的数据类型</h1><h2 id="1-字符串-string"><a href="#1-字符串-string" class="headerlink" title="1.字符串 - string"></a>1.字符串 - string</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">key</span> <span class="keyword">value</span></span><br><span class="line"><span class="keyword">get</span> <span class="keyword">key</span></span><br><span class="line">strlen <span class="keyword">key</span></span><br><span class="line">append <span class="keyword">key</span> <span class="keyword">value</span> <span class="comment">------&gt; 追加</span></span><br><span class="line">mset key1 value1 key2 value2 ... <span class="comment">------&gt; 同时设置多组值</span></span><br><span class="line">mget key1 key2 ...</span><br><span class="line">incr <span class="keyword">key</span> <span class="comment">------&gt; 当key的值为数字时,数值加一</span></span><br><span class="line">incrby <span class="keyword">key</span> N <span class="comment">------&gt; 为key的值加N</span></span><br><span class="line">decr <span class="keyword">key</span> <span class="comment">------&gt; 减一</span></span><br><span class="line">decrby <span class="keyword">key</span> N <span class="comment">------&gt; 减N</span></span><br><span class="line">getrange <span class="keyword">key</span> m n <span class="comment">------&gt; 从m取到n</span></span><br><span class="line">setrange <span class="keyword">key</span> N <span class="keyword">value</span> <span class="comment">------&gt; 从n开始用value覆盖key的value值</span></span><br></pre></td></tr></table></figure>
<h2 id="2-哈希-hash"><a href="#2-哈希-hash" class="headerlink" title="2.哈希 - hash"></a>2.哈希 - hash</h2><figure class="highlight q"><table><tr><td class="code"><pre><span class="line">hset <span class="built_in">key</span> field <span class="built_in">value</span> 设置键和值</span><br><span class="line">hmset <span class="built_in">key</span> field1 value1 field2 value2 同时设置多个键和值</span><br><span class="line">hget <span class="built_in">key</span> field  查看指定的键对应的值</span><br><span class="line">hmget <span class="built_in">key</span> fieldl field2 同时查看多个键和值</span><br><span class="line">hgetall <span class="built_in">key</span> 获取所有的值和键</span><br><span class="line">hkeys <span class="built_in">key</span> 获取所有的键</span><br><span class="line">hvals <span class="built_in">key</span> 获取所有的值</span><br><span class="line">hexists <span class="built_in">key</span> filed 判断是否存在对应的值</span><br></pre></td></tr></table></figure>

<h2 id="3-列表-list"><a href="#3-列表-list" class="headerlink" title="3.列表 - list"></a>3.列表 - list</h2><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">lpush <span class="keyword">list</span> value1 value2 ... 插入到最左边</span><br><span class="line">rpush <span class="keyword">list</span> value1 value2 ... 插入到最右边</span><br><span class="line">lpop <span class="keyword">list</span> 取最左边</span><br><span class="line">rpop <span class="keyword">list</span> 取最右边</span><br><span class="line"><span class="keyword">lrange</span> <span class="keyword">list</span> start end 查看列表片段</span><br><span class="line"><span class="keyword">lindex</span> <span class="keyword">list</span> index 查看指定下标对应的元素</span><br><span class="line">llen <span class="keyword">list</span> 列表长度</span><br><span class="line">lrem <span class="keyword">list</span> count value 删除指定个数的元素</span><br></pre></td></tr></table></figure>
<h2 id="4-集合-set"><a href="#4-集合-set" class="headerlink" title="4.集合 - set"></a>4.集合 - set</h2><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">sadd <span class="keyword">set</span> value1 value2 <span class="string">...</span> 添加元素</span><br><span class="line">srem <span class="keyword">set</span> value 移除元素</span><br><span class="line">spop <span class="keyword">set</span> 获取随机元素</span><br><span class="line">smembers <span class="keyword">set</span> 查看所有元素</span><br><span class="line">sismember <span class="keyword">set</span> value 查看元素是否在集合内</span><br><span class="line">scard <span class="keyword">set</span> 查看元素个数</span><br><span class="line">sinter <span class="keyword">set</span>1 <span class="keyword">set</span>2 交集</span><br><span class="line">sunion <span class="keyword">set</span>1 <span class="keyword">set</span>2 并集</span><br><span class="line">sdiff <span class="keyword">set</span>1 <span class="keyword">set</span>2 差集</span><br></pre></td></tr></table></figure>
<h2 id="5-有序集合-zset-元素自带一个值-可以修改"><a href="#5-有序集合-zset-元素自带一个值-可以修改" class="headerlink" title="5.有序集合 - zset(元素自带一个值,可以修改)"></a>5.有序集合 - zset(元素自带一个值,可以修改)</h2><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">zadd zset score1 mem1 score2 mem2 ... 添加</span><br><span class="line">zrem zset mem 移除</span><br><span class="line">zrange zset start <span class="keyword">end</span> 按<span class="symbol">score</span>升序查看</span><br><span class="line">zrevrange zset start <span class="keyword">end</span> 按<span class="symbol">score</span>降序查看</span><br><span class="line">zscore zset mem 查看<span class="symbol">score</span>值</span><br><span class="line">zincrby zset value mem 改变<span class="symbol">score</span>的值</span><br></pre></td></tr></table></figure>
<h2 id="6-地理位置-LBS应用-Location-Based-Service-基于位置的服务"><a href="#6-地理位置-LBS应用-Location-Based-Service-基于位置的服务" class="headerlink" title="6.地理位置(LBS应用-Location-Based Service - 基于位置的服务)"></a>6.地理位置(LBS应用-Location-Based Service - 基于位置的服务)</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">geoadd zset longitude1 latitude1 member1 longitude2 latitude2 member2 <span class="built_in">..</span>.   添加经纬度信息</span><br><span class="line">geopos zset member1 member2 <span class="built_in">..</span>. 获取指定的位置的经纬度</span><br><span class="line">geodist zset member1 member2 [unit] 计算两点间的距离,默认单位是米,[unit]是单位,可以修改为m,km,mi英里,ft英尺</span><br><span class="line">georadius zset longitude1 latitude1<span class="built_in"> radius </span>m/km/mi/ft 获取以点zset为圆心,radius为半径的圆的范围内的所有的坐标点;后面加withdist,可同时获取距离,加withcoord,可同时获取点的经纬度</span><br></pre></td></tr></table></figure>


<h1 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术"></a>加密技术</h1><p><strong>对称加密 : 加密和解密使用相同的密钥 - AES<br>非对称加密 : 加密和解密使用不同的密钥(公钥和私钥)  -  适合互连网 - RSA</strong></p>
<p><strong>免密操作</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ssh-keygen</span> <span class="selector-tag">-t</span> <span class="selector-tag">rsa</span> <span class="selector-tag">-b</span> 2048 <span class="selector-tag">-c</span> <span class="selector-tag">anjhon</span><span class="keyword">@163</span>.com   -   生成公钥和私钥</span><br><span class="line">t 指定算法; <span class="selector-tag">b</span> 指定强度; <span class="selector-tag">c</span> 指定邮箱</span><br><span class="line"></span><br><span class="line">进入到<span class="selector-class">.ssh</span>文件,</span><br><span class="line"><span class="selector-tag">id_rsa</span>  <span class="selector-tag">-</span>   私钥</span><br><span class="line"><span class="selector-tag">id_rsa</span><span class="selector-class">.pub</span>  <span class="selector-tag">-</span>   公钥</span><br><span class="line"></span><br><span class="line">将公钥复制到网站的公钥设置</span><br><span class="line"></span><br><span class="line">若有<span class="selector-tag">known-hosts</span>文件,且网站链接不上,直接删除<span class="selector-tag">known-hosts</span>文件</span><br></pre></td></tr></table></figure>



<h1 id="Python中的redis"><a href="#Python中的redis" class="headerlink" title="Python中的redis"></a>Python中的redis</h1><p><strong>连接redis服务器:</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">redis.Redis(<span class="attribute">host</span>=<span class="string">''</span>, <span class="attribute">password</span>=<span class="string">''</span>, <span class="attribute">prot</span>=<span class="string">''</span>)</span><br><span class="line">	host : redis所在服务器公网地址;</span><br><span class="line">	password : 登录口令;</span><br><span class="line"><span class="built_in">	port </span>: redis的服务端口</span><br><span class="line">	</span><br><span class="line">连接时会返回一个连接对象:</span><br><span class="line">redis_cli = redis.Redis(<span class="attribute">host</span>=<span class="string">''</span>, <span class="attribute">password</span>=<span class="string">''</span>, <span class="attribute">prot</span>=<span class="string">''</span>)</span><br><span class="line">使用redis完成相应的操作</span><br></pre></td></tr></table></figure>

<p><strong>python中使用redis的数据类型:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis   <span class="comment"># 导入redis模块</span></span><br><span class="line"></span><br><span class="line">redis_cli = redis.Redis(host=<span class="string">'10.10.10.10'</span>, password=<span class="string">'123456'</span>, port=<span class="string">'6379'</span>)   <span class="comment"># 连接redis服务器</span></span><br><span class="line"><span class="comment"># print(redis_cli)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> redis_cli.ping():</span><br><span class="line">    <span class="comment"># hash的使用</span></span><br><span class="line">    redis_cli.hmset(<span class="string">'stu1'</span>, &#123;</span><br><span class="line">        <span class="string">'stuname'</span>: <span class="string">'xiaoming'</span>,</span><br><span class="line">        <span class="string">'stuid'</span>: <span class="string">'001'</span>,</span><br><span class="line">        <span class="string">'stusex'</span>: <span class="string">'1'</span>,</span><br><span class="line">        <span class="string">'stuaddr'</span>: <span class="string">'肖家河'</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    print(redis_cli.hget(<span class="string">'stu1'</span>, <span class="string">'stuname'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 有序集合的使用</span></span><br><span class="line">    redis_cli.zadd(<span class="string">'zset1'</span>, &#123;</span><br><span class="line">        <span class="string">'an'</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="string">'yong'</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">'duan'</span>: <span class="number">300</span></span><br><span class="line">    &#125;)</span><br><span class="line">    items = redis_cli.zrevrange(<span class="string">'zset1'</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">    print(list(map(bytes.decode, items)))</span><br><span class="line">    print(redis_cli.zscore(<span class="string">'zset1'</span>, <span class="string">'an'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 列表的使用</span></span><br><span class="line">    redis_cli.rpush(<span class="string">'list1'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    list1 = redis_cli.lrange(<span class="string">'list1'</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">    print(list(map(int, list1)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 字符串的使用</span></span><br><span class="line">    redis_cli.set(<span class="string">'username'</span>, <span class="string">'an'</span>)</span><br><span class="line">    print(redis_cli.ttl(<span class="string">'username'</span>))</span><br><span class="line">    print(redis_cli.get(<span class="string">'username'</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    redis_cli.set(<span class="string">'user_age'</span>, <span class="string">'25'</span>)</span><br><span class="line">    redis_cli.set(<span class="string">'user_tel'</span>, <span class="string">'133'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'连接失败'</span>)</span><br></pre></td></tr></table></figure>

<p><strong>扩展:</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">freeze</span> &gt; requirement.txt   将虚拟环境依赖项写入到文件</span><br><span class="line">pip install -r requirement.txt   按照文件安装依赖项</span><br><span class="line"></span><br><span class="line">序列化:  把一个对象变成字符串(str)或字节串(bytes)</span><br><span class="line">反序列化:  把字符串或者字节串还原成对象</span><br><span class="line"><span class="type">json</span>.dumps()   序列化(字符串转换成字节串)</span><br><span class="line"><span class="type">json</span>.loads()   反序列化(字节串转换成字符串)</span><br><span class="line">pickle.dumps()   序列化(字符串转换成字节串)</span><br><span class="line">pickle.loads()   反序列化(字节串转换成字符串)</span><br></pre></td></tr></table></figure>
<p><strong>数据上传redis服务器并从redis获取数据</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, sex, addr)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.addr = addr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span>   <span class="comment"># 魔法方法(将数据显示出来)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%s, %d, %s, %s'</span> % (self.name, self.age, self.sex, self.addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = Student(<span class="string">'小明'</span>, <span class="number">20</span>, <span class="string">'男'</span>, <span class="string">'昆明'</span>)</span><br><span class="line">stu2 = Student(<span class="string">'小黄'</span>, <span class="number">30</span>, <span class="string">'女'</span>, <span class="string">'上海'</span>)</span><br><span class="line"></span><br><span class="line">list1 = [stu1, stu2]   <span class="comment"># 将学生对象添加到列表中</span></span><br><span class="line"></span><br><span class="line">redis_cli = redis.Redis(host=<span class="string">'10.10.10.10'</span>, password=<span class="string">'123456'</span>, port=<span class="string">'6379'</span>)   <span class="comment"># 连接redis服务器</span></span><br><span class="line"><span class="keyword">if</span> redis_cli.ping():</span><br><span class="line">    <span class="comment"># redis_cli.set('student_all', pickle.dumps(list1))   -   将本地的数据添加到redis</span></span><br><span class="line">    redis_stu = pickle.loads(redis_cli.get(<span class="string">'student_all'</span>))   <span class="comment"># 获取redis内的数据并进行反序列化</span></span><br><span class="line">    print(redis_stu)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'连接失败'</span>)</span><br></pre></td></tr></table></figure>

<p><strong>将redis作为用户请求和数据库之间的缓存介质</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_depts_from_db</span><span class="params">()</span>:</span></span><br><span class="line">    conn = pymysql.connect(   <span class="comment"># 连接本地的MySQL服务器</span></span><br><span class="line">        host=<span class="string">'localhost'</span>,</span><br><span class="line">        port=<span class="number">3306</span>,</span><br><span class="line">        user=<span class="string">'root'</span>,</span><br><span class="line">        password=<span class="string">'123456'</span>,</span><br><span class="line">        charset=<span class="string">'utf8'</span>,</span><br><span class="line">        autocommit=<span class="literal">True</span>,</span><br><span class="line">        database=<span class="string">'hrs'</span></span><br><span class="line">    )</span><br><span class="line">    depts = ()</span><br><span class="line">    <span class="keyword">try</span>:   <span class="comment"># 异常捕获</span></span><br><span class="line">        <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">            cursor.execute(<span class="string">'select dno, dname, dloc from tb_dept'</span>)   <span class="comment"># 获取数据</span></span><br><span class="line">            depts = cursor.fetchall()</span><br><span class="line">    <span class="keyword">except</span> pymysql.MySQLError <span class="keyword">as</span> err:</span><br><span class="line">        print(err)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        conn.close()</span><br><span class="line">    <span class="keyword">return</span> depts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    redis_cli = redis.Redis(host=<span class="string">'10.10.10.10'</span>, password=<span class="string">'123456'</span>, port=<span class="string">'6379'</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    data = redis_cli.get(<span class="string">'depts'</span>)   <span class="comment"># 获取redis的depts对应的数据</span></span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        depts = pickle.loads(data)   <span class="comment"># 若获取到数据,将数据反序列化并保存下来</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        depts = load_depts_from_db()   <span class="comment"># 若没有数据,从数据库获取数据,并将数据保存到redis中,以便下次使用时优先从redis中获取,以减轻服务器的压力并且提高数据获取效率</span></span><br><span class="line">        redis_cli.set(<span class="string">'depts'</span>, pickle.dumps(depts))</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    print(depts)</span><br><span class="line">    print(<span class="string">f'执行时间: <span class="subst">&#123;end - start&#125;</span>秒'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>数据库</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>vim基础使用教程</title>
    <url>/2019/12/23/%E5%90%8E%E7%AB%AF/vim%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>vim日常使用</p>
<a id="more"></a>

<h1 id="1-vim的三种模式"><a href="#1-vim的三种模式" class="headerlink" title="1.vim的三种模式"></a>1.vim的三种模式</h1><ul>
<li><strong>命令模式：</strong>未尾既没有插入的字样也没有冒号（在编辑模式和末行模式下按esc键可以进入命令模式）</li>
<li><strong>编辑模式：</strong>末尾会显示’一插入一/-insert-，并且在编辑模式下可以对文件进行输入操作（可以编辑）（在命令模式下按i就可以进入编辑模式）</li>
<li><strong>未行模式：</strong>未尾显示冒号，并且冒号后边可以输入内容（在命令模式下输入冒号就可以进入未行模式）</li>
</ul>
<h1 id="2-vim的配置"><a href="#2-vim的配置" class="headerlink" title="2.vim的配置"></a>2.vim的配置</h1><p>通过编辑  etc/vimrc 文件配置</p>
<h1 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3.基本操作"></a>3.基本操作</h1><h2 id="1-保存和退出"><a href="#1-保存和退出" class="headerlink" title="1)保存和退出"></a>1)保存和退出</h2><p><strong>所有的保存和退出都是在末行模式下进行的</strong><br>W   ——&gt;只保存(相当于ctr+s)<br>q   ——&gt;直接退出(只有当前文件的内容全部保存才能直接退出,如果不保存强制退出,需要在q加!)<br>Wq   ——&gt;先保存再退出<br>注意:强制执行在指令后加!</p>
<h2 id="2-光标操作"><a href="#2-光标操作" class="headerlink" title="2)光标操作"></a>2)光标操作</h2><p><strong>所有光标操作对应的指令都是在命令模式下执行的</strong><br>^   ——&gt;直接将光标移动到行首<br>$   ——&gt;直接将光标移动到行尾<br>G   ——&gt;移动到文件未尾<br>gg   ——&gt;移动到文件开头<br>行号G    ——&gt;移动到指定行号的位到</p>
<h2 id="3-文本操作"><a href="#3-文本操作" class="headerlink" title="3)文本操作"></a>3)文本操作</h2><p>以下指令前面如果没有冒号表示在命令模式下执行，有冒号的在未行模式下执行</p>
<p>dd   ——&gt;删除当前光标所在的行<br>数字dd   ——&gt;数字如果是N，从光标所在的位置开始删N行<br>:%d     ——&gt;末行模式下输入%d，删除所有</p>
<p>u   ——&gt;撤销<br>ctr+   r   ——&gt;反撤销</p>
<p>yy   ——&gt;复制光标所在的行<br>数字yy   ——&gt;数字如果是N,从光标所在的位置开始复制N行<br>:%y   ——&gt;未行模式下输入%y,复制所有p-粘贴<br>p   ——&gt;粘贴<br>P   ——&gt;粘贴到上一行</p>
<h2 id="4-查找和替换"><a href="#4-查找和替换" class="headerlink" title="4)查找和替换"></a>4)查找和替换</h2><p><strong>: /正则表达式</strong>——&gt;查找当前文件中符合正则表达式的内容(结果可以用n和N来切换)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim中正则表达式的要求:</span><br><span class="line">1)python正则中所有的语法都有效</span><br><span class="line">2)单独使用有特殊功能的符号，在使用的时候需要加\才有效</span><br><span class="line">r'\d+'    -&gt;  /\d\+</span><br><span class="line">r'\d&#123;3&#125;'  -&gt;  /\d\&#123;3&#125;</span><br><span class="line">r'and|or' -&gt;  /and\|or</span><br></pre></td></tr></table></figure>

<p><strong>:1,$s/被替换的对象对应的正则/替换内容/参数</strong>——&gt;将文件中正则匹配到的内容替换成指定内容</p>
<blockquote>
<p>参数:<br>g——&gt;全局匹配(会替换所有符合要求的字符串,默认情况下一行只替换一个)<br>i——&gt;匹配的时候忽略大小写<br>c——&gt;替换的时候给出提示<br>e——&gt;忽略错误(忽略正则的错)</p>
</blockquote>
<h1 id="4高级操作"><a href="#4高级操作" class="headerlink" title="4高级操作"></a>4高级操作</h1><h2 id="1-比较文件"><a href="#1-比较文件" class="headerlink" title="1)比较文件"></a>1)比较文件</h2><p><strong>vim -d  文件路径1  文件路径2</strong></p>
<h2 id="2-同时打开多个文件"><a href="#2-同时打开多个文件" class="headerlink" title="2)同时打开多个文件"></a>2)同时打开多个文件</h2><p><strong>vim  文件路径  文件路径 …</strong></p>
<blockquote>
<p>1.切换窗口内容<br>在末行模式下输入:<strong>ls</strong>——&gt;可以查看当前打开的所有的文件和文件对象的标号在末行模式下输入:<strong>b标号</strong>——&gt;可以将当前窗口中的内容切换到指定标号对应的文件的内容</p>
<p>2.窗口的拆分<br>在未行模式下输入:<strong>sp/vs</strong>——&gt;可以将当前窗口垂直方向/水平方向进行拆分;拆分后可以在命令模式下按<strong>ctr+w</strong>来切换窗口</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>K近邻算法（KNN）</title>
    <url>/2019/02/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/KNN%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一-KNN算法概述"><a href="#一-KNN算法概述" class="headerlink" title="一: KNN算法概述"></a>一: KNN算法概述</h1><p><strong>K nearest neighbors (k邻近算法)</strong></p>
<p>KNN是通过测量不同特征值之间的<strong>距离</strong>进行分类。</p>
<p>KNN做分类预测时，一般是选择多数表决法，即训练集里和预测的样本特征最近的K个样本，预测为里面有最多类别数的类别。而KNN做回归时，一般是选择平均法，即最近的K个样本的样本输出的平均值作为回归预测值。</p>
<p>它的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别; 其中K通常是不大于20的整数。KNN算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。</p>
<p>KNN方法既可以做分类，也可以做回归</p>
<p><strong>举例说明</strong></p>
<p><strong>例- 1 : 图片中分三类$$w_1 红色圆圈，w_2 蓝色三角，w_3 绿色的方块$$，请问数据$$X_u$$属于哪个类别</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmgmmdlhlrj20c80amq5j.jpg" alt="KNN-1.png"></p>
<p>设置k=5, 4个邻居是红色，1个邻居是绿色的; 所以是红色的概率为80%, 是绿色的概率是20%</p>
<p><strong>例 - 2: 如下图，绿色圆要被决定赋予哪个类，是红色三角形还是蓝色四方形？</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmgmmzt8lkj205a04rmx3.jpg" alt="KNN-2.png"></p>
<p>如果K=3，由于红色三角形所占比例为2/3，绿色圆将被赋予红色三角形那个类，如果K=5，由于蓝色四方形比例为3/5，因此绿色圆被赋予蓝色四方形类。</p>
<p><strong>由此也说明了KNN算法的结果很大程度取决于K的选择。</strong></p>
<br>




<h1 id="二-KNN算法三要素"><a href="#二-KNN算法三要素" class="headerlink" title="二: KNN算法三要素"></a>二: KNN算法三要素</h1><p>KNN算法三要素: <strong>k值的选取</strong>，<strong>距离度量的方式</strong>和<strong>分类决策规则</strong></p>
<h2 id="一-K值得选取"><a href="#一-K值得选取" class="headerlink" title="(一): K值得选取"></a>(一): K值得选取</h2><p>对于k值的选择，没有一个固定的经验，一般根据样本的分布，选择一个较小的值，可以通过交叉验证选择一个合适的k值。</p>
<p>选择较小的k值，就相当于用较小的领域中的训练实例进行预测，训练误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是泛化误差会增大，换句话说，K值的减小就意味着整体模型变得复杂，容易发生过拟合；<br>　　选择较大的k值，就相当于用较大领域中的训练实例进行预测，其优点是可以减少泛化误差，但缺点是训练误差会增大。这时候，与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。<br>　　一个极端是k等于样本数m，则完全没有分类，此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的类，模型过于简单。</p>
<h2 id="二-距离的度量方式-常用欧式距离"><a href="#二-距离的度量方式-常用欧式距离" class="headerlink" title="(二): 距离的度量方式(常用欧式距离)"></a>(二): 距离的度量方式(常用欧式距离)</h2><p><strong>欧式距离:</strong><br>$$<br>d(x, y) =\sqrt{(x_1−y_1)^2+(x_2−y_2)^2+…+(x_n−y_n)^2}=\sqrt{\sum\limits_{i=1}^n(x_i - y_i)^2}<br>$$</p>
<p><strong>曼哈顿距离:</strong><br>$$<br>d(x, y) = |x_1−y_1|+|x_2−y_2|+…+|x_n−y_n|=\sum\limits_{i=1}^n\vert x_i - y_i\vert<br>$$</p>
<p><strong>闵可夫斯基距离:</strong><br>$$<br>d(x,y)= \sqrt[p]{(|x_1−y_1|)^p+(|x_2−y_2|)^p+…+(|x_n−y_n|)^p}=\sqrt[p]{\sum_{i=1}^n(|x_i−y_i|)^p}<br>$$<br>可以看出，欧式距离是闵可夫斯基距离距离在p=2时的特例，而曼哈顿距离是p=1时的特例。</p>
<p><strong>方差和标准差:</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmgmnem8lqj20jh0da74i.jpg" alt="KNN-3.jpg"></p>
<h2 id="三-分类决策规则"><a href="#三-分类决策规则" class="headerlink" title="(三): 分类决策规则"></a>(三): 分类决策规则</h2><p>一般都是使用前面提到的多数表决法。</p>
<br>


<h1 id="三-KNN算法的实现方式"><a href="#三-KNN算法的实现方式" class="headerlink" title="三: KNN算法的实现方式"></a>三: KNN算法的实现方式</h1><h2 id="一-蛮力实现"><a href="#一-蛮力实现" class="headerlink" title="(一): 蛮力实现"></a>(一): 蛮力实现</h2><p>既然我们要找到k个最近的邻居来做预测，那么我们只需要计算预测样本和所有训练集中的样本的距离，然后计算出最小的k个距离即可，接着多数表决，很容易做出预测。这个方法的确简单直接，在样本量少，样本特征少的时候有效。但是在实际运用中很多时候用不上，为什么呢？因为我们经常碰到样本的特征数有上千以上，样本量有几十万以上，如果我们这要去预测少量的测试集样本，算法的时间效率很成问题。因此，这个方法我们一般称之为蛮力实现。比较适合于少量样本的简单模型的时候用。</p>
<h2 id="二-KD树实现原理"><a href="#二-KD树实现原理" class="headerlink" title="(二): KD树实现原理"></a>(二): KD树实现原理</h2><p>KD树算法没有一开始就尝试对测试样本分类，而是先对训练集建模，建立的模型就是KD树，建好了模型再对测试集做预测。所谓的KD树就是K个特征维度的树，注意这里的K和KNN中的K的意思不同。KNN中的K代表最近的K个样本，KD树中的K代表样本特征的维数。为了防止混淆，后面我们称特征维数为n。</p>
<p>KD树算法包括三步，第一步是建树，第二部是搜索最近邻，最后一步是预测。</p>
<h3 id="1-KD树建立"><a href="#1-KD树建立" class="headerlink" title="1: KD树建立"></a>1: KD树建立</h3><p>我们首先来看建树的方法。KD树建树采用的是从m个样本的n维特征中，分别计算n个特征的取值的方差，用方差最大的第k维特征$n_k$来作为根节点。对于这个特征，我们选择特征$n_k$的取值的中位数$n_{kv}$对应的样本作为划分点，对于所有第k维特征的取值小于$n_{kv}$的样本，我们划入左子树，对于第k维特征的取值大于等于$n_{kv}$的样本，我们划入右子树，对于左子树和右子树，我们采用和刚才同样的办法来找方差最大的特征来做更节点，递归的生成KD树。</p>
<p>比如我们有二维样本6个，{(2,3)，(5,4)，(9,6)，(4,7)，(8,1)，(7,2)}，构建kd树的具体步骤为：</p>
<ul>
<li><p>1）找到划分的特征。6个数据点在x，y维度上的数据方差分别为6.97，5.37，所以在x轴上方差更大，用第1维特征建树。</p>
</li>
<li><p>2）确定划分点（7,2）。根据x维上的值将数据排序，6个数据的中值(所谓中值，即中间大小的值)为7，所以划分点的数据是（7,2）。这样，该节点的分割超平面就是通过（7,2）并垂直于：划分点维度的直线x=7；</p>
</li>
<li><p>3）确定左子空间和右子空间。 分割超平面x=7将整个空间分为两部分：x&lt;=7的部分为左子空间，包含3个节点={(2,3),(5,4),(4,7)}；另一部分为右子空间，包含2个节点={(9,6)，(8,1)}。</p>
</li>
<li><p>4）用同样的办法划分左子树的节点{(2,3),(5,4),(4,7)}和右子树的节点{(9,6)，(8,1)}。最终得到KD树。</p>
<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmgmnn1amuj2062064q2t.jpg" alt="KNN-4.jpg"></p>
</li>
</ul>
<h3 id="2-KD树搜索最近邻"><a href="#2-KD树搜索最近邻" class="headerlink" title="2: KD树搜索最近邻"></a>2: KD树搜索最近邻</h3><p>当我们生成KD树以后，就可以去预测测试集里面的样本目标点了。对于一个目标点，我们首先在KD树里面找到包含目标点的叶子节点。以目标点为圆心，以目标点到叶子节点样本实例的距离为半径，得到一个超球体，最近邻的点一定在这个超球体内部。然后返回叶子节点的父节点，检查另一个子节点包含的超矩形体是否和超球体相交，如果相交就到这个子节点寻找是否有更加近的近邻,有的话就更新最近邻。如果不相交那就简单了，我们直接返回父节点的父节点，在另一个子树继续搜索最近邻。当回溯到根节点时，算法结束，此时保存的最近邻节点就是最终的最近邻。</p>
<p>从上面的描述可以看出，KD树划分后可以大大减少无效的最近邻搜索，很多样本点由于所在的超矩形体和超球体不相交，根本不需要计算距离。大大节省了计算时间。</p>
<p>先进行二叉查找，先从（7,2）查找到（5,4）节点，在进行查找时是由y = 4为分割超平面的，由于查找点为y值为4.5，因此进入右子空间查找到（4,7），形成搜索路径&lt;(7,2)，(5,4)，(4,7)&gt;，但 （4,7）与目标查找点的距离为3.202，而（5,4）与查找点之间的距离为3.041，所以（5,4）为查询点的最近点； 以（2，4.5）为圆心，以3.041为半径作圆，如下图所示。可见该圆和y = 4超平面交割，所以需要进入（5,4）左子空间进行查找，也就是将（2,3）节点加入搜索路径中得&lt;(7,2)，(2,3)&gt;；于是接着搜索至（2,3）叶子节点，（2,3）距离（2,4.5）比（5,4）要近，所以最近邻点更新为（2，3），最近距离更新为1.5；回溯查找至（5,4），直到最后回溯到根结点（7,2）的时候，以（2,4.5）为圆心1.5为半径作圆，并不和x = 7分割超平面交割，如下图所示。至此，搜索路径回溯完，返回最近邻点（2,3），最近距离1.5。</p>
<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmgmnukl6vj20k80cr75i.jpg" alt="KNN-5.jpg"></p>
<h3 id="3-KD树预测"><a href="#3-KD树预测" class="headerlink" title="3: KD树预测"></a>3: KD树预测</h3><p>有了KD树搜索最近邻的办法，KD树的预测就很简单了，在KD树搜索最近邻的基础上，我们选择到了第一个最近邻样本，就把它置为已选。在第二轮中，我们忽略置为已选的样本，重新选择最近邻，这样跑k次，就得到了目标的K个最近邻，然后根据多数表决法，如果是KNN分类，预测为K个最近邻里面有最多类别数的类别。如果是KNN回归，用K个最近邻样本输出的平均值作为回归预测值。</p>
<h2 id="三-球树实现原理"><a href="#三-球树实现原理" class="headerlink" title="(三): 球树实现原理"></a>(三): 球树实现原理</h2><p><strong>KD树和球树类似，主要区别在于球树得到的是节点样本组成的最小超球体，而KD得到的是节点样本组成的超矩形体，这个超球体要与对应的KD树的超矩形体小，这样在做最近邻搜索的时候，可以避免一些无谓的搜索。</strong></p>
<h3 id="1-球树建立"><a href="#1-球树建立" class="headerlink" title="1: 球树建立"></a>1: 球树建立</h3><p>1)  先构建一个超球体，这个超球体是可以包含所有样本的最小球体。</p>
<p>2) 从球中选择一个离球的中心最远的点，然后选择第二个点离第一个点最远，将球中所有的点分配到离这两个聚类中心最近的一个上，然后计算每个聚类的中心，以及聚类能够包含它所有数据点所需的最小半径。这样我们得到了两个子超球体，和KD树里面的左右子树对应。</p>
<p>3) 对于这两个子超球体，递归执行步骤2). 最终得到了一个球树。</p>
<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmgmo2ma1kj20cc07y0sz.jpg" alt="KNN-6.jpg"></p>
<h3 id="2-球树搜索最近邻"><a href="#2-球树搜索最近邻" class="headerlink" title="2: 球树搜索最近邻"></a>2: 球树搜索最近邻</h3><p>使用球树找出给定目标点的最近邻方法是首先自上而下贯穿整棵树找出包含目标点所在的叶子，并在这个球里找出与目标点最邻近的点，这将<strong>确定出目标点距离它的最近邻点的一个上限值</strong>，然后跟KD树查找一样，检查兄弟结点，如果<font color=red>目标点到兄弟结点中心的距离超过兄弟结点的半径与当前的上限值之和</font>，那么兄弟结点里<strong>不可能</strong>存在一个更近的点；<font color=red>如果上诉描述相反,说明有可能存在,也有可能不存在，</font><strong>必须进一步检查位于兄弟结点以下的子树。</strong></p>
<p>检查完兄弟节点后，我们向父节点回溯，继续搜索最小邻近值。当回溯到根节点时，此时的最小邻近值就是最终的搜索结果。</p>
<p>从上面的描述可以看出，<strong>KD树在搜索路径优化时使用的是两点之间的距离来判断，而球树使用的是两边之和大于第三边来判断，相对来说球树的判断更加复杂，但是却避免了更多的搜索，这是一个权衡。</strong></p>
<br>


<h1 id="四-KNN算法的思想总结"><a href="#四-KNN算法的思想总结" class="headerlink" title="四: KNN算法的思想总结"></a>四: KNN算法的思想总结</h1><p>就是在训练集中数据和标签已知的情况下，输入测试数据，将测试数据的特征与训练集中对应的特征进行相互比较，找到训练集中与之最为相似的前K个数据，则该测试数据对应的类别就是K个数据中出现次数最多的那个分类，其算法的描述为：</p>
<ul>
<li><p>计算测试数据与各个训练数据之间的距离；</p>
</li>
<li><p>按照距离的递增关系进行排序；</p>
</li>
<li><p>选取距离最小的K个点；</p>
</li>
<li><p>确定前K个点所在类别的出现频率；</p>
</li>
<li><p>返回前K个点中出现频率最高的类别作为测试数据的预测分类。</p>
</li>
</ul>
<br>


<h1 id="五-KNN算法应用"><a href="#五-KNN算法应用" class="headerlink" title="五: KNN算法应用"></a>五: KNN算法应用</h1><h2 id="一-分类应用"><a href="#一-分类应用" class="headerlink" title="(一): 分类应用"></a>(一): 分类应用</h2><h3 id="1-KNN算法实现鸢尾花分类"><a href="#1-KNN算法实现鸢尾花分类" class="headerlink" title="1: KNN算法实现鸢尾花分类"></a>1: KNN算法实现鸢尾花分类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score   <span class="comment"># 准确率计算</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X, y = datasets.load_iris(<span class="literal">True</span>)   <span class="comment"># True表示只获取数据和目标值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认划分比例是 4:1</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">1024</span>)   <span class="comment"># random_state=1024设置固定的随机</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">5</span>)   <span class="comment"># n_neighbors=5设置k值</span></span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line">y_ = knn.predict(X_test)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'预测值:\n'</span>, y_)</span><br><span class="line">print(<span class="string">'实际值:\n'</span>, y_test)</span><br><span class="line">print(<span class="string">'准确率1:\n'</span>, accuracy_score(y_test, y_))</span><br><span class="line">print(<span class="string">'准确率2:\n'</span>, knn.score(X_test, y_test))</span><br><span class="line">print(<span class="string">'人工准确率:\n'</span>, (y_ == y_test).mean())</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">预测值:</span></span><br><span class="line"><span class="string"> [1 0 2 2 0 0 1 2 1 0 0 0 1 2 2 0 1 0 2 0 2 0 1 0 2 1 2 2 2 2 1 2 2 2 1 2 1</span></span><br><span class="line"><span class="string"> 1]</span></span><br><span class="line"><span class="string">实际值:</span></span><br><span class="line"><span class="string"> [1 0 2 2 0 0 1 2 1 0 0 0 1 2 1 0 1 0 2 0 2 0 1 0 2 1 2 2 2 2 1 2 2 2 1 1 1</span></span><br><span class="line"><span class="string"> 1]</span></span><br><span class="line"><span class="string">准确率1:</span></span><br><span class="line"><span class="string"> 0.9473684210526315</span></span><br><span class="line"><span class="string">准确率2:</span></span><br><span class="line"><span class="string"> 0.9473684210526315</span></span><br><span class="line"><span class="string">人工准确率:</span></span><br><span class="line"><span class="string"> 0.9473684210526315</span></span><br><span class="line"><span class="string"> '''</span></span><br></pre></td></tr></table></figure>





<h3 id="2-KNN算法诊断癌症"><a href="#2-KNN算法诊断癌症" class="headerlink" title="2: KNN算法诊断癌症"></a>2: KNN算法诊断癌症</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">'./cancer.csv'</span>, sep=<span class="string">'\t'</span>)   <span class="comment"># sep='\t'分隔符是table键</span></span><br><span class="line">y = data[<span class="string">'Diagnosis'</span>]</span><br><span class="line">X = data.iloc[:, <span class="number">2</span>:]</span><br><span class="line">display(y.head(), X.head())   <span class="comment"># 细胞的各项指标</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># for循环寻找最准确的k值</span></span><br><span class="line">score = []</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> np.arange(<span class="number">2</span>, <span class="number">16</span>):</span><br><span class="line">    knn = KNeighborsClassifier(n_neighbors=k, weights=<span class="string">'uniform'</span>, algorithm=<span class="string">'kd_tree'</span>)</span><br><span class="line">    <span class="comment"># n_neighbors选取的邻居的数量, 默认为5(一般小于总样本呢量的开平放), 例如 样本数为100, 邻居数量小于10</span></span><br><span class="line">    <span class="comment"># weights='distance'各样本权重的不同(最后计算平均值); weights='uniform'各样本的权重统一(默认)(最后计算平均值)</span></span><br><span class="line">    <span class="comment"># algorithm='kd_tree' 寻找邻居的方式为KD树, algorithm=brute(蛮力-计算所有样本到目标值的距离)</span></span><br><span class="line">    knn.fit(X_train, y_train)</span><br><span class="line">    s = knn.score(X_test, y_test)</span><br><span class="line">    score.append([k,s])</span><br><span class="line">score = pd.DataFrame(score, columns=[<span class="string">'k'</span>, <span class="string">'accuracy'</span>])</span><br><span class="line">print(score)</span><br><span class="line">acc = score[<span class="string">'accuracy'</span>]</span><br><span class="line">index = acc.idxmax()   <span class="comment"># 获取accuracy最大时对应的k值</span></span><br><span class="line">print(<span class="string">'最合适的k数量:'</span>, score[<span class="string">'k'</span>][index])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">     k  accuracy</span></span><br><span class="line"><span class="string">0    2  0.923077</span></span><br><span class="line"><span class="string">1    3  0.916084</span></span><br><span class="line"><span class="string">2    4  0.923077</span></span><br><span class="line"><span class="string">3    5  0.916084</span></span><br><span class="line"><span class="string">4    6  0.937063</span></span><br><span class="line"><span class="string">5    7  0.916084</span></span><br><span class="line"><span class="string">6    8  0.937063</span></span><br><span class="line"><span class="string">7    9  0.937063</span></span><br><span class="line"><span class="string">8   10  0.937063</span></span><br><span class="line"><span class="string">9   11  0.937063</span></span><br><span class="line"><span class="string">10  12  0.937063</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">11  13  0.944056</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">12  14  0.930070</span></span><br><span class="line"><span class="string">13  15  0.937063</span></span><br><span class="line"><span class="string">最合适的邻居数量: 13</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">当k=<span class="number">13</span>时, 预测诊断的效果最好;</span><br></pre></td></tr></table></figure>



<h2 id="二-回归应用"><a href="#二-回归应用" class="headerlink" title="(二): 回归应用"></a>(二): 回归应用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor <span class="comment"># 回归</span></span><br><span class="line"><span class="comment"># 魔法指令，预加载,显示画图(新版本不需要)</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X = np.linspace(<span class="number">0</span>,<span class="number">2</span>*np.pi, <span class="number">60</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)   <span class="comment"># 元数据只是1维的,算法使用的数据的结构必须是二维的</span></span><br><span class="line">X_test = np.linspace(<span class="number">0</span>,<span class="number">2</span>*np.pi, <span class="number">256</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">y = np.sin(X)</span><br><span class="line">plt.scatter(X,y)</span><br><span class="line"></span><br><span class="line">knn = KNeighborsRegressor(weights=<span class="string">'distance'</span>)   </span><br><span class="line"><span class="comment"># distance每个样本的权重不一样, 计算带权重的平均值</span></span><br><span class="line"><span class="comment"># uniform每个样本的权重一样, 计算平均值</span></span><br><span class="line">knn.fit(X, y)</span><br><span class="line">y_ = knn.predict(X_test)</span><br><span class="line">plt.plot(X_test, y_, color=<span class="string">'red'</span>)</span><br><span class="line">plt.scatter(X,y, color=<span class="string">'green'</span>)</span><br></pre></td></tr></table></figure>





<h2 id="三-交叉表"><a href="#三-交叉表" class="headerlink" title="(三): 交叉表"></a>(三): 交叉表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.crosstab(index = y_test, columns=y_, rownames=[<span class="string">'确诊'</span>], colnames=[<span class="string">'预测'</span>],margins=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmgmdeb4a8j21ja0k9jvx.jpg" alt="pandas交叉表.png"></p>
<br>


<h1 id="六-数据预处理"><a href="#六-数据预处理" class="headerlink" title="六: 数据预处理"></a>六: 数据预处理</h1><h2 id="一-数据归一化"><a href="#一-数据归一化" class="headerlink" title="(一): 数据归一化"></a>(一): 数据归一化</h2><h3 id="1-最大值最小值归一化"><a href="#1-最大值最小值归一化" class="headerlink" title="1: 最大值最小值归一化"></a>1: 最大值最小值归一化</h3><p>也称为离差标准化，是对原始数据的线性变换，使结果值映射到[0 - 1]之间。</p>
<p><strong>转换函数如下：</strong><br>$$<br>x_{normalization} = \frac{x - min}{max-min}<br>$$<br><strong>优化上面癌症诊断的例子:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法一: 手写最大值最小值归一化</span></span><br><span class="line">X1 = (X - X.min())/(X.max()-X.min())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二: 直接调用最大值最小值归一化</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler   <span class="comment"># 最小值最大值归一化方法</span></span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line">X1 = scaler.fit_transform(X)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练并诊断(1000次取平均)</span></span><br><span class="line">score = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(X1, y)</span><br><span class="line">    knn = KNeighborsClassifier()</span><br><span class="line">    knn.fit(X_train, y_train)</span><br><span class="line">    score += knn.score(X_test, y_test)/<span class="number">1000</span></span><br><span class="line">print(score)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0.9674265734265755</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">可见,诊断准确率明显提高</span><br></pre></td></tr></table></figure>





<h3 id="2-Z-score归一化"><a href="#2-Z-score归一化" class="headerlink" title="2: Z-score归一化"></a>2: Z-score归一化</h3><p>这种方法给予原始数据的均值（mean）和标准差（standard deviation）进行数据的标准化。经过处理的数据符合标准正态分布，即均值为0，标准差为1</p>
<p>转化函数为：<br>$$<br>x_{normalization} = \frac{x - \mu}{\sigma}<br>$$<br>$\mu$是平均值<br>        $\sigma$是标准差</p>
<p><strong>优化上面癌症诊断的例子:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法一: 手写Z-score归一化</span></span><br><span class="line">X2 = (X - X.mean())/(X.std())   <span class="comment"># std是标准差,求每个属性的平均值</span></span><br><span class="line">X2.std()   <span class="comment"># Z-score归一化返回的结果的标准差是1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二: 调用Z-score归一化</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">X2 = scaler.fit_transform(X)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">score = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(X2, y)</span><br><span class="line">    knn = KNeighborsClassifier()</span><br><span class="line">    knn.fit(X_train, y_train)</span><br><span class="line">    score += knn.score(X_test, y_test)/<span class="number">1000</span></span><br><span class="line">print(score)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0.9649860139860167</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>





<h3 id="3-sigmoid归一化"><a href="#3-sigmoid归一化" class="headerlink" title="3: sigmoid归一化"></a>3: sigmoid归一化</h3><p>转换函数:<br>$$<br>x_{normalization} = \frac{1}{1+e^{-x}}<br>$$<br>代码略</p>
<p>sigmoid函数对本组数据优化效果不好,说明并不适用于本组数据</p>
<h2 id="二-3-sigma剔除异常值"><a href="#二-3-sigma剔除异常值" class="headerlink" title="(二): 3 sigma剔除异常值"></a>(二): 3 sigma剔除异常值</h2><p>原理:<br>$$<br>|𝑋−𝜇|&gt;3𝜎<br>$$</p>
<p>$\mu$是平均值</p>
<p>$\sigma是标准差$</p>
<p>满足以上判断条件的值为异常值</p>
<p><strong>代码实现(剔除异常癌症数据):</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier   <span class="comment"># knn</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler, MinMaxScaler   <span class="comment"># 归一化方法</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line">data = pd.read_csv(<span class="string">'./cancer.csv'</span>, sep=<span class="string">'\t'</span>)</span><br><span class="line">X = data.iloc[:, <span class="number">2</span>:]</span><br><span class="line">y = data.iloc[:, <span class="number">1</span>]</span><br><span class="line"><span class="comment"># 归一化</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">X = scaler.fit_transform(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异常值处理</span></span><br><span class="line"><span class="comment"># 正常值</span></span><br><span class="line">cond = np.abs(X-X.mean(axis=<span class="number">0</span>)) &lt; <span class="number">4</span>*X.std(axis=<span class="number">0</span>)   <span class="comment"># 根据数据调整sigema的系数</span></span><br><span class="line">cond = cond.all(axis=<span class="number">1</span>)  </span><br><span class="line">X1 = X[cond]</span><br><span class="line">y1 = y[cond]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 异常值</span></span><br><span class="line">cond = np.abs(X-X.mean(axis=<span class="number">0</span>)) &gt; <span class="number">4</span>*X.std(axis=<span class="number">0</span>)</span><br><span class="line">cond = cond.any(axis=<span class="number">1</span>)  </span><br><span class="line">X2 = X[cond]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">score = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(X1, y1)</span><br><span class="line">    knn = KNeighborsClassifier()</span><br><span class="line">    knn.fit(X_train, y_train)</span><br><span class="line">    score += knn.score(X_test, y_test)/<span class="number">1000</span></span><br><span class="line">print(<span class="string">'数据清洗后的准确率:'</span>, score)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">数据清洗后的准确率: 0.964276119402978</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>



<p><a href="https://www.cnblogs.com/pinard/p/6061661.html" target="_blank" rel="noopener">借鉴文章 - K近邻法(KNN)原理小结 - 刘建平</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>机器学习</tag>
        <tag>KNN</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>决策树算法</title>
    <url>/2020/03/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一: 概述"></a>一: 概述</h1><p>决策树是附加概率结果的一个树状的决策图，是直观的运用统计概率分析的图法。决策树算法采用树形结构，使用层层推理来实现最终的分类。</p>
<p><strong>决策树的结构:</strong></p>
<p><img src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-09-17-jiegou.png" alt=""></p>
<ul>
<li>根节点：包含样本的全集</li>
<li>内部节点：对应特征属性测试</li>
<li>叶节点：代表决策的结果</li>
</ul>
<p>预测时，在树的内部节点处用某一属性值进行判断，根据判断结果决定进入哪个分支节点，直到到达叶节点处，得到分类结果。</p>
<br>



<h1 id="二-决策树算法"><a href="#二-决策树算法" class="headerlink" title="二: 决策树算法"></a>二: 决策树算法</h1><p>决策树算法中有三种基本算法: <strong>ID3算法,C4.5算法,CART算法(在sklearn中默认是使用CART算法);</strong> </p>
<h2 id="一-ID3算法"><a href="#一-ID3算法" class="headerlink" title="(一): ID3算法"></a>(一): ID3算法</h2><p>ID3算法用<strong>信息增益</strong>来作为<strong>特征选择标准</strong></p>
<p>对熵这个概念还不是很熟悉的童鞋可以借鉴一下<a href="https://www.zhihu.com/people/pwlin/answers" target="_blank" rel="noopener">CyberRep在知乎的回答</a></p>
<p>信息熵表示的是不确定度。均匀分布时，不确定度最大，此时熵就最大。当选择某个特征对数据集进行分类时，分类后的数据集信息熵会比分类前的小，其差值表示为信息增益。信息增益可以衡量某个特征对分类结果的影响大小。</p>
<p><strong>衡量熵值的两个公式:</strong></p>
<p><strong>1: 信息熵公式:</strong><br>$$<br>H(X) = -\sum\limits_{i=1}^n p_ilog_2p_i<br>$$</p>
<p>$$<br>H(X) = \sum\limits_{i=1}^n p_ilog_2 \frac{1}{p_i}<br>$$</p>
<p><strong>联合熵:</strong><br>$$<br>H(X,Y)=−\sum_{i=1}^np(x_i,y_i)logp(x_i,y_i)<br>$$<br><strong>条件熵:</strong></p>
<p>它度量了我们的X在知道Y以后剩下的不确定性<br>$$<br>H(X|Y)=−\sum_{i=1}^np(x_i,y_i)logp(x_i|y_i)=\sum_{j=1}^np(y_j)H(X|y_j)<br>$$<br><strong>用目标值的信息熵   减去   知道属性比例后的目标值   的信息熵</strong></p>
<p><strong>信息增益:</strong><br>$$<br>H(X) - H(X|Y)<br>$$</p>
<p><strong>ID3算法的不足:</strong></p>
<p>第一: 不能处理连续特征</p>
<p>第二: 用信息增益作为标准容易偏向于取值较多的特征</p>
<p>第三: 缺失值处理的问和过拟合问题</p>
<p><strong>举个栗子:</strong></p>
<p>如下图, 三个属性:日志密度, 好友密度, 头像是否真实, 判断账号是否真实</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqkxtn8vcj20go0bqq4a.jpg" alt="熵-1.png" style="zoom: 67%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算最后一栏的熵值(暂时不考虑属性的影响 - 期望信息)</span></span><br><span class="line"><span class="comment"># 3个no,7个yes; </span></span><br><span class="line">H1 = -(<span class="number">0.3</span>*np.log2(<span class="number">0.3</span>)+<span class="number">0.7</span>*np.log2(<span class="number">0.7</span>))</span><br><span class="line">H1</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0.8812908992306927</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算日志密度对期望信息的熵值</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">s -&gt; 个数3 -&gt; 概率0.3 -&gt; 2个no,1个yes  </span></span><br><span class="line"><span class="string">m -&gt; 个数4 -&gt; 概率0.4 -&gt; 1个no,3个yes  </span></span><br><span class="line"><span class="string">i -&gt; 个数3 -&gt; 概率0.3 -&gt; 3个yes  </span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">H2 = (<span class="number">0.3</span>*(<span class="number">2</span>/<span class="number">3</span>*np.log2(<span class="number">3</span>/<span class="number">2</span>)+<span class="number">1</span>/<span class="number">3</span>*np.log2(<span class="number">3</span>))) + (<span class="number">0.4</span>*(<span class="number">1</span>/<span class="number">4</span>*np.log2(<span class="number">4</span>)+<span class="number">3</span>/<span class="number">4</span>*np.log2(<span class="number">4</span>/<span class="number">3</span>))) + (<span class="number">0.3</span>*np.log2(<span class="number">1</span>))</span><br><span class="line">print(H2)</span><br><span class="line">print(<span class="string">'信息增益:'</span>, H1-H2)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0.5999999999999999</span></span><br><span class="line"><span class="string">信息增益: 0.28129089923069284</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算好友密度对期望信息的熵值</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">s -&gt; 个数4 -&gt; 概率0.4 -&gt; 3个no,1个yes  </span></span><br><span class="line"><span class="string">m -&gt; 个数4 -&gt; 概率0.4 -&gt; 4个yes  </span></span><br><span class="line"><span class="string">i -&gt; 个数2 -&gt; 概率0.2 -&gt; 2个yes  </span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">H3 = (<span class="number">0.4</span>*(<span class="number">3</span>/<span class="number">4</span>*np.log2(<span class="number">4</span>/<span class="number">3</span>)+<span class="number">1</span>/<span class="number">4</span>*np.log2(<span class="number">4</span>))) + (<span class="number">0.4</span>*np.log2(<span class="number">1</span>)) + (<span class="number">0.2</span>*np.log2(<span class="number">1</span>))</span><br><span class="line">print(H3)</span><br><span class="line">print(<span class="string">'信息增益:'</span>, H1-H3)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0.32451124978365314</span></span><br><span class="line"><span class="string">信息增益: 0.5567796494470396</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p><font color=red>通过以上例子可以看出: 好友密度的信息增益比日志密度的信息增益大, 所以好友密度这一属性更适合作为根节点</font></p>
<h2 id="二-C4-5算法"><a href="#二-C4-5算法" class="headerlink" title="(二): C4.5算法"></a>(二): C4.5算法</h2><p>C4.5算法用<strong>信息增益比</strong>来作为<strong>特征选择标准</strong><br>$$<br>I_R(D,A)=\frac{I(A,D)}{H_A(D)}<br>$$<br>I(A,D)是信息增益, $H_A(D)$是特征熵<br>$$<br>H_A(D)=−\sum_{i=1}^n\frac{|D_i|}{|D|}log2\frac{|D_i|}{|D|}<br>$$<br>其中n为特征A的类别数， Di为特征A的第i个取值对应的样本个数。|D|为样本个数。</p>
<p><strong>C4.5算法的不足:</strong></p>
<p>模型是用较为复杂的熵来度量</p>
<p>使用了相对较为复杂的多叉树</p>
<p>只能处理分类不能处理回归等</p>
<h2 id="三-CART算法"><a href="#三-CART算法" class="headerlink" title="(三): CART算法"></a>(三): CART算法</h2><p>CART分类树算法使用基尼系数来代替信息增益比，基尼系数代表了模型的不纯度，基尼系数越小，则不纯度越低，特征越好。</p>
<p>具体的，在分类问题中，假设有K个类别，第k个类别的概率为$p_i$, 则基尼系数的表达式为：<br>$$<br>gini = \sum\limits_{i = 1}^np_i(1 - p_i)<br>$$</p>
<p>对于个给定的样本D,假设有K个类别, 第k个类别的数量为$C_k$,则样本D的基尼系数表达式为：<br>$$<br>Gini(D)=1−\sum_{k=1}^K(\frac{|C_k|}{|D|})^2<br>$$</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>支持模型</th>
<th>树结构</th>
<th>特征选择</th>
<th>连续值处理</th>
<th>缺失值处理</th>
<th>剪枝</th>
</tr>
</thead>
<tbody><tr>
<td>ID3</td>
<td>分类</td>
<td>多叉树</td>
<td>信息增益</td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>C4.5</td>
<td>分类</td>
<td>多叉树</td>
<td>信息增益比</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>CART</td>
<td>分类，回归</td>
<td>二叉树</td>
<td>基尼系数，均方差</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<br>



<h1 id="三-建立决策树"><a href="#三-建立决策树" class="headerlink" title="三: 建立决策树"></a>三: 建立决策树</h1><h2 id="一-特征选择"><a href="#一-特征选择" class="headerlink" title="(一): 特征选择"></a>(一): 特征选择</h2><p>特征选择决定了使用哪些特征来做判断。选择一个合适的特征作为判断节点，可以快速的分类，减少决策树的深度。决策树的目标就是把数据集按对应的类标签进行分类。</p>
<p>在训练数据集中，每个样本的属性可能有很多个，不同属性的作用有大有小。因而特征选择的作用就是筛选出跟分类结果相关性较高的特征，也就是分类能力较强的特征。</p>
<h2 id="二-决策树的生成"><a href="#二-决策树的生成" class="headerlink" title="(二): 决策树的生成"></a>(二): 决策树的生成</h2><p>选择好特征后，就从根节点触发，对节点计算所有特征的信息增益，选择信息增益最大的特征作为节点特征，根据该特征的不同取值建立子节点；对每个子节点使用相同的方式生成新的子节点，直到信息增益很小或者没有特征可以选择为止。</p>
<h2 id="三-决策树的修剪"><a href="#三-决策树的修剪" class="headerlink" title="(三): 决策树的修剪"></a>(三): 决策树的修剪</h2><p>决策树生成算法递归地产生决策树，直到不能继续下去未为止。这样产生的树往往对训练数据的分类很准确，但对未知的测试数据的分类却没有那么准确，即出现过拟合现象。过拟合的原因在于学习时过多地考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树。解决这个问题的办法是考虑决策树的复杂度，对已生成的决策树进行简化。</p>
<br>



<h1 id="四-决策树分类和回归"><a href="#四-决策树分类和回归" class="headerlink" title="四: 决策树分类和回归"></a>四: 决策树分类和回归</h1><table>
<thead>
<tr>
<th>参数</th>
<th>DecisionTreeClassifier</th>
<th>DecisionTreeRegressor</th>
</tr>
</thead>
<tbody><tr>
<td>特征选择标准criterion</td>
<td>可以使用”gini”或者”entropy”，前者代表基尼系数，后者代表信息增益。一般说使用默认的基尼系数”gini”就可以了，即CART算法。除非你更喜欢类似ID3, C4.5的最优特征选择方法。</td>
<td>可以使用”mse”或者”mae”，前者是均方差，后者是和均值之差的绝对值之和。推荐使用默认的”mse”。一般来说”mse”比”mae”更加精确。除非你想比较二个参数的效果的不同之处。</td>
</tr>
<tr>
<td>特征划分点选择标准splitter</td>
<td>可以使用”best”或者”random”。前者在特征的所有划分点中找出最优的划分点。后者是随机的在部分划分点中找局部最优的划分点。默认的”best”适合样本量不大的时候，而如果样本数据量非常大，此时决策树构建推荐”random”</td>
<td></td>
</tr>
<tr>
<td>划分时考虑的最大特征数max_features</td>
<td>可以使用很多种类型的值，默认是”None”,意味着划分时考虑所有的特征数；如果是”log2”意味着划分时最多考虑log2Nlog2N个特征；如果是”sqrt”或者”auto”意味着划分时最多考虑N−−√N个特征。如果是整数，代表考虑的特征绝对数。如果是浮点数，代表考虑特征百分比，即考虑（百分比xN）取整后的特征数。其中N为样本总特征数。一般来说，如果样本特征数不多，比如小于50，我们用默认的”None”就可以了，如果特征数非常多，我们可以灵活使用刚才描述的其他取值来控制划分时考虑的最大特征数，以控制决策树的生成时间。</td>
<td></td>
</tr>
<tr>
<td>决策树最大深max_depth</td>
<td>决策树的最大深度，默认可以不输入，如果不输入的话，决策树在建立子树的时候不会限制子树的深度。一般来说，数据少或者特征少的时候可以不管这个值。如果模型样本量多，特征也多的情况下，推荐限制这个最大深度，具体的取值取决于数据的分布。常用的可以取值10-100之间。</td>
<td></td>
</tr>
<tr>
<td>内部节点再划分所需最小样本数min_samples_split</td>
<td>这个值限制了子树继续划分的条件，如果某节点的样本数少于min_samples_split，则不会继续再尝试选择最优特征来进行划分。 默认是2.如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。我之前的一个项目例子，有大概10万样本，建立决策树时，我选择了min_samples_split=10。可以作为参考。</td>
<td></td>
</tr>
<tr>
<td>叶子节点最少样本数min_samples_leaf</td>
<td>这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。 默认是1,可以输入最少的样本数的整数，或者最少样本数占样本总数的百分比。如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。之前的10万样本项目使用min_samples_leaf的值为5，仅供参考。</td>
<td></td>
</tr>
<tr>
<td>叶子节点最小的样本权重和min_weight_fraction_leaf</td>
<td>这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝。 默认是0，就是不考虑权重问题。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。</td>
<td></td>
</tr>
<tr>
<td>最大叶子节点数max_leaf_nodes</td>
<td>通过限制最大叶子节点数，可以防止过拟合，默认是”None”，即不限制最大的叶子节点数。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。如果特征不多，可以不考虑这个值，但是如果特征分成多的话，可以加以限制，具体的值可以通过交叉验证得到。</td>
<td></td>
</tr>
<tr>
<td>类别权重class_weight</td>
<td>指定样本各类别的的权重，主要是为了防止训练集某些类别的样本过多，导致训练的决策树过于偏向这些类别。这里可以自己指定各个样本的权重，或者用“balanced”，如果使用“balanced”，则算法会自己计算权重，样本量少的类别所对应的样本权重会高。当然，如果你的样本类别分布没有明显的偏倚，则可以不管这个参数，选择默认的”None”</td>
<td>不适用于回归树</td>
</tr>
<tr>
<td>节点划分最小不纯度min_impurity_split</td>
<td>这个值限制了决策树的增长，如果某节点的不纯度(基尼系数，信息增益，均方差，绝对差)小于这个阈值，则该节点不再生成子节点。即为叶子节点 。</td>
<td></td>
</tr>
<tr>
<td>数据是否预排序presort</td>
<td>这个值是布尔值，默认是False不排序。一般来说，如果样本量少或者限制了一个深度很小的决策树，设置为true可以让划分点选择更加快，决策树建立的更加快。如果样本量太大的话，反而没有什么好处。问题是样本量少的时候，我速度本来就不慢。所以这个值一般懒得理它就可以了。</td>
<td></td>
</tr>
</tbody></table>
<br>



<h1 id="五-决策树应用"><a href="#五-决策树应用" class="headerlink" title="五: 决策树应用"></a>五: 决策树应用</h1><h2 id="一-葡萄酒分类"><a href="#一-葡萄酒分类" class="headerlink" title="(一): 葡萄酒分类"></a>(一): 葡萄酒分类</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets, tree</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wine = datasets.load_wine()</span><br><span class="line">X = wine[<span class="string">'data'</span>]</span><br><span class="line">y = wine[<span class="string">'target'</span>]</span><br><span class="line"></span><br><span class="line">s1 = <span class="number">0</span></span><br><span class="line">s2 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">300</span>):</span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(X, y)</span><br><span class="line">    model = DecisionTreeClassifier(max_depth=<span class="number">5</span>)</span><br><span class="line">    model.fit(X_train, y_train)</span><br><span class="line">    s1 +=  model.score(X_train, y_train)/<span class="number">300</span></span><br><span class="line">    s2 += model.score(X_test, y_test)/<span class="number">300</span></span><br><span class="line">print(<span class="string">'训练准确度:'</span>, s1)</span><br><span class="line">print(<span class="string">'测试准确度:'</span>, s2)</span><br><span class="line">_ = tree.plot_tree(model, filled=<span class="literal">True</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">训练准确度: 0.9989473684210486</span></span><br><span class="line"><span class="string">测试准确度: 0.9063703703703709</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqkyel2sfj21840vugoj.jpg" alt="决策树-葡萄酒分类.jpg" style="zoom: 40%;" />

<h2 id="二-决策树回归"><a href="#二-决策树回归" class="headerlink" title="(二): 决策树回归"></a>(二): 决策树回归</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets, tree</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X = np.linspace(<span class="number">0</span>,<span class="number">2</span>*np.pi, <span class="number">40</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>)   <span class="comment"># 将数据变为二维数据</span></span><br><span class="line">y = np.c_[np.sin(X), np.cos(X)]   <span class="comment"># 蒋两张数据组合</span></span><br><span class="line">X_test = np.linspace(<span class="number">0</span>,<span class="number">2</span>*np.pi, <span class="number">187</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = DecisionTreeRegressor(criterion=<span class="string">'mse'</span>, max_depth=<span class="literal">None</span>)   <span class="comment"># 当max_depth=1, 画出来的图像只有两个点</span></span><br><span class="line">model.fit(X,y)   <span class="comment"># X有40个点</span></span><br><span class="line">y_ = model.predict(X_test)   <span class="comment"># X_test是187个点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">3</span>,<span class="number">3</span>))   <span class="comment"># 调节尺寸</span></span><br><span class="line">plt.scatter(y[:,<span class="number">0</span>], y[:,<span class="number">1</span>])   <span class="comment"># 绘制散点图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">12</span>))</span><br><span class="line">_ = tree.plot_tree(model, filled=<span class="literal">True</span>)   <span class="comment"># 绘制决策树</span></span><br><span class="line">plt.savefig(<span class="string">'./regrece.pdf'</span>, dpi=<span class="number">1024</span>)   <span class="comment"># 保存决策树为pdf</span></span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqkz1v5oyj20dz0a974d.jpg" alt="决策树-正弦余弦.jpg"></p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqkz8nnuhj211v0w576b.jpg" alt="决策树-正弦余弦回归树.jpg" style="zoom: 50%;" />

<p><a href="https://www.cnblogs.com/pinard/p/6053344.html" target="_blank" rel="noopener">借鉴文章 - 决策树算法原理(下) - 刘建平</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>算法</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归二</title>
    <url>/2018/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%B2%AD%E5%9B%9E%E5%BD%92(Ridge)%E5%92%8C%E5%A5%97%E7%B4%A2%E5%9B%9E%E5%BD%92(Lasso)/</url>
    <content><![CDATA[<h2 id="一-拟合"><a href="#一-拟合" class="headerlink" title="一: 拟合"></a>一: 拟合</h2><h3 id="一-过拟合与欠拟合"><a href="#一-过拟合与欠拟合" class="headerlink" title="(一): 过拟合与欠拟合"></a>(一): 过拟合与欠拟合</h3><p><strong>机器学习中一个重要的话题便是模型的泛化能力，泛化能力强的模型才是好模型</strong>，对于训练好的模型，若在训练集表现差，不必说在测试集表现同样会很差，这可能是欠拟合导致；若模型在训练集表现非常好，却在测试集上差强人意，则这便是过拟合导致的; 过拟合与欠拟合也可以用 Bias 与 Variance 的角度来解释，<strong>欠拟合会导致高 Bias; 过拟合会导致高 Variance ，所以模型需要在 Bias 与 Variance 之间做出一个权衡</strong></p>
<p><strong>Bias 即为模型的期望输出与其真实输出之间的差异</strong>；</p>
<p><strong>Variance 刻画了不同训练集得到的模型的输出与这些模型期望输出的差异</strong>。</p>
<p>一般在模型效果差的第一个想法是增多数据，其实增多数据并不一定会有更好的结果，因为<strong>欠拟合时增多数据往往导致效果更差，而过拟合时增多数据会导致 Gap 的减小，效果不会好太多</strong>，所以当模型效果很差时，应该检查模型是否处于欠拟合或者过拟合的状态，而不要一味的增多数据量，关于过拟合与欠拟合，这里给出几个解决方法。</p>
<h3 id="二-常用解决办法"><a href="#二-常用解决办法" class="headerlink" title="(二): 常用解决办法"></a>(二): 常用解决办法</h3><p><strong>(1)解决欠拟合的方法：</strong></p>
<p>1、增加新特征，可以考虑加入进特征组合、高次特征，来增大假设空间;</p>
<p>2、尝试非线性模型，比如核SVM 、决策树、DNN等模型;</p>
<p>3、如果有正则项可以调小正则项参数 $\lambda$;</p>
<p>4、Boosting ,Boosting 往往会有较小的 Bias，比如 Gradient Boosting 等.</p>
<p><strong>(2)解决过拟合的方法：</strong></p>
<p>1、交叉检验，通过交叉检验得到较优的模型参数;</p>
<p>2、特征选择，减少特征数或使用较少的特征组合，对于按区间离散化的特征，增大划分的区间;</p>
<p>3、正则化，常用的有 L1、L2 正则。而且 L1正则还可以自动进行特征选择;</p>
<p>4、如果有正则项则可以考虑增大正则项参数 lambda;</p>
<p>5、增加训练数据可以有限的避免过拟合;</p>
<p>6、Bagging ,将多个弱学习器Bagging 一下效果会好很多，比如随机森林等.</p>
<h2 id="二-Ridge回归-岭回归"><a href="#二-Ridge回归-岭回归" class="headerlink" title="二: Ridge回归 - 岭回归"></a>二: Ridge回归 - 岭回归</h2><h3 id="1-Ridge回归-梯度下降-在线性回归后加上L2正则项-解决过拟合问题"><a href="#1-Ridge回归-梯度下降-在线性回归后加上L2正则项-解决过拟合问题" class="headerlink" title="1: Ridge回归 - 梯度下降(在线性回归后加上L2正则项-解决过拟合问题)"></a>1: Ridge回归 - 梯度下降(在线性回归后加上L2正则项-解决过拟合问题)</h3><p><strong>损失函数:</strong><br>$$<br>J(w) = \min\limits_w||Xw-y||_2^2 + \alpha||w||_2^2<br>$$</p>
<p><strong>$$\frac{1}{m}$$表示m个样本求平均:</strong><br>$$<br>J(w) = \frac{1}{m}\sum_{i=1}^m(||X_iw-y_i||_2^2 + \alpha||w||_2^2)<br>$$</p>
<p>$$<br>J(w) = \frac{1}{m}[(Xw-y)^T(Xw-y)+\alpha w^Tw]<br>$$</p>
<p><strong>求解梯度(导数):</strong><br>$$<br>J’(w) = \frac{2}{m}[X^T(Xw-y)+\alpha w]<br>$$</p>
<p>$$<br>\nabla_wJ(w) = \frac{2}{m} [X^T(Xw - y) +\alpha w]<br>$$</p>
<p><strong>更新w:</strong><br>$$<br>w = w-\epsilon \nabla_wJ(w)<br>$$</p>
<p>$$<br>w = w -\frac{2}{m}\epsilon[X^T(Xw-y)+\alpha w]<br>$$</p>
<p>$$<br>w = w -\frac{2\epsilon}{m}  X^T(Xw-y)-\frac{2\alpha\epsilon}{m}  w<br>$$</p>
<p>$$<br>w = [w -\frac{2\epsilon}{m}  X^T(Xw-y)]-\frac{2\alpha\epsilon}{m}  w<br>$$</p>
<p>如上公式, 中括号内的公式是线性回归的更新规则, 也就是说岭回归就是在 线性回归的基础上多减了一项,$$\frac{2\alpha\epsilon}{m}  w$$, 其</p>
<p>中:</p>
<p>​        $$\alpha &gt;= 0$$缩放强度</p>
<p>​        $$\epsilon&gt;=0$$步幅</p>
<p>​        $$m&gt;0$$样本数量</p>
<p>当w是<font color = red>正数</font>时：$$\frac{2\epsilon\alpha}{m}w$$ 为正数,此时岭回归就相当于在线性回归的基础上减去一个正数, 所以<font color = red>系数w变小</font></p>
<p>当w是<font color = red>负数</font>时：$$\frac{2\epsilon\alpha}{m}w$$ 为负数,此时岭回归就相当于在线性回归的基础上减去一个负数, 所以<font color = red>系数w的绝对值变小</font></p>
<p>正则项：w变小的好处：<font color = red>防止过拟合</font></p>
<p>岭回归适用范围:</p>
<p>方程完全共线性(方程内有方程是其他方程的倍数,相当于重复方程):</p>
<ul>
<li>x+ 2y + 22 = 9</li>
<li>2x +4y + 42 = 18</li>
</ul>
<p>岭回归适用于数据中存在共线性的情况(非满秩矩阵)</p>
<h3 id="2-Ridge回归正规方程推导"><a href="#2-Ridge回归正规方程推导" class="headerlink" title="2: Ridge回归正规方程推导:"></a>2: Ridge回归正规方程推导:</h3><p>损失函数:<br>$$<br>J(w) = \min\limits_w||Xw-y||_2^2 + \alpha||w||_2^2<br>$$</p>
<p>$$<br>J(w)=(Xw-y)^T(Xw-y)+\alpha w^Tw<br>$$</p>
<p>求导:<br>$$<br>\nabla_wJ(w)=2X^TXw-2X^Ty+2\alpha w<br>$$<br>令导数为0:<br>$$<br>2X^TXw-2X^Ty+2\alpha w=0<br>$$</p>
<p>$$<br>X^TXw-X^Ty+\alpha Iw=0<br>$$</p>
<p>$$<br>(X^TX+\alpha I)w-X^Ty=0<br>$$</p>
<p>$$<br>(X^TX+\alpha I)w=X^Ty<br>$$</p>
<p>$$<br>(X^TX+\alpha I)^{-1}(X^TX+\alpha I)w=(X^TX+\alpha I)^{-1}X^Ty<br>$$</p>
<p>推导得出w:<br>$$<br>w=(X^TX+\alpha I)^{-1}X^Ty<br>$$</p>
<h3 id="3-Ridge回归和线性回归对比"><a href="#3-Ridge回归和线性回归对比" class="headerlink" title="3: Ridge回归和线性回归对比"></a>3: Ridge回归和线性回归对比</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression, Ridge, Lasso</span><br><span class="line"><span class="comment"># 将数据一分为二</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="comment"># 均方误差</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line"><span class="comment"># 加载训练数据</span></span><br><span class="line"><span class="comment"># train = pd.read_table('./zhengqi_train.txt') 和下面一行的效果相同</span></span><br><span class="line">train = pd.read_csv(<span class="string">'./zhengqi_train.txt'</span>, sep = <span class="string">'\t'</span>)</span><br><span class="line">train</span><br><span class="line"><span class="comment"># 加载测试数据</span></span><br><span class="line">test = pd.read_table(<span class="string">'./zhengqi_test.txt'</span>)</span><br><span class="line">test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将训练数据分乘特征值和目标值</span></span><br><span class="line"><span class="comment"># 特征, 影响目标值的因素</span></span><br><span class="line">X = train.iloc[:, :<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># 目标值</span></span><br><span class="line">y = train[<span class="string">'target'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 算法评估, 将上面的数据分成两份,一部分用来训练, 一部分用来测试</span></span><br><span class="line">X_train, X_validation, y_train, y_validation = train_test_split(X, y, test_size = <span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用普通线性回归模型</span></span><br><span class="line">linear = LinearRegression()</span><br><span class="line">linear.fit(X_train, y_train)</span><br><span class="line">y_ = linear.predict(X_validation)</span><br><span class="line">mean_squared_error(y_validation,y_)   <span class="comment"># 均方误差</span></span><br><span class="line"><span class="string">'''0.11713370444738197'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用线性模型预测测试数据</span></span><br><span class="line">y_commit = linear.predict(test)</span><br><span class="line"><span class="comment"># 保存数据到本地</span></span><br><span class="line">s = pd.Series(y_commit)</span><br><span class="line">s.to_csv(<span class="string">'./linear_result.txt'</span>, index=<span class="literal">False</span>, header = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用岭回归模型</span></span><br><span class="line">ridge = Ridge(alpha=<span class="number">256</span>)   <span class="comment"># alpha值</span></span><br><span class="line">ridge.fit(X_train, y_train)</span><br><span class="line">y_ = ridge.predict(X_validation)</span><br><span class="line">mean_squared_error(y_validation,y_)</span><br><span class="line"><span class="string">'''0.13427749653218798'''</span></span><br><span class="line"></span><br><span class="line">y_commit = ridge.predict(test)</span><br><span class="line">pd.Series(y_commit).to_csv(<span class="string">'./ridge_result.txt'</span>, index=<span class="literal">False</span>, header = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p><font color=red>将生成的数据上传到阿里天池,与实际数据对比,计算均方误差时, 使用岭回归模型得到的数据比使用线性回归模型得到的数据的均方误差要小,说明对该组数据,岭回归效果更好</font></p>
<h2 id="三-lasso回归-套索回归"><a href="#三-lasso回归-套索回归" class="headerlink" title="三: lasso回归 - 套索回归"></a>三: lasso回归 - 套索回归</h2><h3 id="1-lasso回归-梯度下降-在线性回归后加上L1正则项-解决过拟合问题"><a href="#1-lasso回归-梯度下降-在线性回归后加上L1正则项-解决过拟合问题" class="headerlink" title="1: lasso回归 - 梯度下降(在线性回归后加上L1正则项-解决过拟合问题)"></a>1: lasso回归 - 梯度下降(在线性回归后加上L1正则项-解决过拟合问题)</h3><p><strong>罗斯回归方程:</strong><br>$$<br>\min\limits_w \frac{1}{2n_{samples}}||Xw-y||_2^2+\alpha ||w||_1<br>$$<br><strong>方程转换:</strong><br>$$<br>J(w)=||Xw-y||_2^2+\alpha ||w||_1<br>$$<br>向量的1范数: 取绝对值的最大值</p>
<p>由于求导时方程中不能有绝对值符号, 所以分情况讨论: w是正数或者为负数</p>
<p><strong>求导:</strong><br>$$<br>\nabla_wJ(w)=2X^TXw-2X^Ty+\alpha sgn(w)<br>$$<br>sgn(w)是符号表示函数: sgn(w)代表着w&gt;0那么sgn(w)=+1;如果w&lt;0那么sgn(W)=-1</p>
<p><strong>梯度下降中系数w的更新规则:</strong><br>$$<br>w = w - \epsilon \nabla_wJ(w)<br>$$</p>
<p>$$<br>w = w - \epsilon(X^TXw-X^Ty)-\epsilon \alpha sgn(w)<br>$$</p>
<p>$$<br>w = [w - \epsilon(X^TXw-X^Ty)]-\epsilon \alpha sgn(w)<br>$$</p>
<p>当w为正时候sgn(w) =+1,直接去掉减去入所以正的w变小了</p>
<p>当w为负时候sgn(w)=-1,负号变成了正号加上了入,负数w取向零</p>
<p>Lasso回归系数可以缩减到0,岭回归不可以</p>
<p>系数(权重)变成0了,说明:可有可无,属性不重要</p>
<h3 id="2-lasso回归与岭回归和线性回归对比"><a href="#2-lasso回归与岭回归和线性回归对比" class="headerlink" title="2: lasso回归与岭回归和线性回归对比"></a>2: lasso回归与岭回归和线性回归对比</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression, Ridge, Lasso</span><br><span class="line"><span class="comment"># 将数据一分为二</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="comment"># 均方误差</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line"><span class="comment"># 加载训练数据</span></span><br><span class="line"><span class="comment"># train = pd.read_table('./zhengqi_train.txt') 和下面一行的效果相同</span></span><br><span class="line">train = pd.read_csv(<span class="string">'./zhengqi_train.txt'</span>, sep = <span class="string">'\t'</span>)</span><br><span class="line">train</span><br><span class="line"><span class="comment"># 加载测试数据</span></span><br><span class="line">test = pd.read_table(<span class="string">'./zhengqi_test.txt'</span>)</span><br><span class="line">test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将训练数据分乘特征值和目标值</span></span><br><span class="line"><span class="comment"># 特征, 影响目标值的因素</span></span><br><span class="line">X = train.iloc[:, :<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># 目标值</span></span><br><span class="line">y = train[<span class="string">'target'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 算法评估, 将上面的数据分成两份,一部分用来训练, 一部分用来测试</span></span><br><span class="line">X_train, X_validation, y_train, y_validation = train_test_split(X, y, test_size = <span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用普通线性回归模型</span></span><br><span class="line">linear = LinearRegression()</span><br><span class="line">linear.fit(X_train, y_train)</span><br><span class="line">y_ = linear.predict(X_validation)</span><br><span class="line">mean_squared_error(y_validation,y_)   <span class="comment"># 均方误差</span></span><br><span class="line"><span class="string">'''0.11713370444738197'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用线性模型预测测试数据</span></span><br><span class="line">y_commit = linear.predict(test)</span><br><span class="line"><span class="comment"># 保存数据到本地</span></span><br><span class="line">s = pd.Series(y_commit)</span><br><span class="line">s.to_csv(<span class="string">'./linear_result.txt'</span>, index=<span class="literal">False</span>, header = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用岭回归模型</span></span><br><span class="line">ridge = Ridge(alpha=<span class="number">256</span>)   <span class="comment"># alpha值</span></span><br><span class="line">ridge.fit(X_train, y_train)</span><br><span class="line">y_ = ridge.predict(X_validation)</span><br><span class="line">mean_squared_error(y_validation,y_)</span><br><span class="line"><span class="string">'''0.13427749653218798'''</span></span><br><span class="line"></span><br><span class="line">y_commit = ridge.predict(test)</span><br><span class="line">pd.Series(y_commit).to_csv(<span class="string">'./ridge_result.txt'</span>, index=<span class="literal">False</span>, header = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用lasso回归模型</span></span><br><span class="line">lasso = Lasso(alpha=<span class="number">256</span>)</span><br><span class="line">lasso.fit(X_train, y_train)</span><br><span class="line">y_ = lasso.predict(X_validation)</span><br><span class="line">mean_squared_error(y_validation,y_)</span><br><span class="line"><span class="string">'''0.9351911263395224'''</span></span><br><span class="line"></span><br><span class="line">y_commit = lasso.predict(test)</span><br><span class="line">pd.Series(y_commit).to_csv(<span class="string">'./lasso_result.txt'</span>, index=<span class="literal">False</span>, header = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p><font color=red>将生成的数据上传到阿里天池,与实际数据对比,计算均方误差时, 使用lasso回归模型得到的数据比使用岭回归模型和线性回归模型得到的数据的均方误差要小,说明对该组数据,lasso回归效果较好好</font></p>
<p><font color=green>套索回归适用于稀松矩阵(大部分系数是0)</font></p>
<h2 id="四-Elastic-Net-弹性网络回归"><a href="#四-Elastic-Net-弹性网络回归" class="headerlink" title="四: Elastic-Net  -  弹性网络回归"></a>四: Elastic-Net  -  弹性网络回归</h2><p><strong>弹性网络回归方程:</strong><br>$$<br>\min_{w} { \frac{1}{2n_{\text{samples}}} ||X w - y||_2 ^ 2 + \alpha \rho ||w||_1 +<br>\frac{\alpha(1-\rho)}{2} ||w||_2 ^ 2}<br>$$</p>
<p><strong>使用弹性网络回归预测工业蒸汽量:(在线性回归后加L1, L2正则项来解决过拟合问题)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># ElasticNetCV 交叉验证(可以一次传递多个参数, 模型挑选合适的)</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression, Ridge, ElasticNet, ElasticNetCV</span><br><span class="line"><span class="comment"># 将数据一分为二</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="comment"># 均方误差</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line"><span class="comment"># 加载训练数据</span></span><br><span class="line"><span class="comment"># train = pd.read_table('./zhengqi_train.txt') 和下面一行的效果相同</span></span><br><span class="line">train = pd.read_csv(<span class="string">'./zhengqi_train.txt'</span>, sep = <span class="string">'\t'</span>)</span><br><span class="line">train</span><br><span class="line"><span class="comment"># 加载测试数据</span></span><br><span class="line">test = pd.read_table(<span class="string">'./zhengqi_test.txt'</span>)</span><br><span class="line">test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将训练数据分乘特征值和目标值</span></span><br><span class="line"><span class="comment"># 特征, 影响目标值的因素</span></span><br><span class="line">X = train.iloc[:, :<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># 目标值</span></span><br><span class="line">y = train[<span class="string">'target'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 算法评估, 将上面的数据分成两份,一部分用来训练, 一部分用来测试</span></span><br><span class="line"><span class="comment"># random_state = 1024 ; 种子固定,当数值固定时,生成的随机数是固定的</span></span><br><span class="line">X_train, X_validation, y_train, y_validation = train_test_split(X, y, test_size = <span class="number">0.2</span>, random_state = <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ElasticNetCV可以筛选多个alpha中最好的一个</span></span><br><span class="line">model = ElasticNetCV(l1_ratio=<span class="number">0.05</span>, alphas=[<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">5.0</span>, <span class="number">10.0</span>])</span><br><span class="line">model.fit(X, y)</span><br><span class="line">y_ = model.predict(X_validation)</span><br><span class="line">mean_squared_error(y_validation,y_)</span><br><span class="line"><span class="string">'''0.10872462328271233'''</span></span><br><span class="line"></span><br><span class="line">model.alpha_   <span class="comment"># 返回选择的alpha值</span></span><br><span class="line"></span><br><span class="line">result = model.predict(test)</span><br><span class="line">pd.Series(result).to_csv(<span class="string">'./elastic.txt'</span>, index=<span class="literal">False</span>, header=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
        <tag>Lasso回归</tag>
        <tag>Ridge回归</tag>
      </tags>
  </entry>
  <entry>
    <title>支持向量机（SVM）</title>
    <url>/2020/03/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="一-SVM-支持向量机-概述"><a href="#一-SVM-支持向量机-概述" class="headerlink" title="一: SVM(支持向量机)概述"></a>一: SVM(支持向量机)概述</h1><p><strong>先来一段维基百科的定义:</strong></p>
<p>在机器学习中，支持向量机（英语：support vector machine，常简称为SVM，又名支持向量网络）是在分类与回归分析中分析数据的监督式学习模型与相关的学习算法。给定一组训练实例，每个训练实例被标记为属于两个类别中的一个或另一个，SVM训练算法创建一个将新的实例分配给两个类别之一的模型，使其成为<strong>非概率二元线性分类器</strong>。SVM模型是将实例表示为空间中的点，这样映射就使得单独类别的实例被尽可能宽的明显的间隔分开。然后，将新的实例映射到同一空间，并基于它们落在间隔的哪一侧来预测所属类别。</p>
<p>除了进行线性分类之外，SVM还可以使用所谓的核技巧有效地进行非线性分类，将其输入隐式映射到高维特征空间中。</p>
<br>





<h1 id="二-SVM原理"><a href="#二-SVM原理" class="headerlink" title="二: SVM原理"></a>二: SVM原理</h1><h2 id="一-工作原理"><a href="#一-工作原理" class="headerlink" title="(一): 工作原理"></a>(一): 工作原理</h2><h3 id="1-硬间隔"><a href="#1-硬间隔" class="headerlink" title="1: 硬间隔"></a>1: 硬间隔</h3><p>现在有两种类别的数据需要分类, 如下图:</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqk3hnm1bj20fk0gnt8p.jpg" alt="支持向量机工作原理1.png" style="zoom:50%;" />



<p>要想将这两类数据分开, 可以说是轻而易举, 只需要这样:</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqk3wqzhkj20fk0gnjrj.jpg" alt="支持向量机工作原理2.png" style="zoom:50%;" />



<p>但是这样分类的方式(线条)有很多, 而支持向量机这个算法是追求完美的,  他想要的效果不仅仅是将数据分开, 还要找到一个最佳的分类’位置’进行黄金分割, 就像这样: </p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqk454iypj20fk0gn0t0.jpg" alt="支持向量机工作原理3.png" style="zoom:50%;" />

<p>每一个可能把数据集正确分开的方向都有一个最优决策面（<strong>有些方向无论如何移动决策面的位置也不可能将两类样本完全分开</strong>），而不同方向的最优决策面的分类间隔通常是不同的，那个具有“最大间隔”的决策面就是SVM要寻找的最优解。</p>
<blockquote>
<p> 直观上看，应该去找位于两类训练样本“正中间”的划分超平面，因为该划分超平面对训练样本局部扰动的“容忍”性最好.例如，由于训练集的局限性或噪声的因素，训练集外的样本可能比训练样本更接近两个类的分隔界，这将使许多划分超平面出现错误，而“正中间”的划分超平面受影响最小.换言之，这个划分超平面所产生的分类结果是最鲁棒的，对未见示例的泛化能力最强.</p>
</blockquote>
<p>这是无数条可以分类的直线当中最完美的，因为它恰好在两个类的中间，<font color=red><strong>距离两个类的点都一样远, 同时他还是这两个类别之间间隔最大的线性分类器; 换句话说: 这个分类器对每个类别最近的元素距离最远.</strong></font></p>
<p>而在高维空间中对于支持向量机来说，<strong>数据点若是p维向量，我们用p−1维的超平面来分开这些点。</strong>但是可能有许多超平面可以把数据分类。最佳超平面的一个合理选择就是以最大间隔把两个类分开的超平面。因此，SVM选择能够使离超平面最近的数据点的到超平面距离最大的超平面。</p>
<h3 id="2-软间隔"><a href="#2-软间隔" class="headerlink" title="2: 软间隔"></a>2: 软间隔</h3><p>在实际应用中，完全线性可分的样本是很少的，我们会遇到不能够完全线性可分的样本，于是我们就有了软间隔，相比于硬间隔的苛刻条件，我们允许个别样本点出现在间隔带里面，比如：</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqk4h23edj20eo09wmy8.jpg" alt="支持向量机工作原理5.png" style="zoom: 80%;" />

<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqk63bzwnj22240l8gyt.jpg" alt="支持向量机算法原理4.png"></p>
<h3 id="3-非线性"><a href="#3-非线性" class="headerlink" title="3: 非线性"></a>3: 非线性</h3><p>还有一种非线性情况, 比如下面这个:</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqk6fmj66j20i90ge74b.jpg" alt="支持向量机工作原理4.png" style="zoom:50%;" />



<p>这个时候, 我们就需要引入我们的三维空间了, 没错将数据上升一个维度, 就能轻松将数据分开, 如下图:</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqkdu2tb4j21mo0mq16f.jpg" alt="支持向量机算法原理5.png" style="zoom: 50%;" />







<p>为了解决更加复杂的问题，支持向量机学习方法有一些由简至繁的模型:</p>
<ul>
<li><p><strong>线性可分SVM</strong><br>当训练数据线性可分时，通过<strong>硬间隔(hard margin)</strong>最大化可以学习得到一个线性分类器，即硬间隔SVM。</p>
</li>
<li><p><strong>线性SVM</strong><br>当训练数据不能线性可分但是可以近似线性可分时，通过<strong>软间隔(soft margin)</strong>最大化也可以学习到一个线性分类器，即软间隔SVM。</p>
</li>
<li><p><strong>非线性SVM</strong><br>当训练数据线性不可分时，通过使用<strong>核技巧(kernel trick)和软间隔最大化</strong>，可以学习到一个非线性SVM。</p>
</li>
</ul>
<br>



<h2 id="二-算法原理"><a href="#二-算法原理" class="headerlink" title="(二): 算法原理"></a>(二): 算法原理</h2><p><strong>SVM学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。</strong></p>
<p>但实际上最优决策面的方向和位置完全取决于选择哪些样本作为支持向量。而在经过漫长的公式推导后，你最终会发现，其实与线性决策面的方向和位置直接相关的参数都会被约减掉，最终结果只取决于样本点的选择结果。</p>
<h3 id="1-线性可分SVM—硬间隔"><a href="#1-线性可分SVM—硬间隔" class="headerlink" title="1: 线性可分SVM—硬间隔"></a>1: 线性可分SVM—硬间隔</h3><h4 id="1-目标函数-类别之间的间隔"><a href="#1-目标函数-类别之间的间隔" class="headerlink" title="(1): 目标函数(类别之间的间隔)"></a>(1): 目标函数(类别之间的间隔)</h4><p>如图所示:</p>
<p>我们给出样本 $(x_i, y_i)$ , 类别标签为 $ y_i \in {-1, 1}$</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqkeeupq7j20pm0mkab2.jpg" alt="支持向量机算法原理1.png" style="zoom:50%;" />



<p><strong>向量 $\vec W = [w_1, w_2]^T$ 与直线 $\vec W^Tx + b = 0$ 是相互垂直的</strong> ()</p>
<p>在上图中,  向量 $\vec W$ 是决策面的法向量,  那么决策面的方程就能表示成: $\vec W^T x + b = 0$</p>
<p>正例满足: $ \vec W^T x + b \ge 1$</p>
<p>负例满足: $ \vec W^T x + b \le -1$</p>
<h5 id="1-方法一-用点到直线的距离求间隔"><a href="#1-方法一-用点到直线的距离求间隔" class="headerlink" title="1): 方法一, 用点到直线的距离求间隔"></a>1): 方法一, 用点到直线的距离求间隔</h5><p>知道了决策面的表达式后, 我们就可以根据点到直线的距离公式:<br>$$<br>d = \frac{|Ax+By+C|}{\sqrt{A^2+B^2}}<br>$$<br>可以求出其中一类的支持向量到决策面的距离了:<br>$$<br> d = \frac{|\vec W^T x + b|}{||\vec W||}<br>$$<br>这里 $||\vec W||$ 是向量的模，表示在空间中向量的长度</p>
<p>支持向量所在的直线 $\vec W^T x + b = 1$ 或 $\vec W^T x + b = -1$ , 而无论是-1还是1, 绝对值之后都是1 , 所以:<br>$$<br> d = \frac{|\vec W^T x + b|}{||\vec W||}=\frac{1}{||\vec W||}<br>$$<br><strong>这只是其中一类到决策面的距离, 因此, 总间隔为</strong><br>$$<br> d =\frac{2}{||\vec W||}<br>$$</p>
<h5 id="2-方法二-用向量求间隔"><a href="#2-方法二-用向量求间隔" class="headerlink" title="2): 方法二, 用向量求间隔"></a>2): 方法二, 用向量求间隔</h5><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqket1zqjj20m80howfi.jpg" alt="支持向量机算法原理2.png" style="zoom:50%;" />



<p>如图:</p>
<p>我们要分类的向量到决策边界的距离可以用该向量在决策边界的法向量上面的正交投影来衡量,所以我们如果想要求两个类别之间的间隔, 可以用两个支持边界(决策边界两边的那两条线)上的支持向量在决策边界的法向量上的正交投影相减即可( $x_2$ 在 $w$ 上的投影减去 $x_1$ 在 $w$ 上的投影):</p>
<p>当然上图中的 $x_1, x_2$ 并没有在支持边界上, 我们假设他们都在决策边界上, 这时我们就可以用向量的正交投影的公式:<br>$$<br>||\vec x_2||= \frac{\vec x_2 \times \vec W}{||\vec W||}\<br>||\vec x_1||= \frac{\vec x_1 \times \vec W}{||\vec W||}\<br>$$<br>所以间隔为:<br>$$<br>\begin{aligned}<br>d &amp;= ||\vec x_2|| - ||\vec x_1||\\<br>&amp;=\frac{\vec x_2 \times \vec W}{||\vec W||}-\frac{\vec x_1 \times \vec W}{||\vec W||}\\<br>&amp;=\frac{1-b}{||\vec W||} - \frac{-1-b}{||\vec W||}\\<br>&amp;=\frac{2}{||\vec W||}<br>\end{aligned}<br>$$</p>
<h5 id="3-得出目标函数"><a href="#3-得出目标函数" class="headerlink" title="3): 得出目标函数"></a>3): 得出目标函数</h5><p>间隔求出来了, 而我们的SVM要求的是两类之间的最大间隔:<br>$$<br>max(d) = max(\frac{2}{||\vec W||})<br>$$<br>等价于:<br>$$<br>min||\vec W||<br>$$</p>
<p>等价于:<br>$$<br>min (\frac{1}{2}||\vec W||^2)<br>$$<br><strong>之所以要加上平方和1/2的系数，是为了以后进行最优化的过程中对目标函数求导时比较方便，但这绝不影响最优化问题最后的解。</strong></p>
<p>同时也不要忘了有一些约束条件:<br>$$<br>\vec W^T x_i + b \ge 1, y_i=1\<br>\vec W^T x_i + b \le -1, y_i=-1\<br>$$<br>将这个式子精简一下:<br>$$<br>y_i(\vec W^T x_i + b ) \ge1, i=1,2,3…,n<br>$$</p>
<p><font color=red><strong>至此我们的目标函数就出来了:</strong> </font><br>$$<br>min_{\vec W, b}\frac{1}{2}||\vec W||^2\<br>s.t.y_i(\vec W^T x_i + b ) \ge1, i=1,2,3…,n<br>$$</p>
<p>这里n是样本点的总个数，缩写s. t. 表示“Subject to”，是“服从某某条件”的意思。这是一个典型的不等式约束条件下的二次型函数优化问题</p>
<p><font color=red>某些条件下，把原始的约束问题通过拉格朗日函数转化为无约束问题，如果原始问题求解棘手，在满足KKT的条件下用求解对偶问题来代替求解原始问题，使得问题求解更加容易。</font></p>
<h4 id="2-拉格朗日乘子法"><a href="#2-拉格朗日乘子法" class="headerlink" title="(2): 拉格朗日乘子法"></a>(2): 拉格朗日乘子法</h4><p>上一节我们求出了目标函数, 但这是一个带约束的优化问题, 此时我们可以用拉格朗日乘子法构造一个拉格朗日函数, 将原来的有约束的优化问题转换为没有约束的优化问题.</p>
<p><strong>拉格朗日乘子法的基本思想是把约束条件转化为新的目标函数的一部分，从而使有约束优化问题变成我们习惯的无约束优化问题。</strong></p>
<blockquote>
<p><strong>拉格朗日乘子法扩展</strong></p>
<p>①: 当约束条件为<strong>等式</strong>时:</p>
<p>​                原函数:<br>$$<br>min_x f(x)\<br>s.t. h_i(x)=0 , i=1,2,3…,m<br>$$<br>​                拉格朗日函数:<br>$$<br>L(x, \alpha)=f(x) + \sum_{i=1}^m\alpha_i h_i(x)<br>$$<br>②: 当约束条件为<strong>不等式</strong>时:</p>
<p>​                原函数:<br>$$<br>min_x f(x)\<br>s.t. g_j(x) \le 0 , j=1,2,3…,n<br>$$<br>​                拉格朗日函数:<br>$$<br>L(x, \beta)=f(x) + \sum_{i=1}^n\beta_j g_j(x)<br>$$<br>并且不等式约束转换之后需要满足<strong>KKT(Karush-Kuhn-Tucker)</strong>条件, 即:<br>$$<br>\begin{cases}<br>乘子非负: \beta_j \ge 0, j=1,2,3…,n\\<br>约束条件: g_j(x) \le 0 , j=1,2,3…,n\\<br>互补条件: \beta_j \times g_j(x) = 0<br>\end{cases}<br>$$<br><strong>KKT条件是对最优解的约束，而原始问题中的约束条件是对可行解的约束</strong></p>
</blockquote>
<p>回到我们得原始问题上来,<br>$$<br>min_{\vec W, b}\frac{1}{2}||\vec W||^2\<br>s.t.y_i(\vec W^T x_i + b ) \ge 1, i=1,2,3…,n<br>$$</p>
<p> 我们用拉格朗日乘子法对我们得原函数进行转换:<br>$$<br>L(\vec W, b, \alpha) = \frac{1}{2}||\vec W||^2 + \sum_{i=1}^n\alpha_i [1 - y_i(\vec W^T x_i + b ) ] , \alpha_i \ge 0\<br>$$<br>假设找到了最佳参数是的目标函数取得了最小值 $p$。即 $\frac{1}{2}||\vec W||^2=p$  。而根据 $\alpha_i \ge 0$ ，$y_i(\vec W^T x_i + b ) \ge 1$ 可知  $\sum\limits_{i=1}^n\alpha [1-y_i(\vec W^T x_i + b )] \le 0$ ，因此$L(\vec W, b, \alpha) \le p$ ，为了找到最优的参数  $\alpha$ ，使得 $L(\vec W, b, \alpha)$ 接近 $p$，故问题转换为出 ${max}_{\alpha, \alpha \ge0} L(\vec W, b, \alpha)$。</p>
<p>但我们最终得目的是求原函数关于 $\vec W$ 和 $b$ 的最小值, 也就是拉格朗日函数关于 $\vec W$ 和 $b$ 的最小值, </p>
<p>所以我们将问题转换为:<br>$$<br>min_{\vec W, b}[max_{\alpha, \alpha \ge0}L(\vec W, b, \alpha)]<br>$$</p>
<h4 id="3-拉格朗日对偶函数"><a href="#3-拉格朗日对偶函数" class="headerlink" title="(3): 拉格朗日对偶函数"></a>(3): 拉格朗日对偶函数</h4><p>拉格朗日函数的<strong>对偶问题</strong>为:<br>$$<br>max_{\alpha, \alpha \ge0}[min_{\vec W, b}L(\vec W, b, \alpha)]<br>$$</p>
<blockquote>
<p><strong>对偶问题:</strong></p>
<p>假设有个函数 <img src="https://www.zhihu.com/equation?tex=f" alt="[公式]"> 我们有：<br>$$<br>min max f \ge maxmin f<br>$$<br>也就是说，最大的里面挑出来的最小的也要比最小的里面挑出来的最大的要大。这关系实际上就是弱对偶关系，而强对偶关系是当等号成立时，即：<br>$$<br>min max f = maxmin f<br>$$<br>如果 <img src="https://www.zhihu.com/equation?tex=f+" alt="[公式]"> 是凸优化问题，强对偶性成立。<strong>而我们之前求的 KKT 条件是强对偶性的充要条件</strong>。</p>
</blockquote>
<p>回到我们的问题中, 我们现在的目标是先求出: $\min\limits_{\vec W, b}L(\vec W, b, \alpha)$ </p>
<p>我们分别令函数 $L(\vec W, b, \alpha)$ 对 $\vec W, b$ 求偏导，并使其等于0。<br>$$<br>\frac{\partial L}{\partial \vec W}=\vec W - \sum_{i=1}^n\alpha_i y_ix_i =0\<br>\frac{\partial L}{\partial b} = -\sum_{i=1}^n\alpha_i y_i = 0\<br>$$<br>得到 :<br>$$<br>\vec W = \sum_{i=1}^n\alpha_i y_ix_i\<br>\sum_{i=1}^n\alpha_i y_i = 0<br>$$<br>将我们得到的结果带入 $\min\limits_{\vec W, b}L(\vec W, b, \alpha)$ :<br>$$<br>\begin{aligned}<br>\min_{\vec W, b}L(\vec W, b, \alpha) &amp;= \frac{1}{2}||\vec W||^2 + \sum_{i=1}^n\alpha_i [1 - y_i(\vec W^T x_i + b ) ] \\<br>&amp;=\frac{1}{2}(\sum_{i=1}^n\alpha_i y_ix_i)^T (\sum_{i=1}^n\alpha_i y_ix_i) + \sum_{i=1}^n\alpha_i - \sum_{i=1}^n\alpha_i y_i(\sum_{j=1}^n\alpha_i y_i (x_i x_j) + b )  \\<br>&amp;=\frac{1}{2}\sum_{i=1}^n \sum_{j=1}^n \alpha_i \alpha_j y_i y_j (x_i x_j) + \sum_{i=1}^n\alpha_i - \sum_{i=1}^n \sum_{j=1}^n \alpha_i \alpha_j y_i y_j (x_i x_j) - \sum_{i=1}^n\alpha_i y_i b   \\<br>&amp;=\sum_{i=1}^n\alpha_i - \frac{1}{2} \sum_{i=1}^n \sum_{j=1}^n \alpha_i \alpha_j y_i y_j (x_i x_j)<br>\end{aligned}<br>$$</p>
<p>$\min \limits_{\vec W, b}L(\vec W, b, \alpha)$ 求出来之后我们就可以求 $max_{\alpha, \alpha \ge 0} min_{\vec W, b}L(\vec W, b, \alpha)$ 了, 也就是:<br>$$<br>\max_{\alpha, \alpha \ge 0}[\sum_{i=1}^n\alpha_i - \frac{1}{2} \sum_{i=1}^n \sum_{j=1}^n \alpha_i \alpha_j y_i y_j (x_i x_j)]\<br>s.t \sum_{i=1}^n\alpha_i y_i = 0 , \alpha_i \ge 0<br>$$<br>不难发现这是一个二次规划问题，有现成的通用的算法来求解。</p>
<h4 id="4-二次规划-gt-SMO算法"><a href="#4-二次规划-gt-SMO算法" class="headerlink" title="(4): 二次规划 -&gt; SMO算法"></a>(4): 二次规划 -&gt; SMO算法</h4><blockquote>
<p><strong>维基百科定义的二次规划</strong></p>
<p>一个有n个变数与m个限制的二次规划问题可以用以下的形式描述。首先给定：</p>
<ul>
<li>一个<em>n</em> 维的向量 <strong>c</strong></li>
<li>一个<em>n</em> × <em>n</em> 维的对称矩阵<em>Q</em></li>
<li>一个<em>m</em> × <em>n</em> 维的矩阵<em>A</em></li>
<li>一个<em>m</em> 维的向量 <strong>b</strong></li>
</ul>
<p>则此二次规划问题的目标即是在限制条件为<br>$$<br>Ax \le b<br>$$<br>的条件下，找一个<em>n</em> 维的向量 <strong>x</strong> ，使得<br>$$<br>f(x) = \frac{1}{2}x^TQx+c^Tx<br>$$<br>为最小。</p>
<p>其中$x^T是 x$的转置。</p>
<p>根据不同的参数特性，可以得到对问题不同的结论</p>
<ul>
<li>如果Q是半正定矩阵，那么f(x)是一个凸函数。相应的二次规划为凸二次规划问题；此时若约束条件定义的可行域不为空，且目标函数在此可行域有下界，则该问题有全局最小值。</li>
<li>如果Q是正定矩阵，则该问题有唯一的全局最小值。</li>
<li>若Q为非正定矩阵，则目标函数是有多个平稳点和局部极小点的NP难问题</li>
</ul>
<p>根据优化理论，一个点x成为全局最小值的必要条件是满足KKT。当f(x)是凸函数时，KKT条件也是充分条件。</p>
</blockquote>
<p>对于二次规划问题, 我们常用 SMO(Sequential Minimal Optimization) 算法求解。SMO序列最小优化算法，其核心思想非常简单：每次只优化一个参数，其他参数先固定住，仅求当前这个优化参数的极值。</p>
<p>我们刚说了 SMO 算法每次只优化一个参数，但我们的优化目标有约束条件：$\sum\limits_{i=1}^n\alpha_i y_i = 0$ ，没法一次只变动一个参数。所以我们选择了一次选择两个参数。</p>
<p><a href="https://zhuanlan.zhihu.com/p/29212107" target="_blank" rel="noopener">SMO详解 - SVM中的SMO算法</a> </p>
<p><strong>通过 SMO 求得最优解$\hat \alpha$</strong> </p>
<p>假设我们现在求得了 $\alpha$ 的最优解 $\hat \alpha$，则根据式 $\vec W = \sum\limits_{i=1}^n\alpha_i y_ix_i\$ 可求得最优 $\hat W$ ：<br>$$<br>\hat W = \sum_{i=1}^n \hat \alpha_i y_ix_i\<br>$$</p>
<p>我们知道所有 $ \alpha_i$ 对应的点都是支持向量，我们可以随便找个支持向量，然后带入：$1 - y_s(\vec W^T x_s + b ) = 0 $ 求出 b 即可:<br>$$<br>1 - y_s(\hat W^T x_s + \hat b ) = 0\\<br>1 = y_s(\hat W^T x_s + \hat b )\\<br>y_s = y^2_s(\hat W^T x_s + \hat b )\\<br> \\<br>由于: y_s^2 = 1(y=正负1)\\<br> \\<br>y_s = \hat W^T x_s + \hat b \\<br>\hat b = y_s - \hat W^T x_s<br>$$<br><strong>此处s代表该点是支持向量,</strong></p>
<p>为了更具鲁棒性，我们可以求得支持向量的均值：<br>$$<br>\hat b = \frac{1}{S}\sum_{s \in S}y_s - \hat W^T x_s<br>$$</p>
<p>最终我们的决策函数为:<br>$$<br>\begin{aligned}<br>f(x) &amp;= \vec Wx+b\<br>&amp; =\sum_{i=1}^n \hat \alpha_i y_ix_i x +\hat b<br>\end{aligned}<br>$$<br><font color=red>最最后,加上一个阶跃函数:</font><br>$$<br>f(x) = sign(\sum_{i=1}^n \hat \alpha_i y_ix_i x +\hat b)<br>$$</p>
<blockquote>
<p>阶跃函数sing()<br>$$<br>sing(x) =<br>\begin{cases}<br>-1, x \lt 0\\<br>0, x = 0\\<br>1, x \gt 0\\<br>\end{cases}<br>$$</p>
</blockquote>
<br>

<h3 id="2-线性不可分SVM—软间隔"><a href="#2-线性不可分SVM—软间隔" class="headerlink" title="2: 线性不可分SVM—软间隔"></a>2: 线性不可分SVM—软间隔</h3><p>我们允许部分样本点不满足约束条件： $ 1 - y_i(\vec W^T x_i + b )  \le 0 $ </p>
<p>为了度量这个间隔软到何种程度，我们为每个样本引入一个松弛变量 $\xi$ ，令 $\xi_i \gt0$ ，且 $ 1 - y_i(\vec W^T x_i + b ) - \xi_i \le 0 $ 。</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqkgv0jy0j20rm0nit9l.jpg" alt="支持向量机算法原理3.png" style="zoom:50%;" />





<p>引入松弛变量后, 我们的目标函数就可以重新写为:<br>$$<br>\min_{\vec W, b, \xi}\frac{1}{2}||\vec W||^2 + C\sum_{i=1}^n\xi_i\<br>s.t.y_i(\vec W^T x_i + b ) \ge 1- \xi_i\<br>\xi_i \ge 0, i=1,2,3…,n<br>$$<br>其中 C 是一个大于 0 的常数，可以理解为错误样本的惩罚程度，若 C 为无穷大，$\xi$ 必然无穷小，如此一来线性 SVM 就又变成了线性可分 SVM；当 C 为有限值的时候，才会允许部分样本不遵循约束条件。</p>
<p>构造拉格朗日函数:<br>$$<br>\min_{\vec W, b, \xi} \max_{\lambda, \mu} L(\vec W, b, \xi, \lambda, \mu) = \frac{1}{2}||\vec W||^2 + C\sum_{i=1}^n\xi_i +<br>\sum_{i=1}^n \lambda_i [1-\xi_i-y_i(\vec W^T x_i + b )] + \sum_{i-1}^n\mu_i\xi_i<br>$$<br>其中 $\lambda$和 $\mu$ 是拉格朗日乘子，$\vec W$、b 和 $ \xi$ 是主问题参数。</p>
<p>根据强对偶性，对偶问题为：<br>$$<br>\max_{\lambda, \mu} \min_{\vec W, b, \xi}  L(\vec W, b, \xi, \lambda, \mu)<br>$$<br>分别对主问题参数$\vec W$、b 和 $ \xi$  求偏导数，并令偏导数为 0，得出如下关系：<br>$$<br>\vec W = \sum_{i=1}^n\lambda_i y_ix_i\<br>0 = \sum_{i=1}^n\lambda_i y_i \<br>C = \lambda_i + \mu_i<br>$$<br>将这些关系带入拉格朗日函数中，得到：<br>$$<br>\min_{\vec W, b, \xi}  L(\vec W, b, \xi, \lambda, \mu) = \sum_{j=1}^n \lambda_i - \frac{1}{2}\sum_{i-1}^n \sum_{j=1}^n \lambda_i \lambda_j y_i y_j(x_i x_j)<br>$$<br>所以:<br>$$<br>\max_{\lambda, \mu}[\sum_{j=1}^n \lambda_i - \frac{1}{2}\sum_{i-1}^n \sum_{j=1}^n \lambda_i \lambda_j y_i y_j(x_i x_j)]\<br>s.t. \sum_{i=1}^n\lambda_i y_i = 0 ,<br>C - \lambda_i - \mu_i = 0<br>$$<br>我们可以看到这个和硬间隔的一样，只是多了个约束条件。</p>
<p><strong>然后我们利用 SMO 算法求解得到拉格朗日乘子 $ \lambda^*$ 。</strong></p>
<p>将最佳乘子带入即得:</p>
<p>$$<br>\hat W = \sum\limits_{i=1}^n\hat\lambda_i y_ix_i\<br>\hat b = \frac{1}{S}\sum_{s \in S}y_s - \hat W^T x_s<br>$$<br>超平面函数为:<br>$$<br>f(x) = sign(\sum_{i=1}^n \hat \lambda_i y_ix_i x +\hat b)<br>$$<br><strong>这边要注意一个问题，在间隔内的那部分样本点是不是支持向量</strong></p>
<p>我们可以由求参数 w 的那个式子可看出，只要 $\lambda_i \gt 0$ 的点都能够影响我们的超平面，因此都是支持向量。</p>
<br>

<h3 id="3-非线性SVM—核函数"><a href="#3-非线性SVM—核函数" class="headerlink" title="3: 非线性SVM—核函数"></a>3: 非线性SVM—核函数</h3><p>如下图所示，核技巧的基本思路分为两步:</p>
<ul>
<li>使用一个变换将原空间的数据映射到新空间(例如更高维甚至无穷维的空间)；</li>
<li>然后在新空间里用线性方法从训练数据中学习得到模型。</li>
</ul>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqkh54j4wj21mo0mq16f.jpg" alt="支持向量机算法原理5.png" style="zoom:50%;" />



<p>我们用 x 表示原来的样本点，用 $\phi(x)$表示 x 映射到特征新的特征空间后到新向量。那么分割超平面可以表示为: $f(x) = \vec W \phi(x) + b$</p>
<p>则非线性得SVM的对偶问题就变成:<br>$$<br>\max_{\lambda, \mu}{\sum_{j=1}^n \lambda_i - \frac{1}{2}\sum_{i-1}^n \sum_{j=1}^n \lambda_i \lambda_j y_i y_j[\phi(x_i)  \phi(x_j)]}\<br>s.t. \sum_{i=1}^n\lambda_i y_i = 0 ,<br>C - \lambda_i - \mu_i = 0<br>$$</p>
<blockquote>
<p> <strong>核函数得定义</strong></p>
<p> 设 $\mathcal{X}$ 是输入空间(欧式空间$R^n$的子集或离散集合)，又设 $\mathcal{H}$ 是特征空间(希尔伯特空间)，如果存在一个 $\mathcal{X}$ 到 $\mathcal{H}$ 的映射<br> $$<br> \phi(x): \mathcal{X} \to \mathcal{H}<br> $$<br> 使得对所有 $x, z \in \mathcal{X}$，函数 $K(x,z)$ 满足条件<br> $$<br> K(x,z) = \phi(x) \phi(z)<br> $$<br> 则称 $K(x,z)$ 为核函数， $ϕ(x)$ 为映射函数，式中 $ϕ(x)⋅ϕ(z)$ 为 $ϕ(x)$ 和ϕ(z) 的內积。</p>
</blockquote>
<p>因为低维空间映射到高维空间后维度可能会很大，如果将全部样本的点乘全部计算好，这样的计算量太大了。</p>
<p>有了核函数之后, 我们可以通过计算原始空间的核函数$K(x_i, x_j)$, 就可以得到特征空间内$\phi(x_i)$ 和 $\phi(x_j)$ 的点积, 岂不美哉?</p>
<p><strong>而我们常见的核函数有:</strong></p>
<p>(1): 线性核函数<br>$$<br>K(x_i, x_j) = x_i x_j<br>$$<br>(2): 多项式核函数<br>$$<br>K(x_i, x_j) = ((x_i x_j)+1)^d<br>$$<br>(3): 高斯核函数<br>$$<br>K(x_i, x_j) = exp(-\frac{||x_i - x_j||^2}{\delta^2})<br>$$<br><a href="https://blog.csdn.net/wsj998689aa/article/details/47027365" target="_blank" rel="noopener">核函数详解</a></p>
<p>选择核函数的方法：</p>
<ul>
<li>如果特征的数量大到和样本数量差不多，则选用LR或者线性核的SVM；</li>
<li>如果特征的数量小，样本的数量正常，则选用SVM+高斯核函数；</li>
<li>如果特征的数量小，而样本的数量很大，则需要手工添加一些特征从而变成第一种情况。</li>
</ul>
<br>



<h1 id="三-SVM优缺点"><a href="#三-SVM优缺点" class="headerlink" title="三: SVM优缺点"></a>三: SVM优缺点</h1><p><strong>优点</strong></p>
<ul>
<li>有严格的数学理论支持，可解释性强，不依靠统计方法，从而简化了通常的分类和回归问题；</li>
<li>由于SVM是一个凸优化问题，所以求得的解一定是全局最优而不是局部最优。</li>
<li>能找出对任务至关重要的关键样本（即：支持向量）；</li>
<li>采用核技巧之后，可以处理非线性分类/回归任务；</li>
<li>最终决策函数只由少数的支持向量所确定，计算的复杂性取决于支持向量的数目，而不是样本空间的维数，这在某种意义上避免了“维数灾难”。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>训练时间长。当采用 SMO 算法时，由于每次都需要挑选一对参数，因此时间复杂度为 $O(N^2)$  其中 N 为训练样本的数量；</li>
<li>当采用核技巧时，如果需要存储核矩阵，则空间复杂度为  $O(N^2)$ </li>
<li>模型预测时，预测时间与支持向量的个数成正比。当支持向量的数量较大时，预测计算复杂度较高。</li>
</ul>
<br>

<h1 id="四-SVM调参"><a href="#四-SVM调参" class="headerlink" title="四: SVM调参"></a>四: SVM调参</h1><blockquote>
<p>主要参考:<br><code>Hsu C W, Chang C C, Lin C J. A practical guide to support vector classification[J]. 2003.</code></p>
</blockquote>
<ol>
<li>将原始数据转换为SVM算法期待的格式；</li>
<li>将数据进行scaling(很重要)；</li>
<li>一般考虑用高斯核RBF(如果特征维度太高，建议直接用线性SVM)；</li>
<li>交叉验证寻找最优的RBF的参数以及参数 CC ;</li>
<li>用上面找到的最优参数在整个训练集上训练；</li>
</ol>
<blockquote>
<p>参考文章:</p>
<ul>
<li><a href="https://tangshusen.me/2018/10/27/SVM/" target="_blank" rel="noopener">看了这篇文章你还不懂SVM你就来打我</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/77750026" target="_blank" rel="noopener">【机器学习】支持向量机 SVM（非常详细）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/24638007" target="_blank" rel="noopener">零基础学SVM—Support Vector Machine(一)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29865057" target="_blank" rel="noopener">零基础学SVM-Support Vector Machine(二)</a></li>
<li><a href="https://www.matongxue.com/madocs/939/" target="_blank" rel="noopener">如何理解拉格朗日乘子法？</a></li>
<li><a href="https://www.cnblogs.com/90zeng/p/Lagrange_duality.html" target="_blank" rel="noopener">简易解说拉格朗日对偶（Lagrange duality）</a></li>
</ul>
<p>同时推荐刘建平老师的文章:</p>
<ul>
<li><a href="https://www.cnblogs.com/pinard/p/6097604.html" target="_blank" rel="noopener">支持向量机原理(一) 线性支持向量机</a></li>
<li><a href="https://www.cnblogs.com/pinard/p/6100722.html" target="_blank" rel="noopener">支持向量机原理(二) 线性支持向量机的软间隔最大化模型</a></li>
<li><a href="https://www.cnblogs.com/pinard/p/6103615.html" target="_blank" rel="noopener">支持向量机原理(三)线性不可分支持向量机与核函数</a></li>
<li><a href="https://www.cnblogs.com/pinard/p/6111471.html" target="_blank" rel="noopener">支持向量机原理(四)SMO算法原理</a></li>
<li><a href="https://www.cnblogs.com/pinard/p/6113120.html" target="_blank" rel="noopener">支持向量机原理(五)线性支持回归</a></li>
<li><a href="https://www.cnblogs.com/pinard/p/6117515.html" target="_blank" rel="noopener">scikit-learn 支持向量机算法库使用小结</a></li>
<li><a href="https://www.cnblogs.com/pinard/p/6126077.html" target="_blank" rel="noopener">支持向量机高斯核调参小结</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>算法</tag>
        <tag>支持向量机</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>朴素贝叶斯</title>
    <url>/2019/08/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
    <content><![CDATA[<h1 id="一-贝叶斯定理"><a href="#一-贝叶斯定理" class="headerlink" title="一: 贝叶斯定理"></a>一: 贝叶斯定理</h1><p>贝叶斯定理（英语：Bayes’ theorem）是几率论中的一个定理，描述在已知一些条件下，某事件的发生几率。通常，事件A在事件B已发生的条件下发生的几率，与事件B在事件A已发生的条件下发生的几率是不一样的。然而，这两者是有确定的关系的，贝叶斯定理就是这种关系的陈述。贝叶斯公式的一个用途，即透过已知的三个几率而推出第四个几率。</p>
<p><strong>贝叶斯公式:</strong><br>$$<br>P(A|B) = \frac{P(A)P(B|A)}{P(B)}<br>$$</p>
<p>$P(A|B)$ <strong>的意思是在事件$B$发生的条件下发生事件$A$的概率</strong></p>
<p>接下来我们通过两个例子来更好的理解贝叶斯公式</p>
<h2 id="例1"><a href="#例1" class="headerlink" title="例1:"></a>例1:</h2><p>现分别有 甲,乙 两个容器，在容器 甲 里分别有 7 个红球和 3 个白球，在容器 乙 里有 1 个红球和 9 个白球，现已知从这两个容器里任意抽出了一个球，且是红球，问这个红球是来自容器 甲 的概率是多少?</p>
<p><strong>方便理解: 若乙中0个红球,10个白球,则红球来自A的概率为100%</strong></p>
<p><strong>思路:</strong></p>
<p>选中甲容器的概率: P(A) = 1/2</p>
<p>选中红球的概率: P(B) = 8/20</p>
<p>甲中红球的概率: P(B|A) = 7/10</p>
<p>选中的红球是甲中的概率: </p>
<p>$P(A|B) = \frac{P(A)P(B|A)}{P(B)}= \frac{(1/2)*(7/10)}{8/20}= \frac{7}{8}$</p>
<h2 id="例2"><a href="#例2" class="headerlink" title="例2:"></a>例2:</h2><p>一座别墅在过去的 20 年里一共发生过 2 次被盗，别墅的主人有一条狗，狗平均每周晚上叫 3 次，在盗贼入侵时狗叫的概率被估计为 0.9，问题是：在狗叫的时候发生入侵的概率是多少？</p>
<p>狗叫的概率: P(A) = 3/7</p>
<p>被盗的概率: P(B) = 2 / (20*365) </p>
<p>被盗时狗叫的概率: P(A|B) = 0.9</p>
<p>狗叫时被盗的概率: $P(B|A) = \frac{P(B)P(A|B)}{P(A)} = \frac{(2/(20\times365))\times 0.9}{3/7}$</p>
<p><strong>将贝叶斯公式 $P(A|B) = \frac{P(A)P(B|A)}{P(B)}$ 用到我们的数据分析中则可以理解为,B是特征, A是对应的类别;</strong> </p>
<br>

<h1 id="二-Sklearn中的朴素贝叶斯"><a href="#二-Sklearn中的朴素贝叶斯" class="headerlink" title="二: Sklearn中的朴素贝叶斯"></a>二: Sklearn中的朴素贝叶斯</h1><p><font color=purple> <strong>当特征数量为一时, 表现出来的就是我们的贝叶斯公式;</strong> </font></p>
<h2 id="一-理解朴素贝叶斯"><a href="#一-理解朴素贝叶斯" class="headerlink" title="(一): 理解朴素贝叶斯"></a>(一): 理解朴素贝叶斯</h2><p><strong>屌丝逆袭实例:</strong></p>
<p>大学的时候，某男生经常去007自习室上晚自习，发现他喜欢的那个女生也常去那个自习室，心中窃喜，于是每天买点好吃点在那个自习室蹲点等她来，可是人家女生不一定每天都来，眼看天气渐渐炎热，自习室又不开空调，如果那个女生没有去自习室，该男生也就不去，每次男生鼓足勇气说：“嘿，你明天还来不？”,“啊，不知道，看情况”。然后该男生每天就把她去自习室与否以及一些其他情况做一下记录，<strong>用Y表示该女生是否去自习室，即Y={去，不去}，X是跟去自习室有关联的一系列条件，比如当天上了哪门主课，</strong>蹲点统计了一段时间后，该男生打算今天不再蹲点，而是先预测一下她会不会去，现在已经知道了今天上了常微分方法这么主课，于是计算<strong>$P(Y=去|常微分方程)$</strong>与<strong>$P(Y=不去|常微分方程)$</strong>，看哪个概率大，如果<strong>$P(Y=去|常微分方程) &gt;P(Y=不去|常微分方程)$</strong>，那这个男生不管多热都屁颠屁颠去自习室了，否则不就去自习室受罪了。P(Y=去|常微分方程)的计算可以转为计算以前她去的情况下，那天主课是常微分的概率P(常微分方程|Y=去)，注意公式右边的分母对每个类别（去/不去）都是一样的，所以计算的时候忽略掉分母，这样虽然得到的概率值已经不再是0~1之间，但是<strong>通过比较大小还是能选择类别</strong>。后来他发现还有一些其他条件可以挖，<strong>比如当天星期几、当天的天气，以及上一次与她在自修室的气氛</strong>，统计了一段时间后，该男子一计算，发现不好算了，因为总结历史的公式：<br>$$<br>P(X=x|Y=C_k) = P(X^{(1)}=x^{(1)}, X^{(2)}=x^{(2)}, …, X^{(n)}=x^{(n)} | Y=C_k)<br>$$<br><strong>这里n=4，x(1)表示主课，x(2)表示天气，x(3)表示星期几，x(4)表示气氛，Y仍然是{去，不去}，现在主课有8门，天气有晴、雨、阴三种、气氛有A+,A,B+,B，C五种，那么总共需要估计的参数有8×3×7×5×2=1680个，</strong>每天只能收集到一条数据，那么等凑齐1680条数据，大学都毕业了，男生大呼不妙</p>
<p><font color=purple><strong>当特征数量为多个时, 多个条件之间互相影响, 增加了数据复杂度, 最终决定对应的类别;</strong></font></p>
<p>于是做了一个<font color=red><strong>独立性假设，假设这些影响她去自习室的原因是独立互不相关的:</strong></font><br>$$<br>\begin{aligned}<br>P(X=x|Y=C_k) &amp;= P(X^{(1)}=x^{(1)}, X^{(2)}=x^{(2)}, …, X^{(n)}=x^{(n)} | Y=C_k)\\<br>&amp; = P(X^{(1)}=x^{(1)} | Y=C_k) \times P(X^{(2)}=x^{(2)} | Y=C_k) \times …\times P(X^{(n)}=x^{(n)} | Y=C_k)\\<br>&amp;=\prod_{i=1}^n P(X^{(i)}=x^{(i)} | Y=C_k)\\<br>\end{aligned}<br>$$<br>有了这个独立假设后，需要估计的参数就变为，(8+3+7+5)×2 = 46个了，而且每天收集的一条数据，可以提供4个参数，这样该男生就预测越来越准了</p>
<p>通过上面这个屌丝逆袭的例子我们可以简单的总结一下: </p>
<p><strong><font color=red> sklearn中的朴素贝叶斯其实就是将贝叶斯中的各属性看成是独立的,不相互影响的</font></strong></p>
<p>那么朴素贝叶斯又是怎么判断类别的呢?</p>
<p>别急, 继续往下看.</p>
<h2 id="二-朴素贝叶斯的工作原理"><a href="#二-朴素贝叶斯的工作原理" class="headerlink" title="(二): 朴素贝叶斯的工作原理"></a>(二): 朴素贝叶斯的工作原理</h2><p><strong>又是一个例子:</strong></p>
<p>如果一对男女朋友，男生向女生求婚，男生的四个特点分别是不帅，性格不好，身高矮，不上进，请你判断一下女生是嫁还是不嫁？</p>
<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmgn7r1riwj20t40f8adw.jpg" alt="嫁不嫁算例.png"></p>
<p>首先,我们用<strong>贝叶斯公式</strong>将这个时间的概率表示出来:<br>$$<br>P(嫁 | 不帅、性格不好、身高矮、不上进)=\frac{P(不帅、性格不好、身高矮、不上进|嫁) \times P(嫁)}{P(不帅、性格不好、身高矮、不上进)}<br>$$<br>将贝叶斯转换成<strong>朴素贝叶斯</strong><br>$$<br>\begin{aligned}<br>P(嫁 | 不帅、性格不好、身高矮、不上进)&amp;=\frac{P(不帅、性格不好、身高矮、不上进|嫁) \times P(嫁)}{P(不帅、性格不好、身高矮、不上进)}\\<br>&amp; \\<br>&amp;= \frac{P(不帅|嫁) \times P(性格不好|嫁) \times P(身高矮|嫁) \times P(不上进|嫁) \times P(嫁)}{P(不帅) \times P(性格不好) \times P(身高矮) \times P(不上进)}\\<br>\end{aligned}<br>$$</p>
<p>此时,我们就可以轻易的看出:</p>
<p>$P(不帅|嫁)$ 的概率为: 1/2</p>
<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmgn88b2jlj218u0jsjwl.jpg" alt="嫁不帅的概率.png"></p>
<p>$P(嫁)$ 的概率为: 1/2</p>
<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmgn8kwovhj21a00lbn3c.jpg" alt="嫁的概率.png"></p>
<p>依次类推, 可以计算出其他的独立事件的概率, 即可算出嫁或则不嫁的概率分别时多少, 然后<strong>比较相同条件下嫁和不嫁的概率的大小来决定是否出嫁</strong></p>
<p><font color=red>注意: 朴素贝叶斯的结果可能会大于一, 至于嫁与不嫁只需要比较计算出来的结果即可,结果之和不等于1 </font></p>
<h2 id="三-朴素贝叶斯的算法模型"><a href="#三-朴素贝叶斯的算法模型" class="headerlink" title="(三): 朴素贝叶斯的算法模型"></a>(三): 朴素贝叶斯的算法模型</h2><p>这里主要介绍三种, 分别是: 高斯分布, 伯努利分布, 多项式分布</p>
<p><strong>高斯分布又称正态分布:</strong></p>
<p>曲线高峰位于正中央，即均数所在的位置; 曲线由均数所在处开始，分别向左右两侧逐渐均匀下降</p>
<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmgn8vr7jfj22801f40xn.jpg" alt="高斯分布.png"></p>
<p>正态曲线呈钟型，两头低，中间高，左右对称因其曲线呈钟形，因此人们又经常称之为钟形曲线。</p>
<p><strong>伯努利分布</strong></p>
<p>在概率论和统计学中，二项分布（英语：Binomial distribution）是n个独立的是/非试验中成功的次数的离散概率分布，其中每次试验的成功概率为p。这样的单次成功/失败试验又称为伯努利试验。<strong>实际上，当n = 1时，二项分布就是伯努利分布。</strong>二项分布是显著性差异的二项试验的基础。</p>
<p><strong>多项式分布</strong></p>
<p>在概率论中，多项式分布是二项式分布的推广。例如，它模拟了n次轧制的k面模具每侧计数的概率。对于n个独立试验，每个试验都能准确地为k个类别中的一个成功，并且每个类别具有给定的固定成功概率，多项式分布给出了各个类别成功次数的任何特定组合的概率。</p>
<p><strong>当k为2且n为1时，多项式分布为伯努利分布。当k为2且n大于1时，它是二项分布。当k大于2且n为1时，它是分类分布。</strong></p>
<br>


<h1 id="三-朴素贝叶斯对垃圾邮件进行分类"><a href="#三-朴素贝叶斯对垃圾邮件进行分类" class="headerlink" title="三: 朴素贝叶斯对垃圾邮件进行分类"></a>三: 朴素贝叶斯对垃圾邮件进行分类</h1><ol>
<li>导包获取数据</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB,BernoulliNB,BaseDiscreteNB,MultinomialNB</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sms = pd.read_csv(<span class="string">'./SMSSpamCollection.csv'</span>, sep=<span class="string">'\t'</span>, header=<span class="literal">None</span>)</span><br><span class="line">sms.rename(&#123;<span class="number">0</span>:<span class="string">'label'</span>, <span class="number">1</span>:<span class="string">'message'</span>&#125;, axis = <span class="number">1</span>, inplace=<span class="literal">True</span>)  <span class="comment"># 该表头</span></span><br><span class="line">display(sms.shape, sms.head())</span><br><span class="line">X = sms[[<span class="string">'message'</span>]]   <span class="comment"># 机器学习要求数据是二维的,若只有一个中括号则数据类型的Serios</span></span><br><span class="line">y = sms[[<span class="string">'label'</span>]]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对邮件文本内容(字符串)进行量化</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># feature_extraction特征提取</span></span><br><span class="line"><span class="comment"># CountVectorizer统计词频</span></span><br><span class="line"><span class="comment"># 中文词频统计包: 结巴分词(pip install jieba)</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cv = CountVectorizer()</span><br><span class="line">X_ = cv.fit_transform(sms[<span class="string">'message'</span>])  <span class="comment"># 稀松矩阵</span></span><br><span class="line"><span class="comment"># 返回sparse matrix稀松矩阵,节省内存</span></span><br><span class="line"><span class="comment"># 5572x8713表示5572条短信中提取到8713个词</span></span><br><span class="line"><span class="comment"># cv.vocabulary_   查看单词在稀松矩阵中的例数</span></span><br><span class="line"><span class="comment"># (0, 3571)	1   表示第一行(第一封邮件)第3571列代表的词有一个</span></span><br><span class="line"><span class="comment"># (0, 8084)	1   表示第一行(第一封邮件)第8084列代表的词有一个</span></span><br><span class="line"><span class="comment"># 以此类推</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">sparse.save_npz(<span class="string">'./sms.npz'</span>, X_)   <span class="comment"># 稀松矩阵只有100KB大小</span></span><br><span class="line">X = X_.toarray()   <span class="comment"># 常规矩阵</span></span><br><span class="line">np.savez(<span class="string">'./sms2.npz'</span>, X)   <span class="comment"># 常规矩阵有388MB大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sparse.csc_matrix() 方法可以将常规矩阵转换成稀松矩阵</span></span><br><span class="line"><span class="comment"># toarray() 方法可以将稀松矩阵转回正常矩阵</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>分数据</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 常规数据</span></span><br><span class="line">X_train,X_test, y_train,y_test = train_test_split(X,y,test_size=<span class="number">0.2</span>,random_state=<span class="number">1187</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 稀松矩阵的数据</span></span><br><span class="line">X_train_,X_test_, y_train,y_test = train_test_split(X_,y,test_size=<span class="number">0.2</span>,random_state=<span class="number">1187</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>用不同的模型进行分类</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="comment"># 高斯分布</span></span><br><span class="line">gNB = GaussianNB()   <span class="comment"># 数据必须是正常矩阵</span></span><br><span class="line">gNB.fit(X_train, y_train)</span><br><span class="line">gNB.score(X_test, y_test)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Wall time: 1.51 s</span></span><br><span class="line"><span class="string">0.8914798206278027</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="comment"># 伯努利分布</span></span><br><span class="line">bNB = BernoulliNB()   <span class="comment"># 数据支持稀松举证(提高运行效率)</span></span><br><span class="line">bNB.fit(X_train_, y_train)</span><br><span class="line">bNB.score(X_test_, y_test)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Wall time: 20 ms</span></span><br><span class="line"><span class="string">0.9730941704035875</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="comment"># 多项式分布</span></span><br><span class="line">mNB = MultinomialNB()   <span class="comment"># 数据支持稀松举证(提高运行效率)</span></span><br><span class="line">mNB.fit(X_train_, y_train)</span><br><span class="line">mNB.score(X_test_, y_test)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Wall time: 20.9 ms</span></span><br><span class="line"><span class="string">0.979372197309417</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<br>

<h1 id="四-应用"><a href="#四-应用" class="headerlink" title="四: 应用"></a>四: 应用</h1><p>朴素贝叶斯在文本分类和情感分析中应用最为广泛</p>
<ol>
<li><strong>文本分类（Text Categorization）</strong>是指计算机将一片文档归于预先给定的某一类或几类的过程。文本分类的<strong>特征提取</strong>过程是<strong>分词</strong>。目前比较好的中文分词器有中科院的ictclas，庖丁，IK等等。经过分词后，每个词就是一个特征。分词中可以自己配置停用词库，扩展词库等。<strong>特征选择</strong>有诸如TF-IDF，CHI等特征选择算法，就不在此赘述。</li>
<li>朴素贝叶斯计算先验概率P（C）和条件概率P（X|C）的方法有两种：<strong>多项式模型</strong>和<strong>伯努利模型</strong>。两者在计算的时候有两点差别：多项式会统计词频，而伯努利认为单词出现就记为1，没出现记为0，<strong>可以看到一个是基于词频，一个是基于文档频率</strong>；伯努利在分类时，将词库中的<strong>没有出现在待分类文本的词作为反方考虑</strong>。/</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
        <tag>朴素贝叶斯</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归一</title>
    <url>/2018/10/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h1 id="一-线性回归方程"><a href="#一-线性回归方程" class="headerlink" title="一: 线性回归方程"></a>一: 线性回归方程</h1><p>​        <strong>线性回归</strong>（英语：linear regression）是利用称为线性回归方程的<strong>最小二乘函数</strong>对一个或多个自变量和因变量</p>
<p>之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。只有一个自变量</p>
<p>的情况称为简单回归，大于一个自变量情况的叫做多元回归</p>
<p>​        在线性回归中，数据使用线性预测函数来建模，并且未知的模型参数也是通过数据来估计。这些模型被叫做</p>
<p>线性模型。最常用的线性回归建模是给定X值的y的条件均值是X的仿射函数。不太一般的情况，线性回归模型可以</p>
<p>是一个中位数或一些其他的给定X的条件下y的条件分布的分位数作为X的线性函数表示。像所有形式的回归分析一</p>
<p>样，线性回归也把焦点放在给定X值的y的条件概率分布，而不是X和y的联合概率分布（多元分析领域）。</p>
<p>​        线性回归有很多实际用途。分为以下两大类：</p>
<ol>
<li><p>如果目标是预测或者映射，线性回归可以用来对观测数据集的和X的值拟合出一个预测模型。当完成这样一个</p>
<p>模型以后，对于一个新增的X值，在没有给定与它相配对的y的情况下，可以用这个拟合过的模型预测出一个y</p>
<p>值。</p>
</li>
<li><p>给定一个变量y和一些变量${\displaystyle X_{1}}X_1,…,{\displaystyle X_{p}}X_p$，这些变量有可能与y相关，线性回归分析可以用来量化y与Xj之</p>
<p>间相关性的强度，评估出与y不相关的，${\displaystyle X_{j}}X_j$并识别出哪些${\displaystyle X_{j}}X_j$的子集包含了关于y的冗余信息。</p>
</li>
</ol>
<h2 id="使用sklearn线性回归模型-jupyter"><a href="#使用sklearn线性回归模型-jupyter" class="headerlink" title="使用sklearn线性回归模型(jupyter)"></a>使用sklearn线性回归模型(jupyter)</h2><p><strong>这里我们以波士顿的房价数据来进行使用分析</strong></p>
<h3 id="一-导入sklearn"><a href="#一-导入sklearn" class="headerlink" title="(一): 导入sklearn"></a>(一): 导入sklearn</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线性回归,拟合方程,求解系数, 一次幂</span></span><br><span class="line"><span class="comment"># 线性方程:直来直去,不拐弯</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="comment"># 导入数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="comment"># 导入数据分离的方法(获取数据后,一部分数据用来让回归模型学习,另一部分用来预测)</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br></pre></td></tr></table></figure>
<h3 id="二-获取波士顿房价数据"><a href="#二-获取波士顿房价数据" class="headerlink" title="(二): 获取波士顿房价数据"></a>(二): 获取波士顿房价数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取的数据是numpy,ndarray类型</span></span><br><span class="line">data = datasets.load_boston()   </span><br><span class="line"><span class="comment"># 该数据内有完整的影响房价的因素和完整的房价信息,本次实验就是将数据分为两部分, 一部分用来训练模型,另一部分用来预测,最后将预测出来的数据和已有的完整信息进行对比,判断该模型是否适用于这组房价数据</span></span><br><span class="line"></span><br><span class="line">data   <span class="comment"># 查看data的数据结构</span></span><br><span class="line">data.feature_names   <span class="comment"># 查看影响房价的属性名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># x是属性,特征,未知数</span></span><br><span class="line">X = data[<span class="string">'data'</span>]</span><br><span class="line">X.shape   <span class="comment"># 运行结果是(506, 13), 506表示样本是506个, 每个样本采集了13个属性特征;13个属性,需要构建构建了13元一次方程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># y是房价的估值</span></span><br><span class="line">y = data[<span class="string">'target'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># !!!!!!!!!!</span></span><br><span class="line"><span class="comment"># X, y = datasets.load_boston(True) 获取到X, y的值和以上的一样</span></span><br></pre></td></tr></table></figure>
<h3 id="三-使用模型进行预测"><a href="#三-使用模型进行预测" class="headerlink" title="(三): 使用模型进行预测"></a>(三): 使用模型进行预测</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y)   <span class="comment"># 将数据进行分离(默认是3:1); train_test_split(X, y)函数会随机打乱顺序</span></span><br><span class="line"></span><br><span class="line">display(X_train.shape, X_test.shape)   <span class="comment"># (379, 13) ; (127, 13)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明算法</span></span><br><span class="line">linear = LinearRegression()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">linear.fit(X_train, y_train)   <span class="comment"># X_train, y_train是之前分离出来用来训练模型的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">y_ = linear.predict(X_test).round(<span class="number">1</span>)   <span class="comment"># X_test是影响房价的因素,该预测模型能根据影响房价的因素预测剩余部分的房价</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预估数据和实际数据比较</span></span><br><span class="line">print(y_)</span><br><span class="line">print(y_test)</span><br></pre></td></tr></table></figure>
<p><strong><font color=red>经过估计数据和实际数据对比,说明算法模型适用于数据</font></strong></p>
<h3 id="四-自建方程预测数据-与-使用线性模型得到的数据对比"><a href="#四-自建方程预测数据-与-使用线性模型得到的数据对比" class="headerlink" title="(四): 自建方程预测数据 与 使用线性模型得到的数据对比"></a>(四): 自建方程预测数据 与 使用线性模型得到的数据对比</h3><p>​        假设波士顿的房价数据符合线性回归的特性,则我们可以通过构建线性方程来预测波士顿剩余部分的房价信息</p>
<p>根据一次线性回归方程: $f(X) = Xw+b$ 可推导得出: $ f(X) = w_1x_1+W_2x_2+…+w_{13}x_{13} +b$   (有13个影响房</p>
<p>价的因素)</p>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过训练模型,可从模型中得出系数w</span></span><br><span class="line">w_ = linear.coef_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过训练模型,可从模型中得出截距b</span></span><br><span class="line">b_ = linear.intercept_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自建方程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(w_, b_, X)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.dot(X, w_)+b_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用方程得到预估的房价信息</span></span><br><span class="line">fun(w_, b_, X_test).round(<span class="number">1</span>)   <span class="comment"># round(1)保留一位小数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([31.3, 13.4, 28.6, 20.5, 20.4, 19.4, 32.2, 24. , 25.8, 29.5, 24.5,</span></span><br><span class="line"><span class="string">       25.2, 31.9,  8.2, 20.9, 29.3, 22.3, 35.2, 16.4, 18.5, 30.8, 41.1,</span></span><br><span class="line"><span class="string">       16.2, 13.7, 17.7, 23.8,  7.8, 12. , 20.5, 15.3, 29.3, 26.8, 31.8,</span></span><br><span class="line"><span class="string">       26. , 30.4, 39.2, 25.3, 40.7, 11.6, 27.3, 16.7, 18.8, 19.5, 19.9,</span></span><br><span class="line"><span class="string">       20.7, 22.8, 17.4, 21.6, 23.3, 30. , 25.2, 23.7, 34.2, 18.2, 33.5,</span></span><br><span class="line"><span class="string">       16. , 28.3, 14.1, 24.2, 16.2, 16.7, 23.5, 16. , 21.4, 21.8, 28.2,</span></span><br><span class="line"><span class="string">       25.7, 31.2, 18.8, 26.4, 28.3, 21.9, 27.5, 27.1, 27.1, 15. , 26. ,</span></span><br><span class="line"><span class="string">       26.3, 13.2, 13.3, 26.1, 20.5, 16.8, 24.3, 36.6, 21.4,  8.3, 27.8,</span></span><br><span class="line"><span class="string">        3.6, 19.2, 27.5, 33.6, 28.4, 34.3, 28.2, 13.3, 18. , 23.5, 30.4,</span></span><br><span class="line"><span class="string">       32.9, 23.7, 30.5, 19.8, 19.5, 18.7, 30.9, 36.3,  8. , 18.2, 13.9,</span></span><br><span class="line"><span class="string">       15. , 26.4, 24. , 30.2, 20. ,  5.6, 21.4, 22.9, 17.6, 32.8, 22.1,</span></span><br><span class="line"><span class="string">       32.6, 20.9, 19.3, 23.1, 21. , 21.5])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用sklesrn中的线性模型得到的预估房价信息</span></span><br><span class="line">linear.predict(X_test).round(<span class="number">1</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([31.3, 13.4, 28.6, 20.5, 20.4, 19.4, 32.2, 24. , 25.8, 29.5, 24.5,</span></span><br><span class="line"><span class="string">       25.2, 31.9,  8.2, 20.9, 29.3, 22.3, 35.2, 16.4, 18.5, 30.8, 41.1,</span></span><br><span class="line"><span class="string">       16.2, 13.7, 17.7, 23.8,  7.8, 12. , 20.5, 15.3, 29.3, 26.8, 31.8,</span></span><br><span class="line"><span class="string">       26. , 30.4, 39.2, 25.3, 40.7, 11.6, 27.3, 16.7, 18.8, 19.5, 19.9,</span></span><br><span class="line"><span class="string">       20.7, 22.8, 17.4, 21.6, 23.3, 30. , 25.2, 23.7, 34.2, 18.2, 33.5,</span></span><br><span class="line"><span class="string">       16. , 28.3, 14.1, 24.2, 16.2, 16.7, 23.5, 16. , 21.4, 21.8, 28.2,</span></span><br><span class="line"><span class="string">       25.7, 31.2, 18.8, 26.4, 28.3, 21.9, 27.5, 27.1, 27.1, 15. , 26. ,</span></span><br><span class="line"><span class="string">       26.3, 13.2, 13.3, 26.1, 20.5, 16.8, 24.3, 36.6, 21.4,  8.3, 27.8,</span></span><br><span class="line"><span class="string">        3.6, 19.2, 27.5, 33.6, 28.4, 34.3, 28.2, 13.3, 18. , 23.5, 30.4,</span></span><br><span class="line"><span class="string">       32.9, 23.7, 30.5, 19.8, 19.5, 18.7, 30.9, 36.3,  8. , 18.2, 13.9,</span></span><br><span class="line"><span class="string">       15. , 26.4, 24. , 30.2, 20. ,  5.6, 21.4, 22.9, 17.6, 32.8, 22.1,</span></span><br><span class="line"><span class="string">       32.6, 20.9, 19.3, 23.1, 21. , 21.5])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p><strong><font color=red>通过自建模型获取预估数据与使用模型获取预估数据进行比较,两组数据完全一致;</font></strong></p>
<h3 id="五-使用线性回归-求解斜率和截距"><a href="#五-使用线性回归-求解斜率和截距" class="headerlink" title="(五): 使用线性回归,求解斜率和截距"></a>(五): 使用线性回归,求解斜率和截距</h3><ul>
<li>根据最小二乘法: $\min_{w}||Xw-y||_2^2$ 推到得出公式: $w = (X^TX)^{-1}X^Ty$</li>
</ul>
<p>以上公式只能求出w,我们可以先求出w再计算出b;</p>
<ul>
<li><p>但此处我们有更简单的方法:</p>
<p>根据线性回归方程 $ f(x) = w_1x_1+w_2x_2+b$ 我们可以将方程中的b看成是$w_3x_3^0$, </p>
</li>
</ul>
<p>所以可得: $f(x) = w_1x_1^1+w_2x_2^1+w_3x_3^0$</p>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line">X, y = datasets.load_boston(<span class="literal">True</span>)</span><br><span class="line">linear = LinearRegression()</span><br><span class="line">linear.fit(X,y)</span><br><span class="line">w_ = linear.coef_</span><br><span class="line">b_ = linear.intercept_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向X中插入一列全是1的数据(任何数的0次方都是1)</span></span><br><span class="line">X = np.concatenate([X, np.ones(shape = (<span class="number">506</span>, <span class="number">1</span>))], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据最小二乘法的推导公式:w和b的值为(最后一个值是b)</span></span><br><span class="line">w = ((np.linalg.inv(X.T.dot(X))).dot(X.T)).dot(y)</span><br><span class="line"><span class="comment"># 以上w的写法过于装逼,所以分解为:</span></span><br><span class="line"><span class="comment"># A = X.T.dot(X)   求X和转置后的X的内积(公式中的XTX)</span></span><br><span class="line"><span class="comment"># B = np.linalg.inv(A)   求A的逆矩阵(公式中的-1次方)</span></span><br><span class="line"><span class="comment"># C = B.dot(X.T)   求以上矩阵和X的转置矩阵的内积(公式中的XT)</span></span><br><span class="line"><span class="comment"># w = C.dot(y)   与y求内积,得出w和b</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">运行结果:</span></span><br><span class="line"><span class="string">array([-1.08011358e-01,  4.64204584e-02,  2.05586264e-02,  2.68673382e+00,</span></span><br><span class="line"><span class="string">       -1.77666112e+01,  3.80986521e+00,  6.92224640e-04, -1.47556685e+00,</span></span><br><span class="line"><span class="string">        3.06049479e-01, -1.23345939e-02, -9.52747232e-01,  9.31168327e-03,</span></span><br><span class="line"><span class="string">       -5.24758378e-01,  3.64594884e+01])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">print(b_)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">运行结果:</span></span><br><span class="line"><span class="string">36.45948838509001</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="扩展一-最小二乘法和向量范数"><a href="#扩展一-最小二乘法和向量范数" class="headerlink" title="扩展一: 最小二乘法和向量范数"></a>扩展一: 最小二乘法和向量范数</h2><p>$\min_{w}||Xw-y||_2^2$</p>
<ul>
<li>右上角的2是平方</li>
<li>右下角的2是向量2范数</li>
<li>竖线内的表达式是向量</li>
</ul>
<p><strong>根据最小二乘法的公式, 推导得出</strong></p>
<p>$$w = (X^TX)^{-1}X^Ty$$</p>
<p><strong>向量的1-范数(表示各个元素的绝对值的和)</strong></p>
<p>$$||X||_1 = \sum\limits_{i=1}^n |x_i|$$</p>
<p><strong>向量的2-范数(表示每个元素的平方和再开平方)</strong></p>
<p>$$||X||_2 = \sqrt{\sum\limits_{i=1}^n x_i^2}$$</p>
<p><strong>向量的无穷范数(所有向量元素绝对值中的最大值)</strong></p>
<p>$$||X||_{\infty} = \max\limits_{1 \geq i \leq n}|X_i|$$</p>
<h2 id="扩展二-导数-偏导数"><a href="#扩展二-导数-偏导数" class="headerlink" title="扩展二: 导数, 偏导数"></a>扩展二: 导数, 偏导数</h2><p><strong>导数:</strong><br>对函数$f(x) = x^2+3x+8$ 求导得: $f(x)’ = 2x+3$</p>
<p>求导规则: </p>
<ul>
<li>参数求导为0</li>
<li>参数乘变量求导为常数</li>
<li>变量的次方求导: $x^y$求导为$yx^{y-1}$</li>
<li>复合函数求导:<ul>
<li>$(x^2-x)^2$求导: 先将括号看成一个整体求导, 结果再乘以括号内的求导结果</li>
<li>$2(x^2-x)(2x-1)$</li>
</ul>
</li>
</ul>
<p><strong>偏导数:</strong><br>有多个变量得函数求导:</p>
<p>对函数: $f(x, y) = x^2+xy+y^2$ 求导:</p>
<p>求导规则: 多变量函数只能针对某一个变量求导,此时将其他变量看成常数</p>
<p>将x看成常数a: $f_a(y) = a^2+ay+y^2$</p>
<p>求导得:$f_a’(y) = a+2y$</p>
<p>故求导得: $\frac{\partial f}{\partial y}(x,y)=x+2y$</p>
<p><strong>实现线性回归的两种方式:</strong></p>
<ol>
<li><p>正规方程</p>
</li>
<li><p>梯度下降</p>
</li>
</ol>
<br>



<h1 id="二-正规方程"><a href="#二-正规方程" class="headerlink" title="二: 正规方程"></a>二: 正规方程</h1><h2 id="一-损失函数"><a href="#一-损失函数" class="headerlink" title="(一): 损失函数"></a>(一): 损失函数</h2><p><strong>最小二乘法:</strong></p>
<p>$$\min\limits_{w}||Xw-y||_2^2$$</p>
<p><strong>当X和y都是常数时,按照向量2范数将上面的最小二乘法解开:</strong></p>
<p>$$f(w)=(Xw-y)^2$$</p>
<p><strong>将X,y替换成常数a,b</strong></p>
<p>$$f(w)=(aw-b)^2$$</p>
<p>$$f(w)=a^2w^2 - 2abw + b^2$$</p>
<p>​        由于最小二乘法方程的函数值都是大雨或等于0的,所以此时得到一个开口向</p>
<p>上的抛物线(一元二次方程)</p>
<p>​        此时的$f(w)$就是损失函数,在此时求该函数的导数(抛物线函数顶点的导数为0)</p>
<p>就能得到该函数的最小值,也就是最小损失</p>
<p>$$f’(w)=2a^2w-2ab=0$$</p>
<p><strong>此时即可算出最小的$w$,即最小损失</strong></p>
<h2 id="二-矩阵常用求导公式"><a href="#二-矩阵常用求导公式" class="headerlink" title="(二): 矩阵常用求导公式"></a>(二): 矩阵常用求导公式</h2><p><strong>X的转置矩阵对X矩阵求导, 求解出来是单位矩阵</strong></p>
<ul>
<li><p>$$\frac{dX^T}{dX} = I$$ </p>
</li>
<li><p>$$\frac{dX}{dX^T} = I$$</p>
</li>
</ul>
<p><strong>X的转置矩阵和一个常数矩阵相乘再对X矩阵求导, 求解出来就是改常数矩阵</strong></p>
<ul>
<li>$$\frac{dX^TA}{dX} = A$$ </li>
<li>$$\frac{dAX}{dX} = A^T$$</li>
<li>$$\frac{dXA}{dX} = A^T$$</li>
<li>$$\frac{dAX}{dX^T} = A$$</li>
</ul>
<h2 id="三-正规方程矩阵推导过程"><a href="#三-正规方程矩阵推导过程" class="headerlink" title="(三): 正规方程矩阵推导过程"></a>(三): 正规方程矩阵推导过程</h2><p><font color=red>此时X,w,y都是矩阵</font></p>
<h3 id="1-公式化简"><a href="#1-公式化简" class="headerlink" title="1: 公式化简"></a>1: 公式化简</h3><p><strong>1: 最小二乘法:</strong></p>
<p>$$f(w) = ||Xw-y||_2^2$$</p>
<p><strong>2: 向量2范数:</strong></p>
<p>$$||X||<em>2 = \sqrt{\sum\limits</em>{i = 1}^nx_i^2}$$</p>
<p><strong>3: 将向量2范数的公式带入到最小二乘法中得:</strong></p>
<p>$$f(w)=(\sqrt{(Xw-y)^2})^2$$</p>
<p><strong>4. 化简:</strong></p>
<p>$$f(w)=(Xw-y)^2$$</p>
<p><font color=red>由于X, w, y都是矩阵, 运算后还是矩阵; 矩阵得乘法是一个矩阵得行和另一个矩阵得列相乘; 所以矩阵的平方就是该矩阵乘以他本身的转置矩阵</font></p>
<p><strong>5. 所以:</strong></p>
<p>$$f(w)=(Xw-y)^T(Xw-y)$$</p>
<p><strong>6. 展开:</strong></p>
<p><font color=red>注意: 整体转置变成每个元素都转置时,若是有乘法, 则相乘的两个矩阵要交换位置; 如下所示!!!</font></p>
<p>$$f(w)=(w^TX^T-y^T)(Xw-y)$$</p>
<p>$$f(w)=w^TX^TXw-w^TX^Ty-y^TXw+y^Ty$$</p>
<p><font color=red>注意: 若想交换两个相乘的矩阵再算式中的位置,则交换之后双方都需要转置一次; 如下所示!!!</font></p>
<p>$$f(w)=w^TX^TXw-(X^Ty)^T(w^T)^T-y^TXw+y^Ty$$</p>
<p>$$f(w)=w^TX^TXw-y^TXw-y^TXw+y^Ty$$</p>
<p>$$f(w) = w^TX^TXw - 2y^TXw + y^Ty $$</p>
<h3 id="2-求导"><a href="#2-求导" class="headerlink" title="2: 求导"></a>2: 求导</h3><p>$$f(w) = w^TX^TXw - 2y^TXw + y^Ty $$</p>
<p><strong>这里 $y^Ty$ 是常数求导后为0</strong></p>
<p><strong>$2y^TXw$ 求导:</strong></p>
<p>$$\frac{d(2y^TX)w}{dw}=(2y^TX)^T=2X^T(y^T)^T=2X^Ty$$</p>
<p><strong>$w^TX^TXw$求导:</strong></p>
<p>$$\frac{dw^TX^TXw}{dw}=\frac{d(w^TX^TX)w}{dw}+\frac{dw^T(X^TXw)}{dw}=(w^TX^TX)^T+X^TXw=X^T(X^T)^T(w^T)^T+X^TXw=2X^TXw$$</p>
<p><strong>所以:</strong></p>
<p>$$f’(w) =  2X^TXw - 2X^Ty$$</p>
<p><strong>令$f’(w)=0$,则:</strong></p>
<p>$$2X^TXw - 2X^Ty = 0$$</p>
<p>$$X^TXw=X^Ty$$</p>
<p><strong>矩阵运算没有除法,可以用逆矩阵实现除法的效果</strong></p>
<p><strong>等式两边同时乘以$X^TX$的逆矩阵$(X^TX)^{-1}$</strong></p>
<p>$$(X^TX)^{-1}(X^TX)w=(X^TX)^{-1}X^Ty$$</p>
<p>$$Iw=(X^TX)^{-1}X^Ty$$  <strong>I是单位矩阵</strong></p>
<p><strong>得到正规方程:</strong></p>
<p>$$w=(X^TX)^{-1}X^Ty$$</p>
<h2 id="四-数据挖掘实例-预测2020年淘宝双十一交易额"><a href="#四-数据挖掘实例-预测2020年淘宝双十一交易额" class="headerlink" title="(四): 数据挖掘实例(预测2020年淘宝双十一交易额)"></a>(四): 数据挖掘实例(预测2020年淘宝双十一交易额)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"></span><br><span class="line">X = np.arange(<span class="number">2009</span>, <span class="number">2020</span>)   <span class="comment"># 年份</span></span><br><span class="line">X = X <span class="number">-2008</span>   <span class="comment"># 年份数值太大,差别不明显</span></span><br><span class="line">y = np.array([<span class="number">0.5</span>, <span class="number">9.36</span>, <span class="number">52</span>, <span class="number">191</span>, <span class="number">350</span>, <span class="number">571</span>, <span class="number">912</span>, <span class="number">1207</span>, <span class="number">1682</span>, <span class="number">2135</span>, <span class="number">2684</span>])   <span class="comment"># 09年到19年的交易额</span></span><br></pre></td></tr></table></figure>
<p><strong>假设X和y之间是一元三次的关系(按照前几年的数据走势提出的假设)</strong></p>
<p>$$f(x)=w_1x+w_2x^2+w_3x^3+b$$</p>
<p>$$f(x)=w_0x^0+w_1x^1+w_2x^2+w_3x^3$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># X_oo = np.concatenate([a,a])   # 横着级联</span></span><br><span class="line">X_train = np.c_[X**<span class="number">0</span>, X**<span class="number">1</span>, X**<span class="number">2</span>, X**<span class="number">3</span>]   <span class="comment"># 竖着级联</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[   1,    1,    1,    1],</span></span><br><span class="line"><span class="string">       [   1,    2,    4,    8],</span></span><br><span class="line"><span class="string">       [   1,    3,    9,   27],</span></span><br><span class="line"><span class="string">       [   1,    4,   16,   64],</span></span><br><span class="line"><span class="string">       [   1,    5,   25,  125],</span></span><br><span class="line"><span class="string">       [   1,    6,   36,  216],</span></span><br><span class="line"><span class="string">       [   1,    7,   49,  343],</span></span><br><span class="line"><span class="string">       [   1,    8,   64,  512],</span></span><br><span class="line"><span class="string">       [   1,    9,   81,  729],</span></span><br><span class="line"><span class="string">       [   1,   10,  100, 1000],</span></span><br><span class="line"><span class="string">       [   1,   11,  121, 1331]], dtype=int32)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">linear = LinearRegression(fit_intercept=<span class="literal">False</span>)   <span class="comment"># 声明算法; fit_intercept=False将截距设置为0, w0就是截距</span></span><br><span class="line">linear.fit(X_train, y)   <span class="comment"># 训练</span></span><br><span class="line">w_ = linear.coef_</span><br><span class="line">print(linear.coef_.round(<span class="number">2</span>))   <span class="comment"># 获取系数</span></span><br><span class="line">print(linear.intercept_)   <span class="comment"># 获取截距</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[ 58.77 -84.06  27.95   0.13]</span></span><br><span class="line"><span class="string">0.0</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p><strong>可以得到方程:</strong></p>
<p>$$f(x)=58.77-84.06x+27.95x^2+0.13x^3$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_test = np.linspace(<span class="number">0</span>,<span class="number">12</span>,<span class="number">126</span>)   <span class="comment"># 线性分割(将0,12之间分成126分)等差数列包含1和12</span></span><br><span class="line">X_test = np.c_[X_test**<span class="number">0</span>, X_test**<span class="number">1</span>, X_test**<span class="number">2</span>, X_test**<span class="number">3</span>]   <span class="comment"># 和训练数据保持一致</span></span><br><span class="line">y_ = linear.predict(X_test)   <span class="comment"># 使用模型预测</span></span><br><span class="line">plt.plot(np.linspace(<span class="number">0</span>,<span class="number">12</span>,<span class="number">126</span>), y_, color=<span class="string">'g'</span>)   <span class="comment"># 绘制预测方程曲线</span></span><br><span class="line">plt.scatter(np.arange(<span class="number">1</span>,<span class="number">12</span>), y, color=<span class="string">'red'</span>)   <span class="comment"># 绘制每年的真实销量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line">fun = <span class="keyword">lambda</span> x : w_[<span class="number">0</span>] + w_[<span class="number">1</span>]*x + w_[<span class="number">2</span>]*x**<span class="number">2</span> + w_[<span class="number">-1</span>]*x**<span class="number">3</span></span><br><span class="line"></span><br><span class="line">fun(<span class="number">12</span>)</span><br><span class="line"><span class="string">'''3294.2775757576132'''</span></span><br></pre></td></tr></table></figure>




<br>




<h1 id="三-梯度下降"><a href="#三-梯度下降" class="headerlink" title="三: 梯度下降"></a>三: 梯度下降</h1><p>​        梯度下降法的基本思想可以类比为一个下山的过程。假设这样一个场景：一个人被困在山上，需要从山上下</p>
<p>来(i.e. 找到山的最低点，也就是山谷)。但此时山上的浓雾很大，导致可视度很低。因此，下山的路径就无法确</p>
<p>定，他必须利用自己周围的信息去找到下山的路径。这个时候，他就可以利用梯度下降算法来帮助自己下山。具体</p>
<p>来说就是，以他当前的所处的位置为基准，寻找这个位置最陡峭的地方，然后朝着山的高度下降的地方走，同理，</p>
<p>如果我们的目标是上山，也就是爬到山顶，那么此时应该是朝着最陡峭的方向往上走。然后每走一段距离，都反复</p>
<p>采用同一个方法，最后就能成功的抵达山谷。</p>
<h2 id="一-梯度下降"><a href="#一-梯度下降" class="headerlink" title="(一): 梯度下降"></a>(一): 梯度下降</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = <span class="keyword">lambda</span> w : (w <span class="number">-3.5</span>)**<span class="number">2</span> <span class="number">-4.5</span>*w +<span class="number">10</span></span><br><span class="line">d = <span class="keyword">lambda</span> w : <span class="number">2</span>*(w<span class="number">-3.5</span>)<span class="number">-4.5</span>   <span class="comment"># 梯度 == 导数</span></span><br><span class="line">step = <span class="number">0.1</span>   <span class="comment"># 梯度下降的步幅,比率,学习率(默认是1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求当w(x值)为多少时,得到的函数值最小</span></span><br><span class="line"></span><br><span class="line">w = np.random.randint(<span class="number">0</span>,<span class="number">11</span>,size=<span class="number">1</span>)[<span class="number">0</span>]   <span class="comment"># 随机生成一个初始值数</span></span><br><span class="line">last_w = w + <span class="number">0.1</span>   <span class="comment"># 梯度下降,每走一步,目标值,都会更新</span></span><br><span class="line">precision = <span class="number">1e-4</span>   <span class="comment"># 精确率(误差率,越小越精确,并不是越小越好)</span></span><br><span class="line">print(<span class="string">'==============更新前的w:'</span>, w)</span><br><span class="line">w_ = [w]</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> np.abs(w - last_w) &lt; precision:    <span class="comment"># 退出条件</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    last_w = w    <span class="comment"># 更新</span></span><br><span class="line">    w -= step*d(w)   </span><br><span class="line">    <span class="comment"># 随机初始值在目标值的左边时, d(w)为负, w = w-step*d(w) 会使得w慢慢变大趋近目标值</span></span><br><span class="line">    <span class="comment"># 随机初始值在目标值的右边时, d(w)为正, w = w-step*d(w) 会使得w慢慢变小趋近目标值</span></span><br><span class="line">    w_.append(w)</span><br><span class="line">    print(<span class="string">'==============更新后的w:'</span>, w)</span><br></pre></td></tr></table></figure>




<h2 id="二-梯度下降实现线性回归"><a href="#二-梯度下降实现线性回归" class="headerlink" title="(二): 梯度下降实现线性回归"></a>(二): 梯度下降实现线性回归</h2><h3 id="1-构造数据"><a href="#1-构造数据" class="headerlink" title="1. 构造数据"></a>1. 构造数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X = np.linspace(<span class="number">-2</span>, <span class="number">12</span>, <span class="number">40</span>).reshape(<span class="number">40</span>,<span class="number">1</span>)   </span><br><span class="line"><span class="comment"># reshape(40,1)改变形状; 40这个位置可以写成-1, 此时-1代表40; 当后面的1变为2时,此时-1代表20; 也就是说当后面的数值变化时,系统自动用前面规定的总数计算出相应的结果,而这些结果都可以用-1代替; </span></span><br><span class="line">w = np.random.randint(<span class="number">1</span>,<span class="number">9</span>,size = <span class="number">1</span>)   <span class="comment"># 系数</span></span><br><span class="line">b = np.random.randint(<span class="number">-5</span>,<span class="number">5</span>,size = <span class="number">1</span>)   <span class="comment"># 截距</span></span><br><span class="line">y = w*X + b + np.random.randn(<span class="number">40</span>,<span class="number">1</span>) * <span class="number">2</span>   <span class="comment"># 增加噪声</span></span><br><span class="line">plt.scatter(X, y)   <span class="comment"># 绘点</span></span><br></pre></td></tr></table></figure>



<h3 id="2-使用sklearn中的回归-梯度下降方法计算斜率和截距"><a href="#2-使用sklearn中的回归-梯度下降方法计算斜率和截距" class="headerlink" title="2. 使用sklearn中的回归 - 梯度下降方法计算斜率和截距"></a>2. 使用sklearn中的回归 - 梯度下降方法计算斜率和截距</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">linear = LinearRegression()   <span class="comment"># 定义算法</span></span><br><span class="line">linear.fit(X, y)  <span class="comment"># 训练</span></span><br><span class="line">X_test = np.linspace(<span class="number">-2</span>,<span class="number">12</span>,<span class="number">256</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)   <span class="comment"># 预测数据</span></span><br><span class="line">y_ = linear.predict(X_test)   <span class="comment"># 预测结果</span></span><br><span class="line">print(<span class="string">'真实斜率和截距'</span>, w, b)</span><br><span class="line">print(<span class="string">'算法计算的斜率和截距'</span>, linear.coef_, linear.intercept_)  <span class="comment"># 截距和斜率</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">真实斜率和截距 [5] [3]</span></span><br><span class="line"><span class="string">算法计算的斜率和截距 [[4.91521288]] [3.06426015]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">plt.plot(X_test, y_, color=<span class="string">'g'</span>)   <span class="comment"># 绘制线性回归方程</span></span><br><span class="line">plt.scatter(X, y, color=<span class="string">'r'</span>)   <span class="comment"># 绘制实际的点</span></span><br></pre></td></tr></table></figure>



<h3 id="3-自定义梯度下降的类实现sklearn中的回归-梯度功能"><a href="#3-自定义梯度下降的类实现sklearn中的回归-梯度功能" class="headerlink" title="3.自定义梯度下降的类实现sklearn中的回归 - 梯度功能"></a>3.自定义梯度下降的类实现sklearn中的回归 - 梯度功能</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearModel</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>   <span class="comment"># 初始化, 随机给定截距和斜率</span></span><br><span class="line">        self.w = np.random.randn(<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">        self.b = np.random.randn(<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.w*x + self.b   <span class="comment"># 一元一次线性方程; 模型</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(self,x,y)</span>:</span><span class="comment">#损失，最小二乘法</span></span><br><span class="line">        cost = (self.model(x) - y)**<span class="number">2</span> <span class="comment"># 损失函数越小越好</span></span><br><span class="line">        <span class="comment"># 求解梯度，两个未知数，所以，偏导</span></span><br><span class="line">        d_w = <span class="number">2</span>*(self.model(x) - y)*x <span class="comment"># 斜率w的偏导</span></span><br><span class="line">        d_b = <span class="number">2</span>*(self.model(x) - y)*<span class="number">1</span> <span class="comment"># 截距b的偏导</span></span><br><span class="line">        <span class="keyword">return</span> cost,d_w,d_b</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span><span class="params">(self, step, d_w, d_b)</span>:</span>   <span class="comment"># 梯度下降</span></span><br><span class="line">        self.w -= step*d_w  <span class="comment"># 更新斜率</span></span><br><span class="line">        self.b -= step*d_b  <span class="comment"># 更新截距</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y)</span>:</span>   <span class="comment"># 训练模型, 将数据给模型,寻找规律</span></span><br><span class="line">        precision = <span class="number">1e-4</span>   <span class="comment"># 精确度</span></span><br><span class="line">        last_w = self.w + <span class="number">0.01</span></span><br><span class="line">        last_b = self.b + <span class="number">0.01</span></span><br><span class="line">        </span><br><span class="line">        print(<span class="string">'------------------------初始的截距和斜率:'</span>, self.w, self.b)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> (np.abs(self.w-last_w) &lt; precision) &amp; (np.abs(self.b-last_b) &lt; precision):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            last_w = self.w   <span class="comment"># 更新之前,先保留记录</span></span><br><span class="line">            last_b = self.b</span><br><span class="line">            </span><br><span class="line">            cost_ = <span class="number">0</span></span><br><span class="line">            dw_ = <span class="number">0</span></span><br><span class="line">            db_ = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">40</span>):   <span class="comment"># 计算40个，返回40个偏导数，求平均值</span></span><br><span class="line">                cost,dw,db = self.loss(X[i,<span class="number">0</span>],y[i,<span class="number">0</span>])</span><br><span class="line">                cost_ += cost/<span class="number">40</span></span><br><span class="line">                dw_ += dw/<span class="number">40</span></span><br><span class="line">                db_ += db/<span class="number">40</span></span><br><span class="line">                </span><br><span class="line">            self.gradient_descent(<span class="number">0.01</span>, dw_, db_)</span><br><span class="line">            print(<span class="string">'------------------------更新后的截距和斜率:'</span>, self.w, self.b)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.model(X)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">model = LinearModel()   <span class="comment"># 定义算法</span></span><br><span class="line">w, b = model.fit(X, y)   <span class="comment"># 获取斜率和截距</span></span><br><span class="line">y_ = model.predict(X_test)   <span class="comment"># 用测试数据获取目标值</span></span><br><span class="line">plt.plot(X_test, y_, color=<span class="string">'g'</span>)   <span class="comment"># 绘制线性方程</span></span><br><span class="line">plt.scatter(X, y, color=<span class="string">'r'</span>)   <span class="comment"># 绘制目标点</span></span><br></pre></td></tr></table></figure>


<h2 id="三-梯度下降-矩阵"><a href="#三-梯度下降-矩阵" class="headerlink" title="(三): 梯度下降(矩阵)"></a>(三): 梯度下降(矩阵)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造数据</span></span><br><span class="line">X = np.linspace(<span class="number">-2</span>, <span class="number">12</span>, <span class="number">40</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">w = np.random.randint(<span class="number">2</span>, <span class="number">12</span>, size=<span class="number">1</span>)</span><br><span class="line">b = np.random.randint(<span class="number">-10</span>, <span class="number">10</span>, size=<span class="number">1</span>)</span><br><span class="line">y = X*w + b + np.random.randn(<span class="number">40</span>, <span class="number">1</span>)*<span class="number">2.5</span></span><br><span class="line">plt.scatter(X, y, color=<span class="string">'r'</span>)</span><br><span class="line">X = np.concatenate([X, np.ones(shape=(<span class="number">40</span>, <span class="number">1</span>))], axis=<span class="number">1</span>)  <span class="comment"># 将截距b看作一个斜率w, 在下面定义的类中要求输入两组X值, 所以此处将X的数据结构变为(40,2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义梯度下降类</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span><span class="params">(X,y)</span>:</span></span><br><span class="line">    theta = np.random.randn(<span class="number">2</span>,<span class="number">1</span>) <span class="comment"># theta中既有斜率，又有截距</span></span><br><span class="line">    last_theta = theta + <span class="number">0.1</span></span><br><span class="line">    precision = <span class="number">1e-4</span></span><br><span class="line">    epsilon = <span class="number">0.01</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 当斜率和截距误差小于万分之一时，退出</span></span><br><span class="line">        <span class="keyword">if</span> (np.abs(theta - last_theta) &lt; precision).all():</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 更新</span></span><br><span class="line">        last_theta = theta.copy()</span><br><span class="line">        theta = theta - epsilon*<span class="number">2</span>/<span class="number">40</span>*X.T.dot(X.dot(theta) - y)</span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">w_,b_ = gradient_descent(X,y)</span><br><span class="line">j = <span class="keyword">lambda</span> x : w_*x + b_</span><br><span class="line">plt.scatter(X[:,<span class="number">0</span>],y,color = <span class="string">'red'</span>)</span><br><span class="line">x_test = np.linspace(<span class="number">-2</span>,<span class="number">12</span>,<span class="number">1024</span>) </span><br><span class="line">y_ = j(x_test)</span><br><span class="line">plt.plot(x_test,y_,color = <span class="string">'green'</span>)</span><br></pre></td></tr></table></figure>


<h2 id="四-随机梯度下降-矩阵-从所有样本中随机获取指定数量的样本"><a href="#四-随机梯度下降-矩阵-从所有样本中随机获取指定数量的样本" class="headerlink" title="(四): 随机梯度下降(矩阵) - 从所有样本中随机获取指定数量的样本"></a>(四): 随机梯度下降(矩阵) - 从所有样本中随机获取指定数量的样本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造数据</span></span><br><span class="line">X = np.linspace(<span class="number">-2</span>,<span class="number">12</span>,<span class="number">40</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">w = np.random.randint(<span class="number">2</span>,<span class="number">12</span>,size = <span class="number">1</span>)</span><br><span class="line">b = np.random.randint(<span class="number">-10</span>,<span class="number">10</span>,size = <span class="number">1</span>)</span><br><span class="line">y = X*w + b + np.random.randn(<span class="number">40</span>,<span class="number">1</span>)*<span class="number">2.5</span></span><br><span class="line"><span class="comment"># 将y.reshape(-1)一维的</span></span><br><span class="line">y = y.reshape(<span class="number">-1</span>)</span><br><span class="line">plt.scatter(X,y,color = <span class="string">'red'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义梯度下降类</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span><span class="params">(X,y)</span>:</span></span><br><span class="line">    m = <span class="number">10</span>   <span class="comment"># 随机样本数量</span></span><br><span class="line">    theta = np.random.randn(<span class="number">2</span>) <span class="comment"># theta中既有斜率，又有截距</span></span><br><span class="line">    last_theta = theta + <span class="number">0.1</span> <span class="comment">#记录theta更新后，和上一步的误差</span></span><br><span class="line">    precision = <span class="number">1e-4</span> <span class="comment">#精确度</span></span><br><span class="line">    epsilon = <span class="number">0.01</span> <span class="comment">#步幅</span></span><br><span class="line">    count= <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 当斜率和截距误差小于万分之一时，退出</span></span><br><span class="line">        <span class="keyword">if</span> (np.abs(theta - last_theta) &lt; precision).all():</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">3000</span>:<span class="comment">#死循环执行了3000次</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 更新</span></span><br><span class="line">        last_theta = theta.copy()</span><br><span class="line">        <span class="comment"># 随机梯度下降，梯度是矩阵计算返回的</span></span><br><span class="line">        index = np.random.choice(np.arange(<span class="number">40</span>),size = m)<span class="comment"># index索引，根据随机索引从原数据中取数据</span></span><br><span class="line">        grad = <span class="number">2</span>/m*X[index].T.dot(X[index].dot(theta) - y[index])</span><br><span class="line">        theta -= epsilon*grad</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line">w_,b_ = gradient_descent(X_train,y)</span><br><span class="line">j = <span class="keyword">lambda</span> x : w_*x + b_</span><br><span class="line">plt.scatter(X[:,<span class="number">0</span>],y,color = <span class="string">'red'</span>)</span><br><span class="line">x_test = np.linspace(<span class="number">-2</span>,<span class="number">12</span>,<span class="number">1024</span>) </span><br><span class="line">y_ = j(x_test)</span><br><span class="line">plt.plot(x_test,y_,color = <span class="string">'green'</span>)</span><br></pre></td></tr></table></figure>

<p><font color=red>若随机样本的数量为1, 则是完全随机梯度下降</font></p>
<br>



<h1 id="四-岭回归"><a href="#四-岭回归" class="headerlink" title="四: 岭回归"></a>四: 岭回归</h1><h2 id="一-岭回归和线性回归的模型对比"><a href="#一-岭回归和线性回归的模型对比" class="headerlink" title="(一): 岭回归和线性回归的模型对比"></a>(一): 岭回归和线性回归的模型对比</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression, Ridge</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line">X, y = datasets.load_boston(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线性回归</span></span><br><span class="line">linear = LinearRegression()</span><br><span class="line">linear.fit(X, y)</span><br><span class="line">w_ = linear.coef_</span><br><span class="line">b_ = linear.intercept_</span><br><span class="line">print(<span class="string">'普通线性回归斜率:\n'</span>, w_)</span><br><span class="line">print(<span class="string">'普通线性回归截距:'</span>, b_)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">普通线性回归斜率:</span></span><br><span class="line"><span class="string"> [-1.08011358e-01  4.64204584e-02  2.05586264e-02  2.68673382e+00</span></span><br><span class="line"><span class="string"> -1.77666112e+01  3.80986521e+00  6.92224640e-04 -1.47556685e+00</span></span><br><span class="line"><span class="string">  3.06049479e-01 -1.23345939e-02 -9.52747232e-01  9.31168327e-03</span></span><br><span class="line"><span class="string"> -5.24758378e-01]</span></span><br><span class="line"><span class="string">普通线性回归截距: 36.45948838509001</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 岭回归</span></span><br><span class="line">ridge = Ridge(alpha=<span class="number">10</span>)</span><br><span class="line">ridge.fit(X, y)</span><br><span class="line">w_ = ridge.coef_</span><br><span class="line">b_ = ridge.intercept_</span><br><span class="line">print(<span class="string">'岭回归斜率:\n'</span>, w_)</span><br><span class="line">print(<span class="string">'岭回归截距:'</span>, b_)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">岭回归斜率:</span></span><br><span class="line"><span class="string"> [-0.10143535  0.0495791  -0.0429624   1.95202082 -2.37161896  3.70227207</span></span><br><span class="line"><span class="string"> -0.01070735 -1.24880821  0.2795956  -0.01399313 -0.79794498  0.01003684</span></span><br><span class="line"><span class="string"> -0.55936642]</span></span><br><span class="line"><span class="string">岭回归截距: 27.467884964141252</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
        <tag>sklearn</tag>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title>聚类算法</title>
    <url>/2020/04/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="一-聚类"><a href="#一-聚类" class="headerlink" title="一: 聚类"></a>一: 聚类</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="(一): 概述"></a>(一): 概述</h2><p><strong>聚类算法</strong> 是机器学习（Mahine Learning）的一种，属于<strong>无监督学习（Unsupervised Learning）</strong>，即数据样本没有数据标签。它的目的是将数据中具有相似特征的数据自动聚为一类。</p>
<p>分类简单来说，就是根据文本的特征或属性，划分到已有的类别中。也就是说，这些类别是已知的，通过对已知分类的数据进行训练和学习，找到这些不同类的特征，再对未分类的数据进行分类。<br>        而聚类的理解更简单，就是你压根不知道数据会分为几类，通过聚类分析将数据或者说用户聚合成几个群体，那就是聚类了。聚类不需要对数据进行训练和学习。</p>
<h2 id="二-聚类算法"><a href="#二-聚类算法" class="headerlink" title="(二): 聚类算法"></a>(二): 聚类算法</h2><p><strong>聚类分析的八类方法</strong></p>
<ol>
<li>划分方法<br>1）K-Means聚类<br>2）K-Medoids聚类<br>3）CLARANS算法<br>4）Canopy算法</li>
<li>层次方法<br>1）BIRCH算法</li>
<li>基于密度的方法<br>1）DBSCAN算法</li>
</ol>
<br>



<h1 id="二-K-Means聚类"><a href="#二-K-Means聚类" class="headerlink" title="二: K-Means聚类"></a>二: K-Means聚类</h1><h2 id="一-原理"><a href="#一-原理" class="headerlink" title="(一): 原理"></a>(一): 原理</h2><p>K-Means算法的思想很简单，对于给定的样本集，按照样本之间的距离大小，将样本集划分为K个簇。让簇内的点尽量紧密的连在一起，而让簇间的距离尽量的大。</p>
<p><strong>举一个简单得例子:</strong></p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmql5gtgmqj20fz0av3zf.jpg" alt="k-means示例.png" style="zoom:80%;" />

<p>上图a表达了初始的数据集，假设k=2。在图b中，我们随机选择了两个k类所对应的类别质心，即图中的红色质心和蓝色质心，然后分别求样本中所有点到这两个质心的距离，并标记每个样本的类别为该样本距离最小的质心的类别，如图c所示，经过计算样本和红色质心和蓝色质心的距离，我们得到了所有样本点的第一轮迭代后的类别。此时我们对我们当前标记为红色和蓝色的点分别求其新的质心，如图d所示，新的红色质心和蓝色质心的位置已经发生了变动。图e和图f重复了我们在图c和图d的过程，即将所有点的类别标记为距离最近的质心的类别并求新的质心。最终我们得到的两个类别如图f。</p>
<h2 id="二-K值的选择"><a href="#二-K值的选择" class="headerlink" title="(二):K值的选择"></a>(二):K值的选择</h2><p>不像监督学习的分类问题和回归问题，我们的无监督聚类没有样本输出，也就没有比较直接的聚类评估方法。但是我们可以从簇内的稠密程度和簇间的离散程度来评估聚类的效果。</p>
<p>常用的方法有<strong>轮廓系数</strong>(Silhouette Coefficient), <strong>调整兰德系数</strong>(Adjusted Rand index)和<strong>CH指标分析</strong>(Calinski-Harabasz Index)</p>
<p><strong>在sklearn中轮廓系数对应的方法是: silhouette_score(X,y_)</strong></p>
<p><strong>在sklearn中调整兰德系数对应的方法是: adjusted_rand_score(y,y_)</strong></p>
<p>Calinski-Harabasz分数值s的数学计算公式是：</p>
<p>$$s(k)=\frac{tr(Bk)}{tr(Wk)}\frac{m−k}{k−1}$$</p>
<p>其中m为训练集样本数，k为类别数。Bk为类别之间的协方差矩阵，Wk为类别内部数据的协方差矩阵。tr为矩阵的迹。</p>
<p>也就是说，类别内部数据的协方差越小越好，类别之间的协方差越大越好，这样的Calinski-Harabasz分数会高。<strong>在scikit-learn中， Calinski-Harabasz Index对应的方法是metrics.calinski_harabaz_score.</strong></p>
<h2 id="三-参数详解"><a href="#三-参数详解" class="headerlink" title="(三): 参数详解"></a>(三): 参数详解</h2><p>用KMeans类的话，一般要注意的仅仅就是k值的选择，即参数n_clusters；</p>
<p><strong>KMeans类的主要参数有：</strong></p>
<p>1) <strong>n_clusters</strong>: 即我们的k值，一般需要多试一些值以获得较好的聚类效果。k值好坏的评估标准在下面会讲。</p>
<p>2）<strong>max_iter</strong>： 最大的迭代次数，一般如果是凸数据集的话可以不管这个值，如果数据集不是凸的，可能很难收敛，此时可以指定最大的迭代次数让算法可以及时退出循环。</p>
<p>3）<strong>n_init：</strong>用不同的初始化质心运行算法的次数。由于K-Means是结果受初始值影响的局部最优的迭代算法，因此需要多跑几次以选择一个较好的聚类效果，默认是10，一般不需要改。如果你的k值较大，则可以适当增大这个值。</p>
<p>4）<strong>init：</strong> 即初始值选择的方式，可以为完全随机选择’random’,优化过的’k-means++’或者自己指定初始化的k个质心。一般建议使用默认的’k-means++’。</p>
<p>5）<strong>algorithm</strong>：有“auto”, “full” or “elkan”三种选择。”full”就是我们传统的K-Means算法， “elkan”是我们原理篇讲的elkan K-Means算法。默认的”auto”则会根据数据值是否是稀疏的，来决定如何选择”full”和“elkan”。一般数据是稠密的，那么就是 “elkan”，否则就是”full”。一般来说建议直接用默认的”auto”</p>
<p><a href="https://www.cnblogs.com/pinard/p/6169370.html" target="_blank" rel="noopener">用scikit-learn学习K-Means聚类 - 刘建平</a></p>
<br>



<h1 id="三-DBSCAN聚类"><a href="#三-DBSCAN聚类" class="headerlink" title="三: DBSCAN聚类"></a>三: DBSCAN聚类</h1><h2 id="一-原理-1"><a href="#一-原理-1" class="headerlink" title="(一): 原理"></a>(一): 原理</h2><p>DBSCAN是一种基于密度的聚类算法，这类密度聚类算法一般假定类别可以通过样本分布的紧密程度决定。同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。</p>
<p>通过将紧密相连的样本划为一类，这样就得到了一个聚类类别。通过将所有各组紧密相连的样本划为各个不同的类别，则我们就得到了最终的所有聚类类别结果。</p>
<p>DBSCAN是基于一组邻域来描述样本集的紧密程度的，参数(ϵ, MinPts)用来描述邻域的样本分布紧密程度。其中，<strong>ϵ描述了某一样本的邻域距离阈值，MinPts描述了某一样本的距离为ϵϵ的邻域中样本个数的阈值。</strong></p>
<p>直白了说就是刚开始随机某个点, <strong>以ϵ为半径画圆, 只要在该圆的范围内的点都会被归纳到相同的类别中, 但是若权重的点的总数没有达到设置的阈值MinPts,则不能形成聚类</strong></p>
<p><img src="https://anjhon-blog-imags-1300562301.cos.ap-nanjing.myqcloud.com/photos/%E8%81%9A%E7%B1%BB/DBSCAN%E5%8E%9F%E7%90%86.gif" alt=""></p>
<h2 id="二-总结"><a href="#二-总结" class="headerlink" title="(二): 总结"></a>(二): 总结</h2><p>和传统的K-Means算法相比，DBSCAN最大的不同就是不需要输入类别数k，当然它最大的优势是可以发现任意形状的聚类簇，而不是像K-Means，一般仅仅使用于凸的样本集聚类。同时它在聚类的同时还可以找出异常点，这点和BIRCH算法类似。</p>
<p>那么我们什么时候需要用DBSCAN来聚类呢？<strong>一般来说，如果数据集是稠密的，并且数据集不是凸的，那么用DBSCAN会比K-Means聚类效果好很多。如果数据集不是稠密的，则不推荐用DBSCAN来聚类。</strong></p>
<p>下面对DBSCAN算法的优缺点做一个总结。</p>
<p><strong>DBSCAN的主要优点有：</strong></p>
<p>1） 可以对任意形状的稠密数据集进行聚类，相对的，K-Means之类的聚类算法一般只适用于凸数据集。</p>
<p>2） 可以在聚类的同时发现异常点，对数据集中的异常点不敏感。</p>
<p>3） 聚类结果没有偏倚，相对的，K-Means之类的聚类算法初始值对聚类结果有很大影响。</p>
<p><strong>DBSCAN的主要缺点有：</strong></p>
<p>1）如果样本集的密度不均匀、聚类间距差相差很大时，聚类质量较差，这时用DBSCAN聚类一般不适合。</p>
<p>2） 如果样本集较大时，聚类收敛时间较长，此时可以对搜索最近邻时建立的KD树或者球树进行规模限制来改进。</p>
<p>3） 调参相对于传统的K-Means之类的聚类算法稍复杂，主要需要对距离阈值ϵϵ，邻域样本数阈值MinPts联合调参，不同的参数组合对最后的聚类效果有较大影响。</p>
<p><a href="https://www.cnblogs.com/pinard/p/6208966.html" target="_blank" rel="noopener">DBSCAN密度聚类算法 - 刘建平</a></p>
<h2 id="三-参数详解-1"><a href="#三-参数详解-1" class="headerlink" title="(三): 参数详解"></a>(三): 参数详解</h2><p>DBSCAN类的重要参数也分为两类，一类是DBSCAN算法本身的参数，一类是最近邻度量的参数，下面我们对这些参数做一个总结。</p>
<p>1）<strong>eps</strong>： DBSCAN算法参数，即我们的ϵϵ-邻域的距离阈值，和样本距离超过ϵϵ的样本点不在ϵϵ-邻域内。默认值是0.5.一般需要通过在多组值里面选择一个合适的阈值。eps过大，则更多的点会落在核心对象的ϵϵ-邻域，此时我们的类别数可能会减少， 本来不应该是一类的样本也会被划为一类。反之则类别数可能会增大，本来是一类的样本却被划分开。</p>
<p>2）<strong>min_samples</strong>： DBSCAN算法参数，即样本点要成为核心对象所需要的ϵϵ-邻域的样本数阈值。默认值是5. 一般需要通过在多组值里面选择一个合适的阈值。通常和eps一起调参。在eps一定的情况下，min_samples过大，则核心对象会过少，此时簇内部分本来是一类的样本可能会被标为噪音点，类别数也会变多。反之min_samples过小的话，则会产生大量的核心对象，可能会导致类别数过少。</p>
<p><a href="https://www.cnblogs.com/pinard/p/6217852.html" target="_blank" rel="noopener">用scikit-learn学习DBSCAN聚类 - 刘建平</a></p>
<h2 id="四-实例"><a href="#四-实例" class="headerlink" title="(四): 实例"></a>(四): 实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans,DBSCAN</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据</span></span><br><span class="line"><span class="comment"># y中是两类：0,1</span></span><br><span class="line">X,y = datasets.make_circles(n_samples=<span class="number">1000</span>,noise=<span class="number">0.05</span>,factor = <span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># centers = [(1.5,1.5)] 元组，代表着，中心点的坐标值</span></span><br><span class="line"><span class="comment"># y1一类：0 + 2</span></span><br><span class="line">X1,y1 = datasets.make_blobs(n_samples=<span class="number">500</span>,n_features=<span class="number">2</span>,centers=[(<span class="number">1.5</span>,<span class="number">1.5</span>)],cluster_std=<span class="number">0.2</span>)</span><br><span class="line"><span class="comment"># 将circle和散点进行了数据合并</span></span><br><span class="line">X = np.concatenate([X,X1])</span><br><span class="line">y = np.concatenate([y,y1 + <span class="number">2</span>])</span><br><span class="line">plt.scatter(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],c = y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># DBSCAN聚类</span></span><br><span class="line">dbscan = DBSCAN(eps = <span class="number">0.2</span>,min_samples=<span class="number">5</span>)</span><br><span class="line">dbscan.fit(X)</span><br><span class="line">y_ = dbscan.labels_</span><br><span class="line">plt.scatter(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],c = y_)</span><br></pre></td></tr></table></figure>

<p><img src="https://anjhon-blog-imags-1300562301.cos.ap-nanjing.myqcloud.com/photos/%E8%81%9A%E7%B1%BB/DBSCAN%E8%81%9A%E7%B1%BB%E5%AE%9E%E4%BE%8B.jpg" alt=""></p>
<br>



<h1 id="四-BIRCH聚类"><a href="#四-BIRCH聚类" class="headerlink" title="四: BIRCH聚类"></a>四: BIRCH聚类</h1><p>BIRCH聚类算法是用层次方法来聚类和规约数据的,.</p>
<h2 id="一-聚类特征数"><a href="#一-聚类特征数" class="headerlink" title="(一): 聚类特征数"></a>(一): 聚类特征数</h2><p>BIRCH聚类算法的主要过程其实就是在构建一颗CF tree(聚类特征数);</p>
<p>这颗树的每一个节点是由若干个聚类特征(Clustering Feature，简称CF)组成。从下图我们可以看看聚类特征树是什么样子的：每个节点包括叶子节点都有若干个CF，而内部节点的CF有指向孩子节点的指针，所有的叶子节点用一个双向链表链接起来。</p>
<p><img src="https://anjhon-blog-imags-1300562301.cos.ap-nanjing.myqcloud.com/photos/%E8%81%9A%E7%B1%BB/%E8%81%9A%E7%B1%BB%E7%89%B9%E5%BE%81%E6%A0%911.png" alt=""></p>
<p>CF有一个很好的性质，就是满足线性关系，也就是CF1+CF2=(N1+N2,LS1+LS2,SS1+SS2)CF1+CF2=(N1+N2,LS1+LS2,SS1+SS2)。这个性质从定义也很好理解。如果把这个性质放在CF Tree上，也就是说，在CF Tree中，对于每个父节点中的CF节点，它的(N,LS,SS)三元组的值等于这个CF节点所指向的所有子节点的三元组之和。如下图所示：</p>
<p><img src="https://anjhon-blog-imags-1300562301.cos.ap-nanjing.myqcloud.com/photos/%E8%81%9A%E7%B1%BB/%E8%81%9A%E7%B1%BB%E7%89%B9%E5%BE%81%E6%A0%91.png" alt=""></p>
<p>从上图中可以看出，根节点的CF1的三元组的值，可以从它指向的6个子节点（CF7 - CF12）的值相加得到。这样我们在更新CF Tree的时候，可以很高效。</p>
<p>对于CF Tree，我们一般有几个重要参数，第一个参数是每个内部节点的最大CF数B，第二个参数是每个叶子节点的最大CF数L，第三个参数是针对叶子节点中某个CF中的样本点来说的，它是叶节点每个CF的最大样本半径阈值T，<font color=red>也就是说，在这个CF中的所有样本点一定要在半径小于T的一个超球体内。对于上图中的CF Tree，限定了B=7， L=5， 也就是说内部节点最多有7个CF，而叶子节点最多有5个CF。</font></p>
<h2 id="二-BIRCH聚类原理"><a href="#二-BIRCH聚类原理" class="headerlink" title="(二): BIRCH聚类原理"></a>(二): BIRCH聚类原理</h2><p>在最开始的时候，CF Tree是空的，没有任何样本，我们从训练集读入第一个样本点，将它放入一个新的CF三元组A，这个三元组的N=1，将这个新的CF放入根节点</p>
<p>继续读入第二个样本点，我们发现这个样本点和第一个样本点A，在半径为T的超球体范围内，也就是说，他们属于一个CF，我们将第二个点也加入CF A,此时需要更新A的三元组的值。</p>
<p>此时来了第三个节点，结果我们发现这个节点不能融入刚才前面的节点形成的超球体内，也就是说，我们需要一个新的CF三元组B，来容纳这个新的值。此时根节点有两个CF三元组A和B</p>
<p><strong>BIRCH聚类和K-Mean聚类的区别就是是否有连通性约束</strong></p>
<p><img src="https://anjhon-blog-imags-1300562301.cos.ap-nanjing.myqcloud.com/photos/%E8%81%9A%E7%B1%BB/%E8%BF%9E%E9%80%9A%E6%80%A7%E7%BA%A6%E6%9D%9F1.png" alt=""></p>
<p><img src="https://anjhon-blog-imags-1300562301.cos.ap-nanjing.myqcloud.com/photos/%E8%81%9A%E7%B1%BB/%E8%BF%9E%E9%80%9A%E6%80%A7%E7%BA%A6%E6%9D%9F2.png" alt=""></p>
<p><strong>总结:</strong> </p>
<ol>
<li><p>从根节点向下寻找和新样本距离最近的叶子节点和叶子节点里最近的CF节点</p>
</li>
<li><p>如果新样本加入后，这个CF节点对应的超球体半径仍然满足小于阈值T，则更新路径上所有的CF三元组，插入结束。否则转入3.</p>
</li>
<li><p>如果当前叶子节点的CF节点个数小于阈值L，则创建一个新的CF节点，放入新样本，将新的CF节点放入这个叶子节点，更新路径上所有的CF三元组，插入结束。否则转入4。</p>
</li>
<li><p>将当前叶子节点划分为两个新叶子节点，选择旧叶子节点中所有CF元组里超球体距离最远的两个CF元组，分布作为两个新叶子节点的第一个CF节点。将其他元组和新样本元组按照距离远近原则放入对应的叶子节点。依次向上检查父节点是否也要分裂，如果需要按和叶子节点分裂方式相同。</p>
</li>
</ol>
<h2 id="三-算法小结"><a href="#三-算法小结" class="headerlink" title="(三): 算法小结"></a>(三): 算法小结</h2><p>BIRCH算法可以不用输入类别数K值，这点和K-Means，Mini Batch K-Means不同。如果不输入K值，则最后的CF元组的组数即为最终的K，否则会按照输入的K值对CF元组按距离大小进行合并。</p>
<p>一般来说，BIRCH算法适用于样本量较大的情况，这点和Mini Batch K-Means类似，但是BIRCH适用于类别数比较大的情况，而Mini Batch K-Means一般用于类别数适中或者较少的时候。BIRCH除了聚类还可以额外做一些异常点检测和数据初步按类别规约的预处理。但是如果数据特征的维度非常大，比如大于20，则BIRCH不太适合，此时Mini Batch K-Means的表现较好。</p>
<p>对于调参，BIRCH要比K-Means，Mini Batch K-Means复杂，因为它需要对CF Tree的几个关键的参数进行调参，这几个参数对CF Tree的最终形式影响很大。</p>
<p><strong>最后总结下BIRCH算法的优缺点：</strong></p>
<p>BIRCH算法的主要优点有：</p>
<p>　　1) 节约内存，所有的样本都在磁盘上，CF Tree仅仅存了CF节点和对应的指针。</p>
<p>　　2) 聚类速度快，只需要一遍扫描训练集就可以建立CF Tree，CF Tree的增删改都很快。</p>
<p>　　3) 可以识别噪音点，还可以对数据集进行初步分类的预处理</p>
<p>BIRCH算法的主要缺点有：</p>
<p>　　1) 由于CF Tree对每个节点的CF个数有限制，导致聚类的结果可能和真实的类别分布不同.</p>
<p>　　2) 对高维特征的数据聚类效果不好。此时可以选择Mini Batch K-Means</p>
<p>　　3) 如果数据集的分布簇不是类似于超球体，或者说不是凸的，则聚类效果不好。</p>
<h2 id="四-参数详解"><a href="#四-参数详解" class="headerlink" title="(四): 参数详解"></a>(四): 参数详解</h2><p>1) <strong>threshold</strong>:即叶节点每个CF的最大样本半径阈值T，它决定了每个CF里所有样本形成的超球体的半径阈值。一般来说threshold越小，则CF Tree的建立阶段的规模会越大，即BIRCH算法第一阶段所花的时间和内存会越多。但是选择多大以达到聚类效果则需要通过调参决定。默认值是0.5.如果样本的方差较大，则一般需要增大这个默认值。</p>
<p>2) <strong>branching_factor</strong>：即CF Tree内部节点的最大CF数B，以及叶子节点的最大CF数L。这里scikit-learn对这两个参数进行了统一取值。也就是说，branching_factor决定了CF Tree里所有节点的最大CF数。默认是50。如果样本量非常大，比如大于10万，则一般需要增大这个默认值。选择多大的branching_factor以达到聚类效果则需要通过和threshold一起调参决定</p>
<p>3）<strong>n_clusters</strong>：即类别数K，在BIRCH算法是可选的，如果类别数非常多，我们也没有先验知识，则一般输入None，此时BIRCH算法第4阶段不会运行。但是如果我们有类别的先验知识，则推荐输入这个可选的类别值。默认是3，即最终聚为3类。</p>
<p>4）<strong>compute_labels</strong>：布尔值，表示是否标示类别输出，默认是True。一般使用默认值挺好，这样可以看到聚类效果。</p>
<ul>
<li>掌握Python编程语言,能使用Numpy,Pandas,Matplotlib,sklearn等第三方库进行数据清洗, 数据分析, 数据可视化;</li>
<li>掌握SQL语言,能在Python及MySQL环境下熟练使用SQL语句进行操作;</li>
<li>熟悉tableau,Excel(熟悉使用内置函数, 数据透视表);</li>
<li>熟悉常用的机器学习算法,包括: 线性回归,逻辑回归,KNN,决策树,随机森林,朴素贝叶斯,支持向量机,K-means,等;</li>
<li>熟悉Linux开发环境, 熟悉Git团队协作开发;</li>
<li>熟悉常规的深度神经网络(RNN, CNN, LSTM)原理及主流框架TensorFlow的使用</li>
</ul>
<p>目前人在成都。<br>有扎实的计算机和统计学基础，近2.5年数据分析实战经验，善于用数据化的思维驱动相关工作。熟练使用Excel和Python语言，熟悉数据可视化和数据挖掘相关方法，擅长Pandas、Seaborn、ScikitLearn等工具，擅长数据分析报告的撰写，较强的自我学习能力和自我驱动能力，善于总结和归纳。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>算法</tag>
        <tag>聚类</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑回归</title>
    <url>/2019/03/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h1 id="一-逻辑斯蒂回归原理"><a href="#一-逻辑斯蒂回归原理" class="headerlink" title="一: 逻辑斯蒂回归原理"></a>一: 逻辑斯蒂回归原理</h1><h2 id="一-似然函数"><a href="#一-似然函数" class="headerlink" title="(一): 似然函数"></a>(一): 似然函数</h2><p>每个样本的概率:<br>$$<br>P(y|x;\theta)=(h_{\theta}(x))^y(1-h_\theta (x))^{1-y}<br>$$<br>事件的概率(所有样本属于真实标记的概率)<br>$$<br>L(\theta)= \prod_{i=1}^nP(y_i|x_i;\theta)<br>$$</p>
<p>$$<br>L(\theta)= \prod_{i=1}^n(h_{\theta}(x_i))^{y_i}(1-h_\theta (x_i))^{1-{y_i}}<br>$$</p>
<p><strong>似然函数解决二分类问题:</strong></p>
<p>当y=1时:<br>$$<br>P(1|x_i;\theta)=(h_{\theta}(x_i))^1(1-h_\theta (x_i))^{1-1}<br>$$</p>
<p>$$<br>P(1|x_i;\theta)=h_{\theta}(x_i)<br>$$</p>
<p>当y=0时:<br>$$<br>P(0|x_i;\theta)=(h_{\theta}(x_i))^0(1-h_\theta (x_i))^{1-0}<br>$$</p>
<p>$$<br>P(0|x_i;\theta)=1-h_\theta (x_i)<br>$$</p>
<p><strong>举个栗子:</strong> </p>
<p>假如有一个罐子，里面有黑白两种颜色的球，数目多少不知，两种颜色的比例也不知。我们想知道罐中白球和黑球的比例，但我们不能把罐中的球全部拿出来数。现在我们可以每次任意从已经摇匀的罐中拿一个球出来，记录球的颜色，然后把拿出来的球再放回罐中。这个过程可以重复，我们可以用记录的球的颜色来估计罐中黑白球的比例。假如在前面的一百次重复记录中，有七十次是白球，请问罐中白球所占的比例最有可能是多少？</p>
<p>解: </p>
<p>设每次取到白球的概率为p, 则取到黑球的概率为(1-p), 则100次中70次取到白球的概率为:<br>$$<br>P=C_{100}^{70}p^{70}(1-p)^{30}<br>$$</p>
<p>$$<br>P’=(p^{70})’(1-p)^{30}+p^{70}((1-p)^{30})’\times(1-p)’<br>$$</p>
<p>$$<br>P’=70p^{69}(1-p)^{30}-p^{70}30(1-p)^{29}<br>$$</p>
<p>此时令导数为零求最大值:<br>$$<br>0=70p^{69}(1-p)^{30}-p^{70}30(1-p)^{29}<br>$$<br>化简:<br>$$<br>0=70(1-p)-30p<br>$$</p>
<p>$$<br>100p=70<br>$$</p>
<p>所以:<br>$$<br>p=70\div100<br>$$</p>
<h2 id="二-逻辑斯蒂回归原理和损失函数"><a href="#二-逻辑斯蒂回归原理和损失函数" class="headerlink" title="(二): 逻辑斯蒂回归原理和损失函数"></a>(二): 逻辑斯蒂回归原理和损失函数</h2><p>分类问题其实都是概率问题, 逻辑斯蒂函数就是概率函数,无论给的值多大多小都会转变到0-1之间进行比较,并得出概率进行分类</p>
<p><strong>sigmoid函数:</strong><br>$$<br>S(t) = \frac{1}{1+e^{-t}}<br>$$<br><strong>线性回归方程:</strong><br>$$<br>一般模式: f(x) = {\theta}x+b<br>$$</p>
<p>$$<br>矩阵模式: f(X) = \sum\limits _{i=1}^nx_i{\theta}_i+b<br>$$</p>
<h3 id="1-逻辑斯蒂回归原理"><a href="#1-逻辑斯蒂回归原理" class="headerlink" title="1: 逻辑斯蒂回归原理"></a>1: 逻辑斯蒂回归原理</h3><p><font color=red><strong>逻辑斯蒂回归 = 线性回归 + sigmoid</strong></font></p>
<p><strong>方程结合 - 预测函数:</strong><br>$$<br>一般形式: h_{\theta}(x)=\frac{1}{1+e^{-x\theta}}<br>$$</p>
<p>$$<br>矩阵模式: h_{\theta}(X)=\frac{1}{1+e^{-X\theta}}<br>$$</p>
<h3 id="2-最大似然估计法求损失函数"><a href="#2-最大似然估计法求损失函数" class="headerlink" title="2: 最大似然估计法求损失函数"></a>2: 最大似然估计法求损失函数</h3><p><strong>最大似然估计公式求对数:</strong><br>$$<br>l(\theta) = ln(L(\theta)) =ln[ \prod_{i=1}^n(h_{\theta}(x_i))^{y_i}(1-h_\theta (x_i))^{1-{y_i}}]<br>$$<br><strong>乘积的对数可以转换成加法:</strong><br>$$<br>l(\theta)= \sum_{i=1}^n[y_iln(h_{\theta}(x_i))+(1-{y_i})ln(1-h_\theta (x_i))]<br>$$<br>最大似然估计就是要求得使 $l(\theta)$ 取最大值时的 $\theta$ ，其实这里可以使用梯度上升法求解，求得的 $\theta$ 就是要求的最佳参数</p>
<p><strong>对似然函数对数化取反的表达式，即损失函数表达式</strong><br>$$<br>J(\theta) = -l(\theta) = -\sum_{i=1}^n[y_iln(h_{\theta}(x_i))+(1-{y_i})ln(1-h_\theta (x_i))]<br>$$</p>
<blockquote>
<p><strong>损失函数 $J(\theta)$ 对 $ \theta$ 求导:</strong></p>
</blockquote>
<p>$$<br>J’(\theta) = \frac{\partial J(\theta)}{\partial\theta}<br>$$</p>
<p>$$<br>\begin{aligned}<br>\frac{\partial J(\theta)}{\partial\theta} &amp; =  -\sum_{i=1}^n[y_i\frac{1}{h_{\theta}(x_i)}\frac{\partial h_\theta(x_i)}{\partial\theta}+(1-{y_i})\frac{1}{1-h_\theta (x_i)}\frac{\partial (1-h_\theta(x_i))}{\partial\theta}]\\<br>&amp; \\<br>&amp; 注释: ln(x)’=\frac{1}{x}\\<br>&amp; \\<br>&amp; =  -\sum_{i=1}^n[y_i\frac{1}{h_{\theta}(x_i)}\frac{\partial h_\theta(x_i)}{\partial\theta}-(1-{y_i})\frac{1}{1-h_\theta (x_i)}\frac{\partial h_\theta(x_i)}{\partial\theta}]\\<br>&amp; =  -\sum_{i=1}^n[y_i\frac{1}{h_{\theta}(x_i)}-(1-{y_i})\frac{1}{1-h_\theta (x_i)}]\frac{\partial h_\theta(x_i)}{\partial\theta}\\<br>&amp;\\<br>&amp; 注释: \frac{\partial h_\theta(x_i)}{\partial\theta}的推导过程详见下文\\<br>&amp;\\<br>&amp; =  -\sum_{i=1}^n[y_i\frac{1}{h_{\theta}(x_i)}-(1-{y_i})\frac{1}{1-h_\theta (x_i)}]x_ih_\theta(x_i)(1-h_\theta(x_i))\\<br>&amp; =  -\sum_{i=1}^n[y_i(1-h_\theta (x_i))-(1-{y_i})h_\theta (x_i)]x_i\\<br>&amp; =  -\sum_{i=1}^n[y_i-h_\theta (x_i)]x_i\\<br>&amp; =  \sum_{i=1}^n[h_\theta (x_i)-y_i]x_i\\<br>\end{aligned}<br>$$</p>
<p><strong>推导 $\frac{\partial h_\theta(x_i)}{\partial\theta}$ 的过程:</strong><br>$$<br>\begin{aligned}<br>\frac{\partial h_\theta(x_i)}{\partial\theta}&amp; =  h’_\theta(x_i)\\<br>&amp; =  (\frac{1}{1+e^{-x_i\theta}})’\\<br>&amp; =  (\frac{1}{1+e^{-\theta^Tx_i}})’\\<br>&amp; =  [(1+e^{-\theta^Tx_i})^{-1}]’\\<br>&amp; 注释: (e^x)’ = e^x \\<br>&amp; =  -(1+e^{-\theta^Tx_i})^{-2}e^{-\theta^Tx_i}(-x_i)\\<br>&amp; =  (1+e^{-\theta^Tx_i})^{-2}e^{-\theta^Tx_i}x_i\\<br>&amp; =  x_i\frac{e^{-\theta^Tx_i}}{(1+e^{-\theta^Tx_i})^2}\\<br>&amp; =  x_i\frac{1}{(1+e^{-\theta^Tx_i})}\frac{e^{-\theta^Tx_i}}{(1+e^{-\theta^Tx_i})}\\<br>&amp; =  x_ih_\theta(x_i)\frac{e^{-\theta^Tx_i}}{(1+e^{-\theta^Tx_i})}\\<br>&amp; =  x_ih_\theta(x_i)\frac{1+e^{-\theta^Tx_i}-1}{(1+e^{-\theta^Tx_i})}\\<br>&amp; =  x_ih_\theta(x_i)[\frac{1+e^{-\theta^Tx_i}}{(1+e^{-\theta^Tx_i})}-\frac{1}{(1+e^{-\theta^Tx_i})}]\\<br>&amp; =  x_ih_\theta(x_i)[1-\frac{1}{(1+e^{-\theta^Tx_i})}]\\<br>&amp; =  x_ih_\theta(x_i)(1-h_\theta(x_i))\\<br>\end{aligned}<br>$$</p>
<p><strong>此时使用梯度下降优化算法, 其系数的更新规则为:</strong><br>$$<br>\theta = \theta - \epsilon\frac{\partial J(\theta)}{\partial\theta}<br>$$</p>
<h1 id="二-逻辑斯蒂回归的应用"><a href="#二-逻辑斯蒂回归的应用" class="headerlink" title="二: 逻辑斯蒂回归的应用"></a>二: 逻辑斯蒂回归的应用</h1><h2 id="一-简单应用-鸢尾花分类"><a href="#一-简单应用-鸢尾花分类" class="headerlink" title="(一): 简单应用 - 鸢尾花分类"></a>(一): 简单应用 - 鸢尾花分类</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets, metrics</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 鸢尾花数据</span></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 花萼长度, 花萼宽度, 花瓣长度, 花瓣宽度</span></span><br><span class="line">X = iris[<span class="string">'data'</span>]</span><br><span class="line">y = iris[<span class="string">'target'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># train_test_split随机打乱数据顺序, random_state使得每次随机的数值是一样的</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">512</span>)</span><br><span class="line"></span><br><span class="line">lr = LogisticRegression(max_iter=<span class="number">1000</span>)   <span class="comment"># max_iter=1000, 学习次数</span></span><br><span class="line">lr.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">y_ = lr.predict(X_test)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'实际数据:y_test:\n'</span>, y_test)</span><br><span class="line">print(<span class="string">'预测数据:y_:\n'</span>, y_)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">实际数据:y_test:</span></span><br><span class="line"><span class="string"> [0 1 1 1 2 0 0 2 0 2 1 1 1 0 2 0 2 0 1 1 0 1 0 1 0 2 1 1 1 2]</span></span><br><span class="line"><span class="string">预测数据:y_:</span></span><br><span class="line"><span class="string"> [0 1 1 2 2 0 0 2 0 2 1 1 1 0 2 0 2 0 1 1 0 1 0 2 0 2 1 1 1 2]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>



<h2 id="二-二分类问题"><a href="#二-二分类问题" class="headerlink" title="(二): 二分类问题"></a>(二): 二分类问题</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X,y = datasets.load_iris(<span class="literal">True</span>)   <span class="comment"># True代表只获取数据和目标值</span></span><br><span class="line"></span><br><span class="line">cond = y!=<span class="number">0</span>   <span class="comment"># 只留下两个类别,将类别0 删除</span></span><br><span class="line">X = X[cond]</span><br><span class="line">y = y[cond]</span><br><span class="line"></span><br><span class="line">lr = LogisticRegression()</span><br><span class="line">lr.fit(X,y)  <span class="comment"># 算法，训练数据，找X和y之间的规律，方程</span></span><br><span class="line">y_ = lr.predict(X)  <span class="comment"># 规律找到之后，使用规律，进行计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将类别减少之后, 分类后的结果和真实值相差很小,说明类别越少,分类的准确度越高</span></span><br><span class="line"></span><br><span class="line">(y_ == y).mean()   <span class="comment"># 计算准确率</span></span><br><span class="line">print(y_)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1,</span></span><br><span class="line"><span class="string">       1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,</span></span><br><span class="line"><span class="string">       1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,</span></span><br><span class="line"><span class="string">       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,</span></span><br><span class="line"><span class="string">       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">proba_ = lr.predict_proba(X)   <span class="comment"># 计算的概率</span></span><br><span class="line">proba_[:<span class="number">10</span>]   <span class="comment"># 将概率转化成类别</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[0.99153216, 0.00846784],</span></span><br><span class="line"><span class="string">       [0.9908928 , 0.0091072 ],</span></span><br><span class="line"><span class="string">       [0.99355185, 0.00644815],</span></span><br><span class="line"><span class="string">       [0.99086387, 0.00913613],</span></span><br><span class="line"><span class="string">       [0.99219814, 0.00780186],</span></span><br><span class="line"><span class="string">       [0.98268555, 0.01731445],</span></span><br><span class="line"><span class="string">       [0.99252002, 0.00747998],</span></span><br><span class="line"><span class="string">       [0.9899949 , 0.0100051 ],</span></span><br><span class="line"><span class="string">       [0.99259338, 0.00740662],</span></span><br><span class="line"><span class="string">       [0.99028393, 0.00971607]])</span></span><br><span class="line"><span class="string">每组数据有两种分类的可能性, 每种可能性对应的概率不同,系统在判别的时候会选择概率较大的那个类别</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">proba_.argmax(axis=<span class="number">1</span>)+<span class="number">1</span>   <span class="comment"># 将概率转换为类别; .argmax(axis=1)获取同一行中较大的值(概率)的下标;加1是因为之前的类别0已经被删除了,而这里的下标还有可能是0</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1,</span></span><br><span class="line"><span class="string">       1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,</span></span><br><span class="line"><span class="string">       1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,</span></span><br><span class="line"><span class="string">       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,</span></span><br><span class="line"><span class="string">       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], dtype=int64)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上是用算法模型得出的分类结果(y_)和概率手动计算概率(proba_)，现在我们用代码实现以上效果:</span></span><br><span class="line">w_ = lr.coef_</span><br><span class="line">b_ = lr.intercept_</span><br><span class="line">print(<span class="string">'方程系数'</span>,lr.coef_)</span><br><span class="line">print(<span class="string">'方程截距'</span>,lr.intercept_)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">方程系数 [[ 0.48498493 -0.34086327  1.8278232   0.83365156]]</span></span><br><span class="line"><span class="string">方程截距 [-8.76905997]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(X)</span>:</span><span class="comment">#线性方程，矩阵，批量计算</span></span><br><span class="line">    <span class="keyword">return</span> X.dot(w_[<span class="number">0</span>]) + b_[<span class="number">0</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span><span class="comment">#fun就是线性方程的返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.e**-x)</span><br><span class="line"></span><br><span class="line">f = fun(X)</span><br><span class="line">p_1 = sigmoid(f)   <span class="comment"># 求出二分类中一类的概率</span></span><br><span class="line">p_0 = <span class="number">1</span> - p_1   <span class="comment"># 求出二分类中另外一类的概率(二分类中凌总可能性的和为1)</span></span><br><span class="line">p_ = np.c_[p_0,p_1]   <span class="comment"># 将两个概率连接起来</span></span><br><span class="line"><span class="comment"># np.r_：是按列连接两个矩阵，就是把两矩阵上下相加，要求列数相等，类似于pandas中的concat()。</span></span><br><span class="line"><span class="comment"># np.c_：是按行连接两个矩阵，就是把两矩阵左右相加，要求行数相等，类似于pandas中的merge()。</span></span><br><span class="line"></span><br><span class="line">p_[:<span class="number">10</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[0.99153216, 0.00846784],</span></span><br><span class="line"><span class="string">       [0.9908928 , 0.0091072 ],</span></span><br><span class="line"><span class="string">       [0.99355185, 0.00644815],</span></span><br><span class="line"><span class="string">       [0.99086387, 0.00913613],</span></span><br><span class="line"><span class="string">       [0.99219814, 0.00780186],</span></span><br><span class="line"><span class="string">       [0.98268555, 0.01731445],</span></span><br><span class="line"><span class="string">       [0.99252002, 0.00747998],</span></span><br><span class="line"><span class="string">       [0.9899949 , 0.0100051 ],</span></span><br><span class="line"><span class="string">       [0.99259338, 0.00740662],</span></span><br><span class="line"><span class="string">       [0.99028393, 0.00971607]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 对比发现p_和proba_所得到的结果是一致的;</span></span><br></pre></td></tr></table></figure>



<h2 id="三-多分类问题"><a href="#三-多分类问题" class="headerlink" title="(三): 多分类问题"></a>(三): 多分类问题</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets, metrics</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X,y = datasets.load_iris(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打乱顺序</span></span><br><span class="line">index = np.arange(<span class="number">150</span>)</span><br><span class="line">np.random.shuffle(index)</span><br><span class="line">X = X[index]</span><br><span class="line">y = y[index]</span><br><span class="line"></span><br><span class="line">lr = LogisticRegression(max_iter=<span class="number">200</span>)   <span class="comment"># 定义模型</span></span><br><span class="line">lr.fit(X,y)   <span class="comment"># 训练模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是3分类问题, 三个方程(每一类对应一个方程),三组斜率,每组斜率有4个属性; 三个截距, </span></span><br><span class="line">w_ = lr.coef_</span><br><span class="line">b_ = lr.intercept_</span><br><span class="line">print(<span class="string">'斜率:\n'</span>,w_)</span><br><span class="line">print(<span class="string">'截距:\n'</span>,b_)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">斜率:</span></span><br><span class="line"><span class="string"> [[-0.42294389  0.9669724  -2.51691851 -1.08061335]</span></span><br><span class="line"><span class="string"> [ 0.53406236 -0.32159608 -0.20649198 -0.94361292]</span></span><br><span class="line"><span class="string"> [-0.11111847 -0.64537632  2.72341049  2.02422627]]</span></span><br><span class="line"><span class="string">截距:</span></span><br><span class="line"><span class="string"> [  9.84788649   2.2391674  -12.08705389]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">y_ = lr.predict(X)</span><br><span class="line">proba_ = lr.predict_proba(X)   <span class="comment"># 概率</span></span><br><span class="line">print(<span class="string">'y_:\n'</span>, y_)</span><br><span class="line">print(<span class="string">'proba_:\n'</span>, proba_)</span><br><span class="line">print(proba_.argmax(axis = <span class="number">1</span>))   <span class="comment"># argmax获取最大值的下标(类别)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">y_:</span></span><br><span class="line"><span class="string"> [2 0 1 2 1 1 0 0 2 1 2 2 1 1 1 0 0 0 0 1 2 1 2 2 2 2 2 0 1 0 2 1 1 1 2 0 0</span></span><br><span class="line"><span class="string"> 2 0 1 2 1 2 0 1 2 2 0 1 0 0 2 0 2 0 1 1 1 0 0 0 2 1 1 1 0 0 2 0 2 2 2 2 1</span></span><br><span class="line"><span class="string"> 0 1 0 1 2 1 0 2 1 1 2 0 2 1 0 2 1 2 0 1 0 0 2 1 2 1 0 1 0 0 0 1 1 2 1 2 1</span></span><br><span class="line"><span class="string"> 1 1 2 0 2 0 2 1 0 0 2 0 0 2 1 0 0 2 1 1 2 0 2 2 2 0 1 2 2 0 0 0 2 2 0 1 2</span></span><br><span class="line"><span class="string"> 1 2]</span></span><br><span class="line"><span class="string">proba_:</span></span><br><span class="line"><span class="string"> [[2.42893049e-04 1.62572543e-01 8.37184564e-01]</span></span><br><span class="line"><span class="string"> [9.76236359e-01 2.37636218e-02 1.93734447e-08]</span></span><br><span class="line"><span class="string"> [1.02308731e-02 7.50874989e-01 2.38894138e-01]</span></span><br><span class="line"><span class="string"> [6.22245105e-07 2.13422648e-02 9.78657113e-01]</span></span><br><span class="line"><span class="string"> ......</span></span><br><span class="line"><span class="string"> [9.08742683e-03 9.76589206e-01 1.43233676e-02]</span></span><br><span class="line"><span class="string"> [1.06469379e-06 2.91941988e-02 9.70804737e-01]</span></span><br><span class="line"><span class="string"> [2.43372229e-01 7.55336793e-01 1.29097800e-03]</span></span><br><span class="line"><span class="string"> [2.27109807e-04 2.51919829e-01 7.47853061e-01]]</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> proba_.argmax(axis = 1):</span></span><br><span class="line"><span class="string"> array([2, 0, 1, 2, 1, 1, 0, 0, 2, 1, 2, 2, 1, 1, 1, 0, 0, 0, 0, 1, 2, 1,</span></span><br><span class="line"><span class="string">       2, 2, 2, 2, 2, 0, 1, 0, 2, 1, 1, 1, 2, 0, 0, 2, 0, 1, 2, 1, 2, 0,</span></span><br><span class="line"><span class="string">       1, 2, 2, 0, 1, 0, 0, 2, 0, 2, 0, 1, 1, 1, 0, 0, 0, 2, 1, 1, 1, 0,</span></span><br><span class="line"><span class="string">       0, 2, 0, 2, 2, 2, 2, 1, 0, 1, 0, 1, 2, 1, 0, 2, 1, 1, 2, 0, 2, 1,</span></span><br><span class="line"><span class="string">       0, 2, 1, 2, 0, 1, 0, 0, 2, 1, 2, 1, 0, 1, 0, 0, 0, 1, 1, 2, 1, 2,</span></span><br><span class="line"><span class="string">       1, 1, 1, 2, 0, 2, 0, 2, 1, 0, 0, 2, 0, 0, 2, 1, 0, 0, 2, 1, 1, 2,</span></span><br><span class="line"><span class="string">       0, 2, 2, 2, 0, 1, 2, 2, 0, 0, 0, 2, 2, 0, 1, 2, 1, 2], dtype=int64)</span></span><br><span class="line"><span class="string">       </span></span><br><span class="line"><span class="string">以上proba_.argmax(axis = 1)的分类结果和模型预测的结果一致;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义线性函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear</span><span class="params">(x)</span>:</span></span><br><span class="line">    y = x.dot(w_.T)+b_</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将的到的目标值转换成概率(同一组目标值内的概率和为1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(x)</span>:</span>   <span class="comment"># 详细公式见下文</span></span><br><span class="line">    <span class="keyword">return</span> np.e**x/((np.e**x).sum(axis=<span class="number">1</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line">    <span class="comment"># reshape之后分母的形状由单独的一行,变成一列;变成一列之后回根据分子的形状由第一列进行广播(广播出来的列和原来的一列相同,只是为了对应分支的数据形状,方便进行运算)</span></span><br><span class="line">    <span class="comment"># 如果我只需要特定的行数，列数我无所谓多少，我只需要指定行数，列数用-1代替就行了，计算机帮我算应该有多少列，反之亦然。所以-1在这里应该可以理解为一个正整数通配符，它代替任何正整数。</span></span><br><span class="line">    </span><br><span class="line">y_pred = linear(X)</span><br><span class="line">y_pred = softmax(y_pred)</span><br><span class="line">y_pred[:<span class="number">10</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[2.42893049e-04, 1.62572543e-01, 8.37184564e-01],</span></span><br><span class="line"><span class="string">       [9.76236359e-01, 2.37636218e-02, 1.93734447e-08],</span></span><br><span class="line"><span class="string">       [1.02308731e-02, 7.50874989e-01, 2.38894138e-01],</span></span><br><span class="line"><span class="string">       [6.22245105e-07, 2.13422648e-02, 9.78657113e-01],</span></span><br><span class="line"><span class="string">       [8.71627591e-03, 7.74658724e-01, 2.16625000e-01],</span></span><br><span class="line"><span class="string">       [5.07829679e-03, 9.20088614e-01, 7.48330891e-02],</span></span><br><span class="line"><span class="string">       [9.84437320e-01, 1.55626715e-02, 8.01740090e-09],</span></span><br><span class="line"><span class="string">       [9.85693639e-01, 1.43063452e-02, 1.55226004e-08],</span></span><br><span class="line"><span class="string">       [9.96558465e-05, 1.20579040e-01, 8.79321304e-01],</span></span><br><span class="line"><span class="string">       [2.39486316e-02, 9.59459247e-01, 1.65921216e-02]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 得到的概率和模型计算的概率相同</span></span><br></pre></td></tr></table></figure>

<p>以上代码段中softmax(x)用到的公式:</p>
<p>softmax函数的计算原理 :<br>$$<br>e^{x_i}\div\sum_{i=1}^n e^{x_i}<br>$$<br><img src="https://img-blog.csdn.net/20171127214016170?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGlhb3h1ZXpob25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>机器学习</tag>
        <tag>sklearn</tag>
        <tag>Logistic回归</tag>
      </tags>
  </entry>
  <entry>
    <title>集成算法</title>
    <url>/2020/04/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%9B%86%E6%88%90%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一: 概述"></a>一: 概述</h1><p>集成学习(ensemble learning)可以说是现在非常火爆的机器学习方法了。它本身不是一个单独的机器学习算法，而是通过构建并结合多个机器学习器来完成学习任务。也就是我们常说的“博采众长”。集成学习可以用于分类问题集成，回归问题集成，特征选取集成，异常点检测集成等等，可以说所有的机器学习领域都可以看到集成学习的身影。</p>
<p>集成学习有两个主要的问题需要解决，第一是如何得到若干个个体学习器，第二是如何选择一种结合策略，将这些个体学习器集合成一个强学习器。</p>
<p><strong>集成学习分为两种:</strong>  </p>
<p>第一种就是所有的个体学习器都是一个种类的，或者说是同质的。比如都是决策树个体学习器，或者都是神经网络个体学习器。</p>
<p>第二种是所有的个体学习器不全是一个种类的，或者说是异质的。比如我们有一个分类问题，对训练集采用支持向量机个体学习器，逻辑回归个体学习器和朴素贝叶斯个体学习器来学习，再通过某种结合策略来确定最终的分类强学习器。</p>
<p>目前来说，同质个体学习器的应用是最广泛的，一般我们常说的集成学习的方法都是指的同质个体学习器。而同质个体学习器使用最多的模型是CART决策树和神经网络。同质个体学习器按照个体学习器之间是否存在依赖关系可以分为两类，第一个是个体学习器之间存在强依赖关系，一系列个体学习器基本都需要串行生成，代表算法是boosting系列算法，第二个是个体学习器之间不存在强依赖关系，一系列个体学习器可以并行生成，代表算法是bagging和随机森林（Random Forest）系列算法。</p>
<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqlnqcb8vj21zu0oa0w1.jpg" alt="集成学习的分类.jpg"></p>
<br>



<h1 id="二-同质学习器的分类"><a href="#二-同质学习器的分类" class="headerlink" title="二: 同质学习器的分类"></a>二: 同质学习器的分类</h1><h2 id="1-bagging"><a href="#1-bagging" class="headerlink" title="1: bagging"></a>1: bagging</h2><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqlo3lgh9j20u00csmy9.jpg" alt="bagging.jpg" style="zoom:67%;" />



<p><strong>具体过程：</strong></p>
<ol>
<li>从原始样本集中抽取训练集。每轮从原始样本集中使用 Bootstraping 的方法抽取 n 个训练样本（在训练集中，有些样本可能被多次抽取到，而有些样本可能一次都没有被抽中 - 有放回抽样）。共进行 k 轮抽取，得到 k 个训练集。（k 个训练集之间是相互独立的）</li>
<li>每次使用一个训练集得到一个模型，k 个训练集共得到 k 个模型。</li>
</ol>
<p>Bagging 的思路是所有基础模型都一致对待，每个基础模型手里都只有一票。然后使用民主投票的方式得到最终的结果。</p>
<p>大部分情况下， <strong>经过 bagging 得到的结果方差（variance）更小</strong> 。</p>
<p>随机森林是bagging的一个特化进阶版，所谓的特化是因为随机森林的弱学习器都是决策树。所谓的进阶是随机森林在bagging的样本随机采样基础上，又加上了特征的随机选择，其基本思想没有脱离bagging的范畴。</p>
<h2 id="2-boosting"><a href="#2-boosting" class="headerlink" title="2: boosting"></a>2: boosting</h2><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqloeqsk9j20u00csmyd.jpg" alt="bosting.jpg" style="zoom:67%;" />



<p><strong>具体过程：</strong></p>
<ol>
<li>通过加法模型将基础模型进行线性的组合。</li>
<li>每一轮训练都提升那些错误率小的基础模型权重，同时减小错误率高的模型权重。</li>
<li>在每一轮改变训练数据的权值或概率分布，通过提高那些在前一轮被弱分类器分错样例的权值，减小前一轮分对样例的权值，来使得分类器对误分的数据有较好的效果。</li>
</ol>
<p>Boosting算法的工作机制是首先从训练集用初始权重训练出一个弱学习器，根据弱学习的学习误差率表现来更<strong>新训练样本</strong>的权重，使得之前弱学习器<strong>学习误差率高的训练样本点的权重变高</strong>，使得这些误差率高的点在后面的弱学习器中得到更多的重视。</p>
<p>Boosting通过加法模型将弱分类器进行线性组合，比如AdaBoost通过加权多数表决的方式，<strong>即增大错误率小的分类器的权值，同时减小错误率较大的分类器的权值。</strong></p>
<p>Boosting 和 bagging 最本质的差别在于他对基础模型不是一致对待的，而是经过不停的考验和筛选来挑选出精英，然后给精英更多的投票权，表现不好的基础模型则给较少的投票权，然后综合所有人的投票得到最终结果。</p>
<p>大部分情况下， <strong>经过 boosting 得到的结果偏差（bias）更小</strong> 。</p>
<h2 id="3-Bagging-和-Boosting-的差别"><a href="#3-Bagging-和-Boosting-的差别" class="headerlink" title="3: Bagging 和 Boosting 的差别"></a>3: Bagging 和 Boosting 的差别</h2><p><strong>样本选择上：</strong></p>
<p>Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。</p>
<p>Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。</p>
<p><strong>样例权重：</strong></p>
<p>Bagging：使用均匀取样，每个样例的权重相等</p>
<p>Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。</p>
<p><strong>预测函数：</strong></p>
<p>Bagging：所有预测函数的权重相等。</p>
<p>Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。</p>
<p><strong>并行计算：</strong></p>
<p>Bagging：各个预测函数可以并行生成</p>
<p>Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。</p>
<br>



<h1 id="三-集成学习的结合策略"><a href="#三-集成学习的结合策略" class="headerlink" title="三: 集成学习的结合策略"></a>三: 集成学习的结合策略</h1><h2 id="1-平均法"><a href="#1-平均法" class="headerlink" title="1: 平均法"></a>1: 平均法</h2><p>对于数值类的回归预测问题，通常使用的结合策略是平均法，也就是说，对于若干个弱学习器的输出进行平均得到最终的预测输出。<br>$$<br>H(x)=\frac{1}{T}\sum_{i=1}^Th_i(x)<br>$$<br>$T$代表基础模型数量; $h_i(x)$为每个模型预测的结果</p>
<h2 id="2-投票法"><a href="#2-投票法" class="headerlink" title="2: 投票法"></a>2: 投票法</h2><p>对于分类问题的预测，我们通常使用的是投票法。</p>
<p>最简单的投票法是相对多数投票法，也就是我们常说的少数服从多数，如果不止一个类别获得最高票，则随机选择一个做最终类别。</p>
<p>稍微复杂的投票法是绝对多数投票法，也就是我们常说的要票过半数。在相对多数投票法的基础上，不光要求获得最高票，还要求票过半数。否则会拒绝预测。</p>
<p>更加复杂的是加权投票法，和加权平均法一样，每个弱学习器的分类票数要乘以一个权重，最终将各个类别的加权票数求和，最大的值对应的类别为最终类别。</p>
<h2 id="3-学习法"><a href="#3-学习法" class="headerlink" title="3: 学习法"></a>3: 学习法</h2><p>学习法，代表方法是stacking，当使用stacking的结合策略时， 我们不是对弱学习器的结果做简单的逻辑处理，而是再加上一层学习器，也就是说，我们将训练集弱学习器的学习结果作为输入，将训练集的输出作为输出，重新训练一个学习器来得到最终结果。</p>
<p>在这种情况下，我们将弱学习器称为初级学习器，将用于结合的学习器称为次级学习器。对于测试集，我们首先用初级学习器预测一次，得到次级学习器的输入样本，再用次级学习器预测一次，得到最终的预测结果。</p>
<br>



<h1 id="四-bagging之随机森林系列算法"><a href="#四-bagging之随机森林系列算法" class="headerlink" title="四: bagging之随机森林系列算法"></a>四: bagging之随机森林系列算法</h1><h2 id="1-随机森林"><a href="#1-随机森林" class="headerlink" title="1: 随机森林"></a>1: 随机森林</h2><h3 id="1-构建随机森林"><a href="#1-构建随机森林" class="headerlink" title="(1): 构建随机森林"></a>(1): 构建随机森林</h3><ol>
<li>假如有N个样本，则有放回的随机选择n个样本(每次随机选择一个样本，然后返回继续选择)。这选择好了的N个样本用来训练一个决策树，作为决策树根节点处的样本。</li>
<li>当每个样本有M个属性时，在决策树的每个节点需要分裂时，随机从这M个属性中选取出m个属性，满足条件m &lt;&lt; M。然后从这m个属性中采用某种策略（比如说信息增益）来选择1个属性作为该节点的分裂属性。</li>
<li>决策树形成过程中每个节点都要按照步骤2来分裂（很容易理解，如果下一次该节点选出来的那一个属性是刚刚其父节点分裂时用过的属性，则该节点已经达到了叶子节点，无须继续分裂了）。一直到不能够再分裂为止。注意整个决策树形成过程中没有进行剪枝。</li>
<li>按照步骤1~3建立大量的决策树，这样就构成了随机森林了。</li>
</ol>
<h3 id="2-随机森林的优缺点"><a href="#2-随机森林的优缺点" class="headerlink" title="(2): 随机森林的优缺点"></a>(2): 随机森林的优缺点</h3><p><strong>优点</strong></p>
<p>1、训练可以并行化，对于大规模样本的训练具有速度的优势。</p>
<p>2、由于进行随机选择决策树划分特征列表，这样在样本维度比较高的时候，仍然具有比较高的训练性能。</p>
<p>3、可以给出各个特征值的重要性列表。</p>
<p>4、由于存在随机抽样，训练出来的模型方差小，泛化能力强。</p>
<p>5、RF实现简单。</p>
<p>6、对于部分特征的丢失不敏感。</p>
<p><strong>缺点</strong></p>
<p>1、噪音过大的特征上，容易过拟合。</p>
<p>2、取值比较多的划分特征对RF的决策会产生更大的影响，从而有可能影响模型的效果。</p>
<h3 id="3-随机森林的应用方向"><a href="#3-随机森林的应用方向" class="headerlink" title="(3): 随机森林的应用方向"></a>(3): 随机森林的应用方向</h3><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqloy1wkxj20u00csq3h.jpg" alt="随机森林应用方向.jpg" style="zoom:67%;" />



<h3 id="4-随机森林参数详解"><a href="#4-随机森林参数详解" class="headerlink" title="(4): 随机森林参数详解"></a>(4): 随机森林参数详解</h3><p><a href="https://www.cnblogs.com/pinard/p/6160412.html" target="_blank" rel="noopener">刘建平老师 - scikit-learn随机森林调参小结</a></p>
<h2 id="2-机限随机森林-extra-trees"><a href="#2-机限随机森林-extra-trees" class="headerlink" title="2: 机限随机森林(extra trees)"></a>2: 机限随机森林(extra trees)</h2><p>1、RF会随机采样来作为子决策树的训练集，而Extra Tree每个子决策树采用原始数据集训练。</p>
<p>2、RF在选择划分特征点的时候会和传统决策树一样，会基于信息增益、信息增益率、基尼系数、均方差等原则来选择最优的特征值。Extra Tree则是随机选择一个特征值来划分决策树。</p>
<p>从第二点可以看出，由于随机选择了特征值的划分点位，而不是最优点位，这样会导致生成的决策树的规模一般会大于RF所生成的决策树。也就是说，模型的方差相对于RF进一步减少，但是偏倚相对于RF进一步增大。在某些时候，extra trees的泛化能力比RF更好。</p>
<p>本文强烈参考的文章:</p>
<p><a href="https://www.chainnews.com/articles/804594953090.htm" target="_blank" rel="noopener">一文看懂集成学习（详解 bagging、boosting 以及他们的 4 点区别）</a></p>
<p><a href="https://www.cnblogs.com/pinard/p/6131423.html" target="_blank" rel="noopener">刘建平老师 - 集成学习原理小结</a></p>
<br>



<h1 id="五-bosting系列算法"><a href="#五-bosting系列算法" class="headerlink" title="五: bosting系列算法"></a>五: bosting系列算法</h1><h2 id="一-AdaBoost算法"><a href="#一-AdaBoost算法" class="headerlink" title="(一): AdaBoost算法"></a>(一): AdaBoost算法</h2><h3 id="1-AdaBoost算法概述"><a href="#1-AdaBoost算法概述" class="headerlink" title="1: AdaBoost算法概述"></a>1: AdaBoost算法概述</h3><p>Adaboost既可以用作分类，也可以用作回归。</p>
<p>在boosting中我们介绍过, Boosting算法的工作机制是首先从训练集用初始权重训练出一个弱学习器1，<strong>根据弱学习的学习误差率表现来更新训练样本的权重，使得之前弱学习器1学习误差率高的训练样本点的权重变高，使得这些误差率高的点在后面的弱学习器2中得到更多的重视。然后基于调整权重后的训练集来训练弱学习器2.</strong>，如此重复进行，直到弱学习器数达到事先指定的数目T，最终将这T个弱学习器通过集合策略进行整合，得到最终的强学习器。</p>
<p><strong>只要是boosting大家族的算法，都要解决下面4个问题。</strong></p>
<p>1）如何计算学习误差率e?</p>
<p>2)  如何得到弱学习器权重系数α?</p>
<p>3）如何更新样本权重D?</p>
<p>4)  使用何种结合策略？</p>
<h3 id="2-AdaBoost算法原理"><a href="#2-AdaBoost算法原理" class="headerlink" title="2: AdaBoost算法原理"></a>2: AdaBoost算法原理</h3><p>输入为样本集 $T={(x_1,y_1),(x_2,y_2),…(x_m,y_m)}$ 输出为 ${-1, +1}$ ，弱分类器算法, 弱分类器迭代次数K。</p>
<p>输出为最终的强分类器 $f(x)$</p>
<p><strong>1) 初始化样本集权重为</strong></p>
<p>$$D(1)=(w_{11}),w_{12}),…w_{1m}))$$</p>
<p>$$ w_{1i}=\frac{1}{m}, i=1,2…m$$</p>
<p><strong>2) 对于k=1,2，…K:</strong></p>
<p>　　a) 使用具有权重 $D_k$ 的样本集来训练数据，得到弱分类器$G_k(x)$</p>
<p>　　b) 计算$G_k(x)$的<strong>分类误差率</strong><br>$$<br>e_k=P(G_k(x_i)≠y_i)=\sum_{i=1}^m w_{ki}I(G_k(x_i)≠y_i)<br>$$</p>
<p>　　c) 计算<strong>弱分类器的系数</strong></p>
<p>$$<br>α_k=\frac{1}{2}log(\frac{1-e_k}{e_k})<br>$$<br>　　d) <strong>更新样本集的权重分布</strong><br>$$<br>w _{k+1, i}=\frac{w _{ki}}{Z_K}exp(−α_ky_iG_k(x_i)), i=1,2,…m<br>$$</p>
<p><strong>这里ZkZk是规范化因子</strong><br>$$<br>Z_k=\sum_{i=1}^m w_{ki}exp(−α_k y_i G_k(x_i))<br>$$</p>
<p><strong>3) 构建最终分类器为：</strong><br>$$<br>f(x)=sign(\sum_{k=1}^K α_k G_k(x))<br>$$</p>
<p>对于Adaboost多元分类算法，其实原理和二元分类类似，最主要区别在弱分类器的系数上。比如Adaboost SAMME算法，它的弱分类器的系数<br>$$<br>α_k=\frac{1}{2}log(\frac{1-e_k}{e_k})+log(R−1)<br>$$<br><strong>其中R为类别数。</strong>从上式可以看出，如果是二元分类，R=2，则上式和我们的二元分类算法中的弱分类器的系数一致。</p>
<h3 id="3-代码实现Adaboost算法"><a href="#3-代码实现Adaboost算法" class="headerlink" title="3: 代码实现Adaboost算法"></a>3: 代码实现Adaboost算法</h3><h4 id="二分类"><a href="#二分类" class="headerlink" title="二分类"></a><strong>二分类</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X = np.arange(<span class="number">10</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">y = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一棵树!!!!!!</span></span><br><span class="line"><span class="comment"># 样本的初始权重，还没有开始进行训练，所以，所有样本权重一样？</span></span><br><span class="line">w1 = np.full(shape = <span class="number">10</span>,fill_value=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 样本中10个数据，划分，0到1之间(threshold阈值0.5)划分；1到2之间（1.5）划分……</span></span><br><span class="line"></span><br><span class="line">thresholds = np.arange(<span class="number">0.5</span>,<span class="number">10</span>)   <span class="comment"># 生成0.5到9.5中间间隔1的10个数</span></span><br><span class="line"><span class="keyword">for</span> i,t <span class="keyword">in</span> enumerate(thresholds,start = <span class="number">1</span>): <span class="comment">#enumerate,获取索引，默认从0开始， </span></span><br><span class="line">    y_ = np.array([<span class="number">1</span>]*i + [<span class="number">-1</span>]*(<span class="number">10</span>-i))   <span class="comment"># 计算预测值</span></span><br><span class="line">    print(t,((y !=y_)*w1).sum())   <span class="comment"># 计算每个分割点的误差率</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0.5 0.5</span></span><br><span class="line"><span class="string">1.5 0.4</span></span><br><span class="line"><span class="string">2.5 0.30000000000000004</span></span><br><span class="line"><span class="string">3.5 0.4</span></span><br><span class="line"><span class="string">4.5 0.5</span></span><br><span class="line"><span class="string">5.5 0.6</span></span><br><span class="line"><span class="string">6.5 0.5</span></span><br><span class="line"><span class="string">7.5 0.4</span></span><br><span class="line"><span class="string">8.5 0.30000000000000004</span></span><br><span class="line"><span class="string">9.5 0.4</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 阈值是2.5或者8.5，误差最小的：0.3; 选择2.5或者8.5作为裂分条件，代码中一般选择，前面的索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算第一个弱学习器的权重，相当于大夫的话语权</span></span><br><span class="line">e1 = <span class="number">0.3</span></span><br><span class="line">a1 = <span class="number">1</span>/<span class="number">2</span>*np.log((<span class="number">1</span> -e1)/e1 )</span><br><span class="line">print(<span class="string">'第一个弱学习器的权重:'</span>,a1)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">第一个弱学习器的权重: 0.42364893019360184</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新样本的权重</span></span><br><span class="line"><span class="comment"># 在w1的基础上，进行更新 w1 = [0.1,0.1,0.1……]</span></span><br><span class="line">y_ = np.array([<span class="number">1</span>]*<span class="number">3</span> + [<span class="number">-1</span>]*(<span class="number">10</span><span class="number">-3</span>))</span><br><span class="line">w2 = w1*np.exp(-y*y_*a1)</span><br><span class="line">w2 = w2/w2.sum()</span><br><span class="line">print(w2)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[0.07142857 0.07142857 0.07142857 0.07142857 0.07142857 0.07142857</span></span><br><span class="line"><span class="string"> 0.16666667 0.16666667 0.16666667 0.07142857]</span></span><br><span class="line"><span class="string"> '''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二棵树!!!!!!!!!!</span></span><br><span class="line">thresholds = np.arange(<span class="number">0.5</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i,t <span class="keyword">in</span> enumerate(thresholds,start = <span class="number">1</span>): <span class="comment">#enumerate,获取索引，默认从0开始， </span></span><br><span class="line">    y_ = np.array([<span class="number">1</span>]*i + [<span class="number">-1</span>]*(<span class="number">10</span>-i))   <span class="comment"># 计算预测值</span></span><br><span class="line">    print(t,((y !=y_)*w2).sum())   <span class="comment"># 计算每个分割点的误差率</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0.5 0.6428571428571428</span></span><br><span class="line"><span class="string">1.5 0.5714285714285714</span></span><br><span class="line"><span class="string">2.5 0.5</span></span><br><span class="line"><span class="string">3.5 0.5714285714285714</span></span><br><span class="line"><span class="string">4.5 0.6428571428571428</span></span><br><span class="line"><span class="string">5.5 0.7142857142857142</span></span><br><span class="line"><span class="string">6.5 0.5476190476190476</span></span><br><span class="line"><span class="string">7.5 0.38095238095238093</span></span><br><span class="line"><span class="string">8.5 0.21428571428571425</span></span><br><span class="line"><span class="string">9.5 0.28571428571428564</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 阈值，如果是8.5，那么左边9个数，右边是1个数，计算误差率</span></span><br><span class="line">y_ = np.array([<span class="number">1</span>]*<span class="number">9</span> + [<span class="number">-1</span>]*(<span class="number">10</span><span class="number">-9</span>))<span class="comment">#预测值</span></span><br><span class="line">display(y,y_)</span><br><span class="line">e2 = ((y != y_)*w2).sum()   <span class="comment"># 误差率</span></span><br><span class="line">print(<span class="string">'第二棵树的误差率：'</span>,e2)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">第二棵树的误差率： 0.21428571428571425</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">a2 =np.round( <span class="number">1</span>/<span class="number">2</span>*np.log((<span class="number">1</span> - e2)/e2),<span class="number">4</span>)</span><br><span class="line">print(<span class="string">'第二棵树，权重是：'</span>,a2)   <span class="comment"># 计算第二棵树的权重</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">第二棵树，权重是： 0.6496</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新样本权重</span></span><br><span class="line">w3 = w2*np.exp(-y*y_*a2)</span><br><span class="line">w3 = w3/w3.sum()</span><br><span class="line">print(<span class="string">'更新样本权重：'</span>,w3)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[0.04545643 0.04545643 0.04545643 0.16665975 0.16665975 0.16665975</span></span><br><span class="line"><span class="string"> 0.10606501 0.10606501 0.10606501 0.04545643]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三棵树!!!!!!!!!!</span></span><br><span class="line">thresholds = np.arange(<span class="number">0.5</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i,t <span class="keyword">in</span> enumerate(thresholds,start = <span class="number">1</span>):<span class="comment">#enumerate,获取索引，默认从0开始， </span></span><br><span class="line">    y_ = np.array([<span class="number">1</span>]*i + [<span class="number">-1</span>]*(<span class="number">10</span>-i))</span><br><span class="line">    print(t,((y !=y_)*w3).sum()) <span class="comment">#误差率 + 准确率 = 1</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0.5 0.40910788311754365</span></span><br><span class="line"><span class="string">1.5 0.36365145166003876</span></span><br><span class="line"><span class="string">2.5 0.318195020202534</span></span><br><span class="line"><span class="string">3.5 0.4848547715250161</span></span><br><span class="line"><span class="string">4.5 0.6515145228474983</span></span><br><span class="line"><span class="string">5.5 0.8181742741699806</span></span><br><span class="line"><span class="string">6.5 0.7121092674358026</span></span><br><span class="line"><span class="string">7.5 0.6060442607016245</span></span><br><span class="line"><span class="string">8.5 0.4999792539674466</span></span><br><span class="line"><span class="string">9.5 0.5454356854249515</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">e3 = <span class="number">0.1820</span></span><br><span class="line"><span class="comment"># 计算第三棵树的权重</span></span><br><span class="line">y_ = np.array([<span class="number">-1</span>]*<span class="number">6</span> + [<span class="number">1</span>]*(<span class="number">10</span><span class="number">-6</span>))</span><br><span class="line">a3 = <span class="number">1</span>/<span class="number">2</span>*np.log((<span class="number">1</span> - e3)/e3)</span><br><span class="line">print(<span class="string">'第三棵树的权重是：'</span>,a3)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">第三棵树的权重是： 0.7514278247629759</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新第三棵树的，样本权值分布，权重</span></span><br><span class="line">w4 = w3*np.exp(-y*y_*a3)</span><br><span class="line">w4 = w4/w4.sum()</span><br><span class="line">print(<span class="string">'第三棵树，更新样本权重：'</span>,w4.round(<span class="number">3</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">第三棵树，更新样本权重： [0.125 0.125 0.125 0.102 0.102 0.102 0.065 0.065 0.065 0.125]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集成算法</span></span><br><span class="line"><span class="comment"># 第一棵树ft(x)</span></span><br><span class="line">y1 = np.array([<span class="number">1</span>]*<span class="number">3</span> + [<span class="number">-1</span>]*(<span class="number">10</span><span class="number">-3</span>))</span><br><span class="line"><span class="comment"># 第二棵树的预测值</span></span><br><span class="line">y2 = np.array([<span class="number">1</span>]*<span class="number">9</span> + [<span class="number">-1</span>]*(<span class="number">10</span><span class="number">-9</span>))<span class="comment">#预测值</span></span><br><span class="line"><span class="comment"># 第三棵树，预测值</span></span><br><span class="line">y3 = np.array([<span class="number">-1</span>]*<span class="number">6</span> + [<span class="number">1</span>]*(<span class="number">10</span><span class="number">-6</span>))</span><br><span class="line">F =  a1*y1 + a2*y2 + a3*y3</span><br><span class="line"><span class="comment"># 将多个弱分类器，整合，变成了强分类器F(X)</span></span><br><span class="line">F</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([ 0.32182111,  0.32182111,  0.32182111, -0.52547675, -0.52547675,</span></span><br><span class="line"><span class="string">       -0.52547675,  0.97737889,  0.97737889,  0.97737889, -0.32182111])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">result = [<span class="number">-1</span> <span class="keyword">if</span> i &lt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span>  <span class="keyword">for</span> i <span class="keyword">in</span> F]</span><br><span class="line">result</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[1, 1, 1, -1, -1, -1, 1, 1, 1, -1]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 分类成功!</span></span><br></pre></td></tr></table></figure>



<h4 id="多分类"><a href="#多分类" class="headerlink" title="多分类"></a>多分类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">待更新。。。</span><br></pre></td></tr></table></figure>







<p><a href="https://www.cnblogs.com/pinard/p/6133937.html" target="_blank" rel="noopener">刘建平 - 集成学习之Adaboost算法原理小结</a></p>
<p><a href="https://www.cnblogs.com/pinard/p/6136914.html" target="_blank" rel="noopener">刘建平 - scikit-learn Adaboost类库使用小结</a></p>
<h2 id="二-GBDT-梯度提升树-算法-Gradient-Boosting-Decision-Tree"><a href="#二-GBDT-梯度提升树-算法-Gradient-Boosting-Decision-Tree" class="headerlink" title="(二): GBDT(梯度提升树)算法(Gradient Boosting Decision Tree)"></a>(二): GBDT(梯度提升树)算法(Gradient Boosting Decision Tree)</h2><h3 id="1-梯度提升回归树算法原理"><a href="#1-梯度提升回归树算法原理" class="headerlink" title="1: 梯度提升回归树算法原理"></a>1: 梯度提升回归树算法原理</h3><h4 id="1-残差更新"><a href="#1-残差更新" class="headerlink" title="(1): 残差更新:"></a>(1): 残差更新:</h4><p>举个简单的例子: 预测一个同学本次的考试成绩, 根据他之前的考试成绩的平均值来预测本次结果, 在训练算法时, 将预测值(之前分数的平均分) 分数和实际的分数相减, 得到的值就是残差;(在梯度提升回归树中, 残差值越小越好)</p>
<p>之后按照梯度下降的思想不断更新残差:</p>
<p>$residual = residual - learning_rate*residual$</p>
<p> residual 是上一轮的残差, learning_rate是残差更新的系数, 也就是学习率,在定义算法时定义的参数</p>
<p>直到循环的次数达到事先预设好的次数就结束, 预设次数是参数n_estimators决定的(默认是100)</p>
<p><strong>示例:</strong> 现有一组数据,  X代表消费金额和上网时长, 通过X预测任务的年龄.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingRegressor</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X = np.array([[<span class="number">600</span>,<span class="number">0.8</span>],[<span class="number">800</span>,<span class="number">1.2</span>],[<span class="number">1500</span>,<span class="number">10</span>],[<span class="number">2500</span>,<span class="number">3</span>]])</span><br><span class="line">y = np.array([<span class="number">14</span>,<span class="number">16</span>,<span class="number">24</span>,<span class="number">26</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># loss  = ls 最小二乘法</span></span><br><span class="line">learning_rate = <span class="number">0.1</span>   <span class="comment"># 残差更新系数</span></span><br><span class="line">gbdt = GradientBoostingRegressor(n_estimators=<span class="number">1</span>,loss = <span class="string">'ls'</span>, learning_rate=<span class="number">0.1</span>)  <span class="comment"># learning_rate 学习率</span></span><br><span class="line">gbdt.fit(X,y_true)  <span class="comment">#训练</span></span><br><span class="line">y_ = gbdt.predict(X)  <span class="comment">#预测</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用代码实现残差更新</span></span><br><span class="line">residual = y  - y.mean()   <span class="comment"># 残差(第一棵树); 预测的初始值给训练数据的平均值</span></span><br><span class="line">print(residual)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([-6., -4.,  4.,  6.])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">result = y - residual   <span class="comment"># 第一棵树的预测值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">residual = residual - learning_rate*residual   <span class="comment"># 对残差进行更新(残差值越小越好) - 第二棵树的残差</span></span><br><span class="line">result = y - residual   <span class="comment"># 第二棵树的预测值</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([-3., -2.,  2.,  3.])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以此类推, 残差值会越来越小, 预测的结果也就月接近真实值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 算法模型实现残差更新</span></span><br><span class="line">gbdt[<span class="number">0</span>, <span class="number">0</span>].predict(X)   <span class="comment"># 得到残差</span></span><br><span class="line">gbdt.predict(X)    <span class="comment"># 预测值</span></span><br></pre></td></tr></table></figure>





<h4 id="2-均方误差判断分裂标准"><a href="#2-均方误差判断分裂标准" class="headerlink" title="(2): 均方误差判断分裂标准:"></a>(2): 均方误差判断分裂标准:</h4><p><strong>知识扩展:</strong></p>
<p><strong>均方误差: 预测值和真实值的差的平方的平均值</strong></p>
<p>MSE的值越小，说明预测模型描述实验数据具有更好的精确度<br>$$<br>MSE=\frac{1}{N}\sum_{i=1}^N(True_i-Predict_i)^2<br>$$<br><strong>均方根误差: 均方误差开方</strong><br>$$<br>RMSE=\sqrt{\frac{1}{N}\sum_{i=1}^N(True_i-Predict_i)^2}<br>$$<br><strong>平均绝对误差: 预测值和真实值的绝对值求和的平方的平均值</strong></p>
<p>平均绝对误差能更好地反映预测值误差的实际情况.<br>$$<br>MAE=\frac{1}{N}\sum_{i=1}^N|True_i-Predict_i|<br>$$<br><strong>方差: 数组内每个数和该数组的平均值的差的平方的和的平均值</strong><br>$$<br>\sigma^2 = \frac{1}{N}\sum _{i=1}^N(x_i-\overline x)^2<br>$$<br><strong>标准差(均方差):  方差开方</strong></p>
<p>标准差能反映一个数据集的<a href="https://wiki.mbalib.com/wiki/离散程度" target="_blank" rel="noopener">离散程度</a>, 标准差越大,数据越离散<br>$$<br>\sigma = \sqrt{\frac{1}{N}\sum _{i=1}^N(x_i-\overline x)^2}<br>$$</p>
<p>梯度提升回归树是使用了决策树的算法, 所以在预测的时候可以将过程可视化出来,方便更直观的观察整个过程;在这个过程中我们一般使用<strong>目标值的均方误差</strong>来作为分裂的标准:</p>
<p>同样是上面那个例子, 在<strong>第一次分裂</strong>的时候我们可以根据消费金额和上网时长来分裂, 这里以消费金额为例, 我们有决策树模型: </p>
<p>X.iloc[:, 0]  = [600, 800,1500,2500]   —&gt;   y = [14, 16,24,26]</p>
<ul>
<li>①:  [[600], [800,1500,2500]]   —&gt;   [[14], [16,24,26]]</li>
</ul>
<p>此时计算目标值均方误差(<strong>初次年龄预测值为测试数据的平均值</strong>):<br>$$<br>mse_left = (14 - 14)^2\div1 = 0 \<br>mse_right = ([16,24,26] - (16+24+26)\div3)^2 \div3 = \frac{56}{3}<br>$$<br>再乘以各子数组在总数组中所占的比例:<br>$$<br>\begin{aligned}<br>mse&amp;=\frac{1}{4}mse_left+\frac{3}{4}mse_right\<br>&amp;=\frac{3}{4}\times \frac{56}{3}\<br>&amp;=14<br>\end{aligned}<br>$$<br>同理可以算出另外两种决策树模型的均方误差:</p>
<ul>
<li>②: [[600, 800], [1500,2500]]   —&gt;   [[14,16], [24,26]]</li>
</ul>
<p>均方误差为: 1</p>
<ul>
<li>③: [[600, 800, 1500], [2500]]   —&gt;   [[14,16,24], [26]]</li>
</ul>
<p>均方误差为: 14</p>
<p>均方误差越小,说明该模型预测的结果和真实值越接近,所以,不选它还选谁?</p>
<p>以上的推导只是梯度提升回归树的第一棵树的第一次裂变, 我们可以设置相应的参数,规定树的裂变次数, 所以按照以上的原理方式依次进行裂变,即可的到最精确的回归模型</p>
<p><a href="https://www.cnblogs.com/pinard/p/6140514.html" target="_blank" rel="noopener">刘建平 - 梯度提升树(GBDT)原理小结</a></p>
<h3 id="2-梯度提升分类树算法原理"><a href="#2-梯度提升分类树算法原理" class="headerlink" title="2:梯度提升分类树算法原理"></a>2:梯度提升分类树算法原理</h3><h4 id="1-二分类问题"><a href="#1-二分类问题" class="headerlink" title="(1): 二分类问题:"></a>(1): 二分类问题:</h4><h5 id="1-信息熵和交叉熵"><a href="#1-信息熵和交叉熵" class="headerlink" title="1): 信息熵和交叉熵:"></a>1): 信息熵和交叉熵:</h5><p>信息熵:<br>$$<br>\sum_{k=1}^N p_klog\frac{1}{p_k}<br>$$<br>交叉熵: (pk是真实分布比例, qk是非真实分布(预测分布比例))<br>$$<br>\sum_{k=1}^N p_klog\frac{1}{q_k}<br>$$</p>
<h5 id="2-GBDT原理概述"><a href="#2-GBDT原理概述" class="headerlink" title="2): GBDT原理概述"></a>2): GBDT原理概述</h5><p>GBDT 是先有 GB（梯度提升），再有 DT（决策树），所以我们先从 GB 讲起.</p>
<p>boosting 就是通过训练多个弱分类器来组合成一个强分类器，形式如下:<br>$$<br>F_m(x) = F_0 + \alpha_1 F_1(x) + \alpha_2 F_2(x)+… + \alpha_m F_m(x)<br>$$<br>其中，$F_i(x), i=1,2,3,…,m$ 是弱分类器，比如在 <strong>AdaBoost提升中是 C4.5决策树</strong>； $F_m(x)$是最终得到的强分类器; 而本篇中的<font color=red><strong>GBDT的弱分类器则是CART回归树(在GBDT中不管是回归问题还是分类问题,弱学习器都是决策回归树)</strong></font></p>
<p><strong>最深梯度下降法(Steepest Gradient Descent):</strong></p>
<ol>
<li><p>给定一个起点$x_0$</p>
</li>
<li><p>更新 $x$ 的位置:</p>
<p>​    $$i = 1,2,…,k$$</p>
<p>​    $$x_i = x_{i-1} + \gamma_{i-1}\times g_{i-1}$$</p>
</li>
</ol>
<p>其中:  $g_{i-1} = - \frac{\partial f}{\partial x}|_    {x=x_{i-1}}$ 表示 $f$  在 $x_{i-1}$ 处的导数</p>
<ol start="3">
<li>直到$|g_{i-1}|$足够小, 或者$|x_i-x_{i-1}| $ 足够小</li>
</ol>
<p>以上迭代过程可以理解为: <strong>整个寻优的过程就是小步快跑的过程，每跑一小步，都往函数当前下降最快的那个方向走一点，直到达到可接受的点</strong></p>
<p>这个迭代过程展开得到寻优的结果:</p>
<p>​        $$x_k = x_0 + \gamma_1g_1 + \gamma_2g_2 + … + \gamma_kg_k $$</p>
<p><strong>所以我们可以将最深梯度下降法运用到boosting, 不同的是最深梯度下降法求得的是一个最优值, 此时我们是要求得一个最优的函数</strong></p>
<h5 id="3-二分类损失函数-交叉熵"><a href="#3-二分类损失函数-交叉熵" class="headerlink" title="3): 二分类损失函数(交叉熵):"></a>3): 二分类损失函数(交叉熵):</h5><p>$$<br>\psi(y, p) = ylog(\frac{1}{p})+(1-y)log(\frac{1}{1-p})\\<br>\psi(y, p) = -ylog(p)-(1-y)log(1-p)\\<br>其中:\\<br>p=\frac{1}{1+exp(-F(x))}<br>$$<br>y是真实分布, p是非真实分布; 梯度提升回归森林是由决策回归树组成 , F(x)表示GBDT的学习器, 通过p这个sigmoid函数将其转换为相应的概率(多分类问题通过softmax函数转化概率)</p>
<p><strong>带入p化简:<font color=red>(此处log默认以e为底)</font></strong><br>$$<br>\begin{aligned}<br>\psi(y, F(x)) &amp; = -ylog(p)-(1-y)log_2(1-p)\\<br>&amp; = -ylog(\frac{1}{1+exp(-F(x))})-(1-y)log(1-\frac{1}{1+exp(-F(x))})\\<br>&amp; = ylog(1+exp(-F(x)))-(1-y)log(\frac{exp(-F(x))}{1+exp(-F(x))})\\<br>&amp; = ylog(1+exp(-F(x)))-(1-y)log(exp(-F(x)))+(1-y)log(1+exp(-F(x)))\\<br>&amp; = -(1-y)(-F(x))+log(1+exp(-F(x)))\\<br>&amp; = F(x)-yF(x)+log(1+exp(-F(x)))\\<br>&amp; = -yF(x)+log(exp(F(x)))+log(1+exp(-F(x)))\\<br>&amp; = -yF(x)+log(exp(F(x))\times (1+exp(-F(x))))\\<br>&amp; = -yF(x)+log(exp(F(x))+1)\\<br>\end{aligned}<br>$$</p>
<p><strong>对损失函数在$F_{m-1}(x)$ 处应用二级泰勒展开(方便计算$\gamma_{mj}$):</strong><br>$$<br>\begin{aligned}<br>L(\gamma_{mj}, R_{mj}) &amp;= \sum_{x_i \in R_{mj}}\psi(y, F_{m-1}(x)+\gamma_{mj})\\<br>&amp;\approx \sum_{x_i \in R_{mj}}{\psi(y, F_{m-1}(x))+\psi’(y, F_{m-1}(x))\gamma_{mj}+\frac{1}{2}\psi’’(y, F_{m-1}(x))\gamma_{mj}^2}\\<br>&amp;=argmin_{\gamma_{mj}}\sum_{x_i \in R_{mj}}{\psi(y_i,F_{m-1}(x_i)) + \psi’(y_i,F_{m-1}(x_i))\gamma_{mj} + \frac{1}{2}\psi’’(y_i,F_{m-1}(x_i))\gamma_{mj}^2 }<br>\end{aligned}<br>$$</p>
<p>$$F_m(x) = F_{m-1}(x) + \gamma_m*learning_rate$$</p>
<p>$\gamma_{mj}$ 相当于梯度下降中的梯度(<strong>这里可以理解为弱学习器的拟合函数</strong>), 表示第m轮的第j个叶节点的预测值</p>
<p>$R_{mj}$是第m轮学习的第j个叶节点, $F_{m-1}(x)$是上一轮学习的结果</p>
<p><strong>接着对损失函数的泰勒展开式求导:</strong><br>$$<br>\begin{aligned}<br>\frac{\partial L’(\gamma_{mj}, R_{mj})}{\partial\gamma_{mj}}&amp;=\sum_{x_i \in R_{mj}}{\psi’(y_i,F_{m-1}(x_i)) + \psi’’(y_i,F_{m-1}(x_i))*\gamma_{mj}}<br>\end{aligned}<br>$$</p>
<p><strong>上面泰勒展开式中有损失函数的一阶导数和二阶导数,所以:</strong></p>
<ol>
<li><strong>对损失函数求导(一阶导数):</strong></li>
</ol>
<p>$$<br>\begin{aligned}<br>\psi’(y, F(x)) &amp;=(-yF(x)+log(exp(F(x))+1))’\\<br>&amp;=-y+\frac{1}{exp(F(x))+1)}\times (exp(F(x)))’\\<br>&amp;注释: (e^x)’ = e^x\\<br>&amp;=-y+\frac{1}{exp(F(x))+1)}\times (exp(F(x)))\\<br>&amp;=-y+\frac{exp(F(x))}{exp(F(x))+1)}\\<br>&amp;注释: 分子分母同时除以exp(F(x))\\<br>&amp;=-y+\frac{1}{1+exp(-F(x))}\\<br>&amp;注释: sigmoid函数可以用\sigma表示\\<br>&amp;=-y+\sigma(F(x))<br>\end{aligned}<br>$$<br>2. <strong>对损失函数求导(二阶导数):</strong> </p>
<p>$$<br>\begin{aligned}<br>(\psi’(y, F(x)))’ &amp;=(-y+\frac{1}{1+exp(-F(x))})’\\<br>&amp;=[(1+exp(-F(x)))^{-1}]’\\<br>&amp;=-[1+exp(-F(x))]^{-2}\times exp(-F(x))\times [-F(x)]’\\<br>&amp;=-\frac{1}{[1+exp(-F(x))]^{2}}\times exp(-F(x))\times (-1)\\<br>&amp;=\frac{1}{1+exp(-F(x))}\times \frac{exp(-F(x))}{1+exp(-F(x))}\\<br>&amp;=\frac{1}{1+exp(-F(x))}\times \frac{exp(-F(x))+1-1}{1+exp(-F(x))}\\<br>&amp;=\frac{1}{1+exp(-F(x))}\times (1-\frac{1}{1+exp(-F(x))})\\<br>&amp;=\sigma(F(x))\times (1-\sigma(F(x)))\\<br>\end{aligned}<br>$$</p>
<p>此时令:</p>
<p>$$\widetilde{y} = y-\frac{1}{1+exp(-F(x))}$$</p>
<p>则损失函数的一阶导数为:</p>
<p>$$\psi’(y,F(x)) = -y + \frac{1}{1 + exp(-F(x))} = -\widetilde{y}$$</p>
<p>损失函数的二阶导数为:</p>
<p>$$\psi’’(y,F(x)) =\frac{1}{1+exp(-F(x))}\times (1-\frac{1}{1+exp(-F(x))})=(y - \widetilde{y})(1 - y + \widetilde{y})$$</p>
<p><strong>令导数为0, 并将损失函数的一阶导数和二阶导数带进去, 求$\gamma_{mj}$的最优函数:</strong><br>$$<br>0 = \sum_{x_i \in R_{mj}}{\psi’(y_i,F_{m-1}(x_i)) + \psi’’(y_i,F_{m-1}(x_i)) · \gamma_{mj}} \\<br>0 = \sum_{x_i \in R_{mj}}{-\widetilde{y_i} + (y_i - \widetilde{y_i})(1 - y_i + \widetilde{y_i}) · \gamma_{mj}} \\<br>$$</p>
<p>$$<br>\sum_{x_i \in R_{mj}}\widetilde{y_i} = \sum_{x_i \in R_{mj}}(y_i - \widetilde{y_i})(1 - y_i + \widetilde{y_i}) *\gamma_{mj}<br>$$</p>
<p>$$<br>\sum_{x_i \in R_{mj}}\widetilde{y_i} = (\sum_{x_i \in R_{mj}}(y_i - \widetilde{y_i})(1 - y_i + \widetilde{y_i}) )*\gamma_{mj}<br>$$</p>
<h5 id="4-求初始值"><a href="#4-求初始值" class="headerlink" title="4): 求初始值"></a>4): 求初始值</h5><p>$$<br>\begin{aligned}<br>F_0(x) &amp;= argmin_{\rho}\sum_{i=1}^N \psi(y_i, \rho)\\<br>&amp;=argmin_{\rho}H(\rho) = -\sum\limits_{i=1}^N(y_i\rho -log(1 + exp(\rho)))<br>\end{aligned}<br>$$</p>
<p>此时$F_0(x)$为$H(\rho)$的最小值, 当$H(\rho)$的导数为零时$F_0(x)$取最小值, 也就是$\rho$取得最小值,即为初始值</p>
<p>对$H(\rho)$求导<br>$$<br>H’(\rho) = -\sum\limits_{i = 1}^N(y_i - \frac{1}{1 + exp(-\rho)})<br>$$<br>令$$H’(\rho) = 0$$ ,求$\rho$<br>$$<br>0 = -\sum\limits_{i = 1}^N(y_i -\frac{1}{1 + exp(-\rho)})\\<br>0 = \sum\limits_{i = 1}^N(y_i -\frac{1}{1 + exp(-\rho)})\\<br>\sum\limits_{i=1}^Ny_i = \sum\limits_{i=1}^N\frac{1}{1+exp(-\rho)}\\<br>\sum\limits_{i=1}^Ny_i = \frac{N}{1+exp(-\rho)}\\<br>求倒数\\<br>\frac{(1 + exp(-\rho))}{N} = \frac{1}{\sum\limits_{i=1}^Ny_i}\\<br>1 + exp(-\rho) = \frac{N}{\sum\limits_{i=1}^Ny_i}\\<br>1 + exp(-\rho) = \frac{\sum\limits_{i=1}^N1}{\sum\limits_{i=1}^Ny_i}\\<br>exp(-\rho) = \frac{\sum\limits_{i=1}^N1}{\sum\limits_{i=1}^Ny_i} - 1\\<br>exp(-\rho) = \frac{\sum\limits_{i=1}^N(1 -y_i)}{\sum\limits_{i=1}^Ny_i}\\<br>对数运算\\<br>-\rho = log\frac{\sum\limits_{i=1}^N(1 -y_i)}{\sum\limits_{i=1}^Ny_i}\\<br>\rho = log\frac{\sum\limits_{i=1}^Ny_i}{\sum\limits_{i=1}^N(1 -y_i)}<br>$$</p>
<h5 id="5-最强学习器"><a href="#5-最强学习器" class="headerlink" title="5): 最强学习器"></a>5): <font color=red>最强学习器</font></h5><p>根据:<br>$$<br>F_m(x) = F_0 + \alpha_1 F_1(x) + \alpha_2 F_2(x)+… + \alpha_m F_m(x)<br>$$<br>其中:<br>$$<br>F_n(x) = F_{n-1}(x) + \gamma_n*learning_rate<br>$$<br>而此时初始值:<br>$$<br>F_0 =\rho = log\frac{\sum\limits_{i=1}^Ny_i}{\sum\limits_{i=1}^N(1 -y_i)}<br>$$<br>$\gamma$的值为:<br>$$<br>\gamma_{mj} = \frac{\sum_{x_i \in R_{mj}}\widetilde{y_i}}{\sum_{x_i \in R_{mj}}(y_i - \widetilde{y_i})(1 - y_i + \widetilde{y_i})}<br>$$<br>$learning_rate$ 的值为模型参数,</p>
<p><strong>经过足够多的学习次数, 最终能得出一个最优学习器$F_m(x)$</strong></p>
<h5 id="6-代码实现梯度提升分类树"><a href="#6-代码实现梯度提升分类树" class="headerlink" title="6): 代码实现梯度提升分类树"></a>6): 代码实现梯度提升分类树</h5><p>代码实现和模型调用进行对比</p>
<h6 id="①-模型调用-二分类结果"><a href="#①-模型调用-二分类结果" class="headerlink" title="①: 模型调用(二分类结果)"></a>①: 模型调用(二分类结果)</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造数据</span></span><br><span class="line">X = np.arange(<span class="number">1</span>,<span class="number">11</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">y = np.array([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义算法</span></span><br><span class="line"><span class="comment"># 默认情况下，损失函数就是Log-loss == 交叉熵！</span></span><br><span class="line">clf = GradientBoostingClassifier(n_estimators=<span class="number">100</span>,learning_rate=<span class="number">0.1</span>,max_depth=<span class="number">1</span>)</span><br><span class="line">clf.fit(X,y)</span><br><span class="line">y_ = clf.predict(X)</span><br><span class="line">print(<span class="string">'真实的类别：'</span>,y)</span><br><span class="line">print(<span class="string">'算法的预测：'</span>,y_)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">真实的类别： [0 0 0 1 1 0 0 0 1 1]</span></span><br><span class="line"><span class="string">算法的预测： [0 0 0 1 1 0 0 0 1 1]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制决策树</span></span><br><span class="line"><span class="comment"># 第一棵树</span></span><br><span class="line">_ = tree.plot_tree(clf[<span class="number">0</span>,<span class="number">0</span>],filled=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 第二棵树</span></span><br><span class="line">_ = tree.plot_tree(clf[<span class="number">1</span>,<span class="number">0</span>],filled=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 第三棵树</span></span><br><span class="line">_ = tree.plot_tree(clf[<span class="number">2</span>,<span class="number">0</span>],filled=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqlsmqk6uj20s20gajt1.jpg" alt="1tree.Png" style="zoom:50%;" />

<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqlswjrmuj20s00go75y.jpg" alt="2tree.Png" style="zoom:50%;" />

<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gmqlt4alf8j20rq0gs0ue.jpg" alt="3tree.Png" style="zoom:50%;" />

<h6 id="②-代码实现-二分类结果"><a href="#②-代码实现-二分类结果" class="headerlink" title="②: 代码实现(二分类结果)"></a>②: 代码实现(二分类结果)</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造数据</span></span><br><span class="line">X = np.arange(<span class="number">1</span>,<span class="number">11</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">y = np.array([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]*<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><strong>计算初始值:</strong><br>$$<br>F_0 =\rho = log\frac{\sum\limits_{i=1}^Ny_i}{\sum\limits_{i=1}^N(1 -y_i)}<br>$$<br>此处$y_i$表示类别, 其值为1(1表示true)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二分类问题，类别 ：0,1</span></span><br><span class="line"><span class="comment"># [0 0 0 1 1 0 0 0 1 1]</span></span><br><span class="line">F0 = np.log(<span class="number">4</span>/<span class="number">6</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">-0.40546510810816444</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>





<p><strong>计算$$\widetilde{y}$$ 导数就是梯度，负梯度</strong><br>$$<br>\widetilde{y} = y - \frac{1}{1+exp(-F(x))} = -\psi’(y,F(x))\\<br>\psi’(y,F(x)) = -y + \frac{1}{1 + exp(-F(x))}<br>$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数F(X) 初始值F0的负梯度</span></span><br><span class="line">yderivative0 = y - <span class="number">1</span>/(<span class="number">1</span> + np.exp(-F0))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([-0.4, -0.4, -0.4,  0.6,  0.6, -0.4, -0.4, -0.4,  0.6,  0.6])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>



<p><strong>拟合第一棵树:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分裂标准 mse</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    <span class="keyword">if</span> i ==<span class="number">10</span>:</span><br><span class="line">        mse = ((yderivative0 - yderivative0.mean())**<span class="number">2</span>).mean()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left_mse = ((yderivative0[:i] - yderivative0[:i].mean())**<span class="number">2</span>).mean()</span><br><span class="line">        right_mse = ((yderivative0[i:] - yderivative0[i:].mean())**<span class="number">2</span>).mean()</span><br><span class="line">        mse = left_mse*i/<span class="number">10</span> + right_mse*(<span class="number">10</span>-i)/<span class="number">10</span></span><br><span class="line">    print(<span class="string">'从第%d个进行切分'</span>%(i),np.round(mse,<span class="number">4</span>))</span><br><span class="line"><span class="comment"># 从第八个样本这里进行分类，最优的选择，和算法第一颗画图的结果一致</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">从第1个进行切分 0.2222</span></span><br><span class="line"><span class="string">从第2个进行切分 0.2</span></span><br><span class="line"><span class="string">从第3个进行切分 0.1714</span></span><br><span class="line"><span class="string">从第4个进行切分 0.225</span></span><br><span class="line"><span class="string">从第5个进行切分 0.24</span></span><br><span class="line"><span class="string">从第6个进行切分 0.2333</span></span><br><span class="line"><span class="string">从第7个进行切分 0.2095</span></span><br><span class="line"><span class="string">从第8个进行切分 0.15</span></span><br><span class="line"><span class="string">从第9个进行切分 0.2</span></span><br><span class="line"><span class="string">从第10个进行切分 0.24</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>





<p>计算左、右两侧叶子的预测值:<br>$$<br>\gamma_{mj} = \frac{\sum_{x_i \in R_{mj}}\widetilde{y_i}}{\sum_{x_i \in R_{mj}}(y_i - \widetilde{y_i})(1 - y_i + \widetilde{y_i})}<br>$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 左边分支</span></span><br><span class="line">gamma1 = np.round(yderivative0[:<span class="number">8</span>].sum()/((y[:<span class="number">8</span>] - yderivative0[:<span class="number">8</span>])*(<span class="number">1</span> - y[:<span class="number">8</span>] + yderivative0[:<span class="number">8</span>])).sum(),<span class="number">3</span>)</span><br><span class="line">print(<span class="string">'左边决策树分支，预测值：'</span>,gamma1)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">左边决策树分支，预测值： -0.625</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 右边分支</span></span><br><span class="line">gamma2 =np.round(yderivative0[<span class="number">8</span>:].sum()/((y[<span class="number">8</span>:] - yderivative0[<span class="number">8</span>:])*(<span class="number">1</span> - y[<span class="number">8</span>:] + yderivative0[<span class="number">8</span>:])).sum(),<span class="number">3</span>)</span><br><span class="line">print(<span class="string">'右边决策树分支，预测值：'</span>,gamma2)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">右边决策树分支，预测值： 2.5</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p><strong>第一棵树拟合完毕, 代码实现的，和算法中的第一颗树（画图显示），完全一样</strong></p>
<p>以此类推实现第二棵树:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拟合第二颗树</span></span><br><span class="line"><span class="comment"># 第一颗预测的结果</span></span><br><span class="line">gamma = np.array([<span class="number">-0.625</span>]*<span class="number">8</span> + [<span class="number">2.5</span>]*<span class="number">2</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([-0.625, -0.625, -0.625, -0.625, -0.625, -0.625, -0.625, -0.625,</span></span><br><span class="line"><span class="string">        2.5  ,  2.5  ])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># F(x) 随着梯度提升树，提升，发生变化</span></span><br><span class="line">learning_rate = <span class="number">0.1</span></span><br><span class="line">F1 =np.round( F0 + gamma*learning_rate,<span class="number">4</span>) <span class="comment">#保留4位小数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([-0.468 , -0.468 , -0.468 , -0.468 , -0.468 , -0.468 , -0.468 ,</span></span><br><span class="line"><span class="string">       -0.468 , -0.1555, -0.1555])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算F1(x)的负梯度</span></span><br><span class="line">yderivative1 = np.round(y - <span class="number">1</span>/(<span class="number">1</span> + np.exp(-F1)),<span class="number">4</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([-0.3851, -0.3851, -0.3851,  0.6149,  0.6149, -0.3851, -0.3851,</span></span><br><span class="line"><span class="string">       -0.3851,  0.5388,  0.5388])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二颗树分裂标准 mse</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    <span class="keyword">if</span> i ==<span class="number">10</span>:</span><br><span class="line">        mse = ((yderivative1 - yderivative1.mean())**<span class="number">2</span>).mean()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left_mse = ((yderivative1[:i] - yderivative1[:i].mean())**<span class="number">2</span>).mean()</span><br><span class="line">        right_mse = ((yderivative1[i:] - yderivative1[i:].mean())**<span class="number">2</span>).mean()</span><br><span class="line">        mse = left_mse*i/<span class="number">10</span> + right_mse*(<span class="number">10</span>-i)/<span class="number">10</span></span><br><span class="line">    print(<span class="string">'从第%d个进行切分'</span>%(i),np.round(mse,<span class="number">4</span>))</span><br><span class="line"><span class="comment"># 第二棵树也是从第八个样本这里进行分类，最优的选择，和算法第二颗画图的结果一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 左边分支</span></span><br><span class="line">gamma1 = np.round(yderivative1[:<span class="number">8</span>].sum()/((y[:<span class="number">8</span>] - yderivative1[:<span class="number">8</span>])*(<span class="number">1</span> - y[:<span class="number">8</span>] + yderivative1[:<span class="number">8</span>])).sum(),<span class="number">3</span>)</span><br><span class="line">print(<span class="string">'第二棵树左边决策树分支，预测值：'</span>,gamma1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 右边分支</span></span><br><span class="line">gamma2 =np.round(yderivative1[<span class="number">8</span>:].sum()/((y[<span class="number">8</span>:] - yderivative1[<span class="number">8</span>:])*(<span class="number">1</span> - y[<span class="number">8</span>:] + yderivative1[<span class="number">8</span>:])).sum(),<span class="number">3</span>)</span><br><span class="line">print(<span class="string">'第二棵树右边决策树分支，预测值：'</span>,gamma2)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第二棵树左边决策树分支，预测值： -0.571</span></span><br><span class="line"><span class="string">第二棵树右边决策树分支，预测值： 2.168</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>第三棵树:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二棵树预测值</span></span><br><span class="line">gamma = np.array([<span class="number">-0.571</span>]*<span class="number">8</span> + [<span class="number">2.168</span>]*<span class="number">2</span>)</span><br><span class="line"><span class="comment"># F(x) 随着梯度提升树，提升，发生变化</span></span><br><span class="line">learning_rate = <span class="number">0.1</span></span><br><span class="line">F2 =np.round( F1 + gamma*learning_rate,<span class="number">4</span>) <span class="comment">#保留4位小数</span></span><br><span class="line"><span class="comment"># 计算F2(x)的负梯度</span></span><br><span class="line">yderivative2 = np.round(y - <span class="number">1</span>/(<span class="number">1</span> + np.exp(-F2)),<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三颗树分裂标准 mse</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    <span class="keyword">if</span> i ==<span class="number">10</span>:</span><br><span class="line">        mse = ((yderivative2 - yderivative2.mean())**<span class="number">2</span>).mean()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left_mse = ((yderivative2[:i] - yderivative2[:i].mean())**<span class="number">2</span>).mean()</span><br><span class="line">        right_mse = ((yderivative2[i:] - yderivative2[i:].mean())**<span class="number">2</span>).mean()</span><br><span class="line">        mse = left_mse*i/<span class="number">10</span> + right_mse*(<span class="number">10</span>-i)/<span class="number">10</span></span><br><span class="line">    print(<span class="string">'从第%d个进行切分'</span>%(i),np.round(mse,<span class="number">4</span>))</span><br><span class="line"><span class="comment"># 第三棵树从第三个样本这里进行裂分，最优的选择，和算法第三颗画图的结果一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  计算第三颗树的预测值</span></span><br><span class="line"><span class="comment"># 前三个是一类</span></span><br><span class="line"><span class="comment"># 后七个是一类</span></span><br><span class="line"><span class="comment"># 左边分支</span></span><br><span class="line">gamma1 = np.round(yderivative2[:<span class="number">3</span>].sum()/((y[:<span class="number">3</span>] - yderivative2[:<span class="number">3</span>])*(<span class="number">1</span> - y[:<span class="number">3</span>] + yderivative2[:<span class="number">3</span>])).sum(),<span class="number">3</span>)</span><br><span class="line">print(<span class="string">'第三棵树左边决策树分支，预测值：'</span>,gamma1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 右边分支</span></span><br><span class="line">gamma2 =np.round(yderivative2[<span class="number">3</span>:].sum()/((y[<span class="number">3</span>:] - yderivative2[<span class="number">3</span>:])*(<span class="number">1</span> - y[<span class="number">3</span>:] + yderivative2[<span class="number">3</span>:])).sum(),<span class="number">3</span>)</span><br><span class="line">print(<span class="string">'第三棵树右边决策树分支，预测值：'</span>,gamma2)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">第三棵树左边决策树分支，预测值： -1.592</span></span><br><span class="line"><span class="string">第三棵树右边决策树分支，预测值： 0.666</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>



<p>最后将最后一棵树的结果通过sigmoid函数转换乘概率:<br>$$<br>p = \frac{1}{1 + exp(-F(x))}<br>$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算第三颗的F3(x)</span></span><br><span class="line"><span class="comment"># 第三颗树预测值</span></span><br><span class="line">gamma = np.array([<span class="number">-1.592</span>]*<span class="number">3</span> + [<span class="number">0.666</span>]*<span class="number">7</span>)</span><br><span class="line"><span class="comment"># F(x) 随着梯度提升树，提升，发生变化</span></span><br><span class="line">learning_rate = <span class="number">0.1</span></span><br><span class="line">F3 =np.round( F2 + gamma*learning_rate,<span class="number">4</span>) <span class="comment">#保留4位小数</span></span><br><span class="line"></span><br><span class="line">proba = <span class="number">1</span>/(<span class="number">1</span> + np.exp(-F3))</span><br><span class="line"><span class="comment"># 类别：0,1，如果这个概率大于等于0.5类别1，小于0.5类别0</span></span><br><span class="line">(proba &gt;= <span class="number">0.5</span>).astype(np.int8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1], dtype=int8)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>可见第三棵树的分类结果已经达到一定的准确率;</p>
<p>以此类推,只要循环的次数足够多, 就能达到和算法的分类结果相同(代码设置的树是100颗)</p>
<p>至此,完毕</p>
<h3 id="3-梯度提升树的优缺点"><a href="#3-梯度提升树的优缺点" class="headerlink" title="3: 梯度提升树的优缺点"></a>3: 梯度提升树的优缺点</h3><p><strong>优点</strong></p>
<p>1) 可以灵活处理各种类型的数据，包括连续值和离散值。</p>
<p>2) 在相对少的调参时间情况下，预测的准确率也可以比较高。这个是相对SVM来说的。</p>
<p>3）使用一些健壮的损失函数，对异常值的鲁棒性非常强。比如 Huber损失函数和Quantile损失函数。</p>
<p><strong>缺点</strong></p>
<p>1)由于弱学习器之间存在依赖关系，难以并行训练数据。不过可以通过自采样的SGBT来达到部分并行。</p>
<h3 id="4-梯度提升树参数详解"><a href="#4-梯度提升树参数详解" class="headerlink" title="4: 梯度提升树参数详解"></a>4: 梯度提升树参数详解</h3><p><a href="https://www.cnblogs.com/pinard/p/6143927.html" target="_blank" rel="noopener">刘建平 - scikit-learn 梯度提升树(GBDT)调参小结</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/34507947" target="_blank" rel="noopener">Surface 键盘耐脏又好擦？真的吗？</a></p>
<br>



<h1 id="六-XGboost"><a href="#六-XGboost" class="headerlink" title="六: XGboost"></a>六: XGboost</h1><p>在算法的弱学习器模型选择上，对比GBDT只支持决策树，还可以直接很多其他的弱学习器。</p>
<p>在算法的损失函数上，除了本身的损失，还加上了正则化部分。</p>
<p>在算法的优化方式上，GBDT的损失函数只对误差部分做负梯度（一阶泰勒）展开，而XGBoost损失函数对误差部分做二阶泰勒展开，更加准确</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>算法</tag>
        <tag>集成算法</tag>
        <tag>Bagging</tag>
        <tag>随机森林</tag>
        <tag>Boosting</tag>
        <tag>AdaBoost</tag>
        <tag>GBDT</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络</title>
    <url>/2019/07/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p><strong>本文整理自:</strong></p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/27642620" target="_blank" rel="noopener">YJango的卷积神经网络——介绍</a></li>
<li><a href="https://www.jianshu.com/p/c0215d26d20a" target="_blank" rel="noopener">从此明白了卷积神经网络（CNN）</a></li>
</ul>
<h1 id="一-卷积神经网络的结构组成"><a href="#一-卷积神经网络的结构组成" class="headerlink" title="一: 卷积神经网络的结构组成"></a>一: 卷积神经网络的结构组成</h1><p><strong>1. Convolutional layer（卷积层–CONV）</strong><br> 由滤波器filters和激活函数构成。<br> 一般要设置的超参数包括filters的数量、大小、步长，以及padding是“valid”还是“same”。当然，还包括选择什么激活函数。</p>
<p><strong>2. Pooling layer （池化层–POOL）</strong><br> 这里里面没有参数需要我们学习，因为这里里面的参数都是我们设置好了，要么是Maxpooling，要么是Averagepooling。<br> 需要指定的超参数，包括是Max还是average，窗口大小以及步长。<br> 通常，我们使用的比较多的是Maxpooling,而且一般取大小为(2,2)步长为2的filter，这样，经过pooling之后，输入的长宽都会缩小2倍，channels不变。</p>
<p><strong>3. Fully Connected layer（全连接层–FC）</strong><br> 这个前面没有讲，是因为这个就是我们最熟悉的家伙，<strong>就是我们之前学的神经网络中的那种最普通的层，就是一排神经元</strong>。因为这一层是每一个单元都和前一层的每一个单元相连接，所以称之为“全连接”。<br> 这里要指定的超参数，无非就是神经元的数量，以及激活函数。</p>
<p>在上面的三个步骤中卷积层和池化层可以叠加多次</p>
<p>在经过数次卷积和池化之后，我们 <strong>最后会先将多维的数据进行“扁平化”，</strong>也就是把 <strong>(height,width,channel)</strong>的数据压缩成长度为 <strong>height × width × channel</strong> 的一维数组，然后再与 <strong>FC层</strong>连接，<strong>这之后就跟普通的神经网络无异了</strong>。</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5ou4t76zj20m80903yx.jpg" alt="CNN.png" style="zoom:67%;" />





<br>



<h1 id="二-卷积层"><a href="#二-卷积层" class="headerlink" title="二: 卷积层"></a>二: 卷积层</h1><p>在计算机中, 图片是由像素组成, 而每个像素由RGB三种颜色代表得数值表达, </p>
<p>我们可以想象一张图片是数字构成的“长方体”。可用 宽width, 高height, 深depth 来描述，如图。</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5ouemhayj208h070jr9.jpg" alt="图片结构.png" style="zoom:67%;" />

<p>RGB中得每个颜色的数值都可以单独写成一个矩阵的表达形式</p>
<h2 id="1-kernel-卷积核"><a href="#1-kernel-卷积核" class="headerlink" title="1: kernel(卷积核)"></a>1: <strong>kernel</strong>(卷积核)</h2><p>接下来我们将以单层的<strong>‘矩阵’</strong>为例进行讲解</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5our9oeug20go0c3wgl.jpg" alt="卷积层.png" style="zoom:67%;" />

<p>如上图所示, 图中灰色的3x3的区域我们称之为<strong>filter</strong>(滤波器), 也叫<strong>kernel</strong>(卷积核), 我们用这个filter，往我们的第一层矩阵上“盖”，覆盖一块跟filter一样大的区域之后，对应元素相乘，然后求和。计算一个区域之后，就向其他区域挪动，接着计算，直到把原图片的每一个角落都覆盖到了为止。这个过程就是 <strong>“卷积”</strong>。</p>
<p><strong>来一个更直观的:</strong> </p>
<p>卷积核是一个小矩阵, 下图中每个格子的右下角红色的就是卷积矩阵, 与对应位置的值相乘求和之后会得到卷积后的结果<strong>convolved feature</strong> 或 <strong>Feature Map</strong></p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5ov0qaudg20em0aot9j.jpg" alt="卷积层2.png" style="zoom:67%;" />



<p><strong><font color=red>需要注意的是:  卷积核相当于卷积运算的权重, 而卷积核扫描过的所有位置计算输出节点时使用的都是相同的卷积核, 也就是相同的权重, 这就是卷积神经网络的空间共享</font></strong></p>
<p>我们知道了1层像素矩阵怎么处理了, 但我们的图片一般都是由RBG组成的撒能矩阵, </p>
<p>在2D卷积中，filter在张量的width维, height维上是局部连接，在depth维上是贯串全部channels的。</p>
<p>想象在切蛋糕的时候，不管这个蛋糕有多少层，通常大家都会一刀切到底，但是在长和宽这两个维上是局部切割。</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5p6n1k74j20920cnt8r.jpg" alt="多层 - 副本2.png" style="zoom: 50%;" />

<ul>
<li>在输入depth为1时：被filter size为2x2所圈中的4个输入节点连接到1个输出节点上。</li>
<li>在输入depth为3时：被filter size为2x2，但是贯串3个channels后，所圈中的12个输入节点连接到1个输出节点上。</li>
</ul>
<p><strong><font color=red>注意:  虽然多层会累积到一个点, 但是每层的卷积矩阵并不共用, 每一层RGB矩阵都有自己的卷积核</font></strong></p>
<p>此时的运算规则是:   将每层的结果求解出来再求和, 然后输出为一个数</p>
<h2 id="2-Zero-padding"><a href="#2-Zero-padding" class="headerlink" title="2: Zero padding"></a>2: Zero padding</h2><p>若按照以上的方式进行计算, 每次卷积之后我们的图像就会变小, 如果次数多一点, 那我们的凸显都被卷没了, 另外, 这样有个缺点就是图像边缘的像素点很少被计算, 容易造成信息丢失</p>
<p>而padding就可以很好的解决这个问题, </p>
<p>具体方法就是, 在原图片的周围先填充一圈空白像素, 这样我们在卷积之后得到的Feature Map尺寸依然和原尺寸一样</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5p2qhu1sj20hs0e4jrm.jpg" alt="Zero padding.png" style="zoom:67%;" />



<p>通常大家都想要在卷积时保持图片的原始尺寸。 选择3x3的filter和1的zero padding，或5x5的filter和2的zero padding可以保持图片的原始尺寸。 这也是为什么大家多选择3x3和5x5的filter的原因。 另一个原因是3x3的filter考虑到了像素与其距离为1以内的所有其他像素的关系，而5x5则是考虑像素与其距离为2以内的所有其他像素的关系。</p>
<h2 id="3-多个卷积核"><a href="#3-多个卷积核" class="headerlink" title="3: 多个卷积核"></a>3: 多个卷积核</h2><p>每个filter可以抓取探测特定的形状的存在</p>
<p>因此我们自然而然的会选择用多个不同的filters对同一个图片进行多次抓取</p>
<p>这样卷积层的输出也不再是depth为1的一个平面，而是和输入一样是depth为复数的长方体。</p>
<p>如下图所示，当我们增加一个filter（紫色表示）后，就又可以得到一个Feature Map。 将不同filters所卷积得到的Feature Maps按顺序堆叠后，就得到了一个卷积层的最终输出。</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5p9papzbj20go089tda.jpg" alt="多层输出.png" style="zoom:67%;" />



<p>这样卷积后输出的长方体可以作为新的输入送入另一个卷积层中处理。</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5pa2yru7j20xc0irt90.jpg" alt="多个卷积核.png" style="zoom: 50%;" />







<h2 id="4-激活函数"><a href="#4-激活函数" class="headerlink" title="4: 激活函数"></a>4: 激活函数</h2><p>经过线性组合和偏移后，会加入非线性增强模型的拟合能力。</p>
<br>





<h1 id="三-池化层"><a href="#三-池化层" class="headerlink" title="三: 池化层"></a>三: 池化层</h1><p>常见的池化方法: average pooling 和 max pooling</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5pacyacuj20dw09w3yp.jpg" alt="池化.png" style="zoom:50%;" />

<p>顾名思义max pooling就是取该区域内的最大值, average pooling就是取该区域内的平均值</p>
<p><strong>max pooling在不同的depth上是分开执行的，且不需要参数控制。</strong></p>
<p>Max pooling的主要功能是<strong>降采样(downsamping)</strong>，却不会损坏识别结果。</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5pajyrpij20ro083aae.jpg" alt="池化2.png" style="zoom:50%;" />





<br>



<h1 id="四-全连接层"><a href="#四-全连接层" class="headerlink" title="四: 全连接层"></a>四: 全连接层</h1><p>全连接层（也叫前馈层）, 通常卷积网络的最后会将末端得到的长方体平摊(flatten)成一个长长的向量，并送入全连接层配合输出层进行分类。</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5pat7somj20et07bt8z.jpg" alt="全连接层.png" style="zoom:67%;" />







<p><strong>卷积神经网络结构图</strong></p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5pb0j7ldj21ji0s278p.jpg" alt="卷积神经网络.png" style="zoom:67%;" />]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>循环神经网络</title>
    <url>/2019/07/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<blockquote>
<p>本文整理自:</p>
<p>原理推导:</p>
<p><a href="https://zybuluo.com/hanbingtao/note/541458" target="_blank" rel="noopener">零基础入门深度学习(5) - 循环神经网络</a></p>
<p><a href="https://zybuluo.com/hanbingtao/note/581764" target="_blank" rel="noopener">零基础入门深度学习(6) - 长短时记忆网络(LSTM)</a></p>
<p>原理讲解:</p>
<p><a href="https://zhuanlan.zhihu.com/p/123211148" target="_blank" rel="noopener">史上最详细循环神经网络讲解（RNN/LSTM/GRU）</a></p>
</blockquote>
<h1 id="一-循环神经网络RNN"><a href="#一-循环神经网络RNN" class="headerlink" title="一: 循环神经网络RNN"></a>一: 循环神经网络RNN</h1><p>某些任务需要能够更好的处理<strong>序列</strong>的信息，即前面的输入和后面的输入是有关系的。比如，当我们在理解一句话意思时，孤立的理解这句话的每个词是不够的，我们需要处理这些词连接起来的整个<strong>序列</strong>；当我们处理视频的时候，我们也不能只单独的去分析每一帧，而要分析这些帧连接起来的整个<strong>序列</strong>。这时，就需要用到深度学习领域中另一类非常重要神经网络：<strong>循环神经网络(Recurrent Neural Network)</strong>。</p>
<p>RNN的特点，<strong>RNN对具有序列特性的数据非常有效，它能挖掘数据中的时序信息以及语义信息，</strong>利用了RNN的这种能力，使深度学习模型在解决语音识别、语言模型、机器翻译以及时序分析等NLP领域的问题时有所突破。</p>
<h2 id="1-基本循环神经网络"><a href="#1-基本循环神经网络" class="headerlink" title="1: 基本循环神经网络"></a>1: 基本循环神经网络</h2><p>下图是一个简单的循环神经网络如，它由输入层、一个隐藏层和一个输出层组成：</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5o8fz9lij203s08vdfx.jpg" alt="基本RNN结构.png" style="zoom:67%;" />



<p><strong>如果将右边的w部分先拿掉, 那剩下的就是最基本的神经网络连接图,</strong> </p>
<ul>
<li><p>X是输入, </p>
</li>
<li><p>U是输入层到隐藏层的参数矩阵(权重矩阵), </p>
</li>
<li><p>S是是隐藏层向量, 是通过X和U的线性组合之后再通过激活函数得到</p>
</li>
<li><p>V是隐藏层到输出层的参数矩阵, </p>
</li>
<li><p>O是输出</p>
</li>
</ul>
<p>那W是什么? <strong>W可以理解为每个时间点之间的参数矩阵(权重矩阵)</strong></p>
<p>将上面的图展开:</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5o8tldymj20m308vaaz.jpg" alt="基本RNN展开结构.png" style="zoom:67%;" />



<p>如上图: 这个网络在t时刻接收到输入$X_t$之后，隐藏层的值是$S_t$，输出值是$O_t$。关键一点是，$S_t$的值不仅仅取决于$X_t$，还取决于$S_{t-1}$。我们可以用下面的公式来表示<strong>循环神经网络</strong>的计算方法：<br>$$<br>o_t = g(Vs_t)\<br>s_t = f(Ux_t+Ws_{t-1})<br>$$<br><strong>值得注意的一点是，在整个训练过程中，每一时刻所用的都是同样的W。</strong></p>
<h2 id="2-双向循环神经网络"><a href="#2-双向循环神经网络" class="headerlink" title="2: 双向循环神经网络"></a>2: 双向循环神经网络</h2><p>在很多时候, 语言处理光看前面的词是不够的，比如下面这句话：</p>
<blockquote>
<p>我的手机坏了，我打算____一部新手机。</p>
</blockquote>
<p>可以想象，如果我们只看横线前面的词，手机坏了，那么我是打算修一修？换一部新的？还是大哭一场？这些都是无法确定的。但如果我们也看到了横线后面的词是『一部新手机』，那么，横线上的词填『买』的概率就大得多了。</p>
<p>这个时候, 我们就需要<strong>双向循环神经网络</strong>了</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5o96z8p4j21080codje.jpg" alt="双向循环神将网络.png" style="zoom:67%;" />



<p>从上图可以看出，<strong>双向卷积神经网络</strong>的隐藏层要保存两个值，一个A参与正向计算，另一个值A’参与反向计算。最终的输出值$y_2$取决于$A_2$和$A’_2$。其计算方法为：<br>$$<br>y_2 = g(VA_2 + V’A’_2)<br>$$</p>
<p>$A_2$和$A’_2$则分别计算：<br>$$<br>A_2 = f(WA_1 + Ux_2)\<br>A’_2 = f(W’A’_3 + U’x_2)<br>$$</p>
<p>可以看出: 正向计算时，隐藏层的值$s_t$与$s_{t-1}$有关；反向计算时，隐藏层的值$s’<em>t$与$s</em>{t+1}$有关；最终的输出取决于正向和反向计算的<strong>加和</strong>。</p>
<p>双向循环神经网络的计算方法：<br>$$<br>o_t = g(Vs_t + V’s’_t)<br>$$</p>
<p>$$<br>s_t = f(Ux_t + Ws_{t-1})<br>$$</p>
<p>$$<br>s’_t = f(U’x_t + W’s’_{t+1})<br>$$</p>
<p>从上面三个公式我们可以看到，正向计算和反向计算<strong>不共享权重</strong>，也就是说U和U’、W和W’、V和V’都是不同的<strong>权重矩阵</strong>。</p>
<p>堆叠两个以上的隐藏层，这样就得到了<strong>深度循环神经网络</strong>。如下图所示：</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5o9ik2sjj20dc0epgn6.jpg" alt="深度循环神经网络.png" style="zoom:67%;" />







<br>



<h1 id="二-长短时记忆网络-LSTM"><a href="#二-长短时记忆网络-LSTM" class="headerlink" title="二: 长短时记忆网络(LSTM)"></a>二: 长短时记忆网络(LSTM)</h1><p>RNN每一时刻的隐藏状态都不仅由该时刻的输入决定，还取决于上一时刻的隐藏层的值，如果一个句子很长，到句子末尾时，它将记不住这个句子的开头的内容详细内容</p>
<p><strong>LSTM是一种改进之后的循环神经网络</strong></p>
<p>RNN是<strong>每个时刻都会把隐藏层的值存下来，到下一时刻的时候再拿出来用，这样就保证了，每一时刻含有上一时刻的信息</strong>，如图，我们把存每一时刻信息的地方叫做Memory Cell，中文就是记忆细胞。</p>
<p><strong>而LSTM则会通过它特有的门控机制选择相应的信息</strong></p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5o9sh1b7j20gq0a83z4.jpg" alt="LMST原理.png" style="zoom:67%;" />



<ol>
<li>Input Gate：中文是输入门，在每一时刻从输入层输入的信息会首先经过输入门，输入门的开关会决定这一时刻是否会有信息输入到Memory Cell(每一时刻信息的地方)。</li>
<li>Output Gate：中文是输出门，每一时刻是否有信息从Memory Cell输出取决于这一道门。</li>
<li>Forget Gate：中文是遗忘门，每一时刻Memory Cell里的值都会经历一个是否被遗忘的过程，就是由该门控制的，如果打卡，那么将会把Memory Cell里的值清除，也就是遗忘掉。</li>
</ol>
<p><strong>LSTM和普通RNN正是贵族和乞丐，RNN什么信息它都存下来，因为它没有挑选的能力，而LSTM不一样，它会选择性的存储信息，因为它能力强，它有门控装置，它可以尽情的选择。</strong></p>
<p><strong>信息在传递的顺序，是这样的：</strong></p>
<p>先经过输入门，看是否有信息输入，再判断遗忘门是否选择遗忘Memory Cell里的信息，最后再经过输出门，判断是否将这一时刻的信息进行输出。</p>
<p><strong>LSTM内部结构图</strong></p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5oa1yothj20cd0e074h.jpg" alt="LSTM内部结构图.png" style="zoom:67%;" />

<p>LSTM里常用的激活函数有两个，一个是tanh，一个是sigmoid。</p>
<p>其中:<br>$$<br>Z = tanh(W[x_t, h_{t-1}])\\<br>Z_i = sigmoid(W_i[x_t, h_{t-1}])\\<br>Z_f = sigmoid(W_f[x_t, h_{t-1}])\\<br>Z_o = sigmoid(W_o[x_t, h_{t-1}])<br>$$<br><strong>其中: W为各个时刻之间的权重矩阵, $h_{t-1}$是上一时刻的隐藏层信息, 并且每个门的权重向量都不一样</strong></p>
<p>其中 $Z$ 是最为普通的输入，可以从上图中看到， $Z$ 是通过该时刻的输入 $X_t$ 和上一时刻存在memory cell里的隐藏层信息 $h_{t-1}$ 向量拼接，再与权重参数向量点积，得 $W$ 到的值经过激活函数tanh最终会得到一个数值，也就是 $Z$ ，注意只有 $Z$ 的激活函数是tanh，因为 $Z$ 是真正作为输入的，其他三个都是门控装置。</p>
<p>再来看 $Z_i$ ，input gate的缩写i，所以也就是输入门的门控装置， $Z_i$ 同样也是通过该时刻的输入和上 $X_t$ 一时刻隐藏状态，也就是上一时刻存下来的信息 $h_{t-1}$ 向量拼接，在与权重参数向量点积（注 $W$ 意每个门的权重向量都不一样，这里的下标i代表input的意思，也就是输入门）。得到的值经过激活函数sigmoid的最终会得到一个0-1之间的一个数值，用来作为输入门的控制信号。</p>
<p>首先解释一下，经过这个sigmod激活函数后，得到的 $Z_i, Z_f, Z_o$  都是在0到1之间的数值，1表示该门完全打开，0表示该门完全关闭，</p>
<br>



<h1 id="三-梯度消失与梯度爆炸"><a href="#三-梯度消失与梯度爆炸" class="headerlink" title="三: 梯度消失与梯度爆炸"></a>三: 梯度消失与梯度爆炸</h1><p>梯度消失和梯度爆炸其实是一种情况：均是在神经网络中，<strong>当前面隐藏层的学习速率低于后面隐藏层的学习速率，即随着隐藏层数目的增加，分类准确率反而下降了。</strong></p>
<p>其实梯度爆炸和梯度消失问题都是因为<strong>网络太深</strong>，网络权值更新不稳定造成的，本质上是因为梯度反向传播中的连乘效应。</p>
<p><strong>梯度消失产生的原因：</strong></p>
<p>（1）隐藏层的层数过多;</p>
<p>（2）采用了不合适的激活函数（更容易产生梯度消失，但是也有可能产生梯度爆炸）</p>
<p><strong>梯度爆炸产生的原因：</strong></p>
<p>（1）隐藏层的层数太多;</p>
<p>（2）权重初始化值过大。</p>
<p>1、为什么说隐藏层数过多会造成梯度消失或梯度爆炸？</p>
<p>从深层网络角度来讲，不同的层学习的速度差异很大，表现为网路中靠近输出的层学习的情况很好，靠近输入的层学习的很慢，有时甚至训练了很久，前基层的权值和刚开始随机初始化的值差不多。因此，梯度消失、爆炸，其根本原因在于反向传播训练法则，属于先天不足。</p>
<p>2、激活函数不合适</p>
<p>损失函数对某个权重求偏导, 用求导的链式法则进行分解, 求导的结果与权重W和激活函数的导数有关, $|\sigma’(z)w| \leq 0.25 $, 而sigmoid函数求导后最大最大也只能是0.25,  初始化权重参数W时，通常都小于1, 多个小于1的数连乘之后，那将会越来越小，导致靠近输入层的层的权重的偏导几乎为0，也就是说几乎不更新，这就是梯度消失的根本原因。</p>
<p>再来看看梯度爆炸的原因，也就是说如果$|\sigma’(z)w| \geq 1 $时，连乘下来就会导致梯度过大，导致梯度更新幅度特别大，可能会溢出，导致模型无法收敛。sigmoid的函数是不可能大于1了，上图看的很清楚，那只能是w了，这也就是经常看到别人博客里的一句话，<strong>初始权重过大</strong>，一直不理解为啥。。现在明白了。</p>
<p>3、初始化权重的值过大</p>
<p>也就是w比较大的情况下，根据2式的链式相乘可得(反向传播)，则前面的网络层比后面的网络层梯度变化更快，引起了梯度爆炸的问题。所以，在一般的神经网络中，权重的初始化一般都利用高斯分布随机产生权重值。</p>
<ol start="10">
<li>梯度消失和梯度爆炸的问题是如何产生的？如何解决？</li>
</ol>
<p>答：第一个问题相对简单，由于反向传播过程中，前面网络权重的偏导数的计算是逐渐从后往前累乘的，如果使用 $\sigma, tanh$ 激活函数的话，由于导数小于一，因此累乘会逐渐变小，导致梯度消失，前面的网络层权重更新变慢；如果权重 $w$ 本身比较大，累乘会导致前面网络的参数偏导数变大，产生数值上溢。</p>
<p>因为 sigmoid 导数最大为1/4，故只有当abs(w)&gt;4时才可能出现梯度爆炸，因此最普遍发生的是梯度消失问题。</p>
<p>解决方法通常包括</p>
<ol>
<li>使用ReLU等激活函数，梯度只会为0或者1，每层的网络都可以得到相同的更新速度</li>
<li>采用LSTM</li>
<li>进行梯度裁剪(clip), 如果梯度值大于某个阈值，我们就进行梯度裁剪，限制在一个范围内</li>
<li>使用正则化，这样会限制参数 $w$ 的大小，从而防止梯度爆炸</li>
<li>设计网络层数更少的网络进行模型训练</li>
<li>batch normalization</li>
</ol>
<p><strong>梯度消失与梯度爆炸的解决方案：</strong></p>
<p>（1）预训练加微调</p>
<p>（2）梯度剪切、正则</p>
<p>（3）ReLU、LeakyReLU、ELU等激活函数</p>
<p>（4）BatchNormalization</p>
<p>（5）残差结构</p>
<p>（6）LSTM</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>递归神经网络</tag>
        <tag>RNN</tag>
        <tag>LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络</title>
    <url>/2019/07/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>本文整理自:</p>
<ul>
<li><a href="https://www.cnblogs.com/subconscious/p/5058741.html" target="_blank" rel="noopener">神经网络浅讲：从神经元到深度学习</a></li>
</ul>
<h1 id="一-生物神经网络"><a href="#一-生物神经网络" class="headerlink" title="一: 生物神经网络"></a>一: 生物神经网络</h1><h3 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h3><p>一个神经元通常具有多个<strong>树突</strong>，主要用来接受传入信息；而<strong>轴突</strong>只有一条，轴突尾端有许多轴突末梢可以给其他多个神经元传递信息。轴突末梢跟其他神经元的树突产生连接，从而传递信号。这个连接的位置在生物学上叫做“<strong>突触</strong>”。</p>
<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5nxyrkduj20b206ldgd.jpg" alt="神经元.png"></p>
<br>



<h1 id="二-人工神经网络-ANN"><a href="#二-人工神经网络-ANN" class="headerlink" title="二: 人工神经网络(ANN)"></a>二: 人工神经网络(ANN)</h1><h2 id="一-神经元模型MP"><a href="#一-神经元模型MP" class="headerlink" title="(一): 神经元模型MP"></a>(一): 神经元模型MP</h2><p>1943年，心理学家McCulloch和数学家Pitts参考了生物神经元的结构，发表了抽象的神经元模型MP。</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5nyhu64yj20ku0c53yx.jpg" alt="MP模型.png" style="zoom:67%;" />



<p>神经元模型是一个包含输入，输出与计算功能的模型。</p>
<p>连接是神经元中最重要的东西。每一个连接上都有一个权重。在神经元模型里，每个有向箭头表示的是值的加权传递。</p>
<p>一个神经网络的训练算法就是让权重的值调整到最佳，以使得整个网络的预测效果最好。</p>
<p><strong>神经元的计算</strong></p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5nyymumxj20of0d1aai.jpg" alt="神经元计算.png" style="zoom:67%;" />



<p>可见z是在输入和权值的线性加权和叠加了一个<strong>函数g</strong>的值。在MP模型里，函数g是sgn函数，也就是取符号函数。这个函数当输入大于0时，输出1，否则输出0。</p>
<p>MP模型中，权重的值都是预先设置的，因此不能学习。</p>
<h2 id="二-单层神经网络"><a href="#二-单层神经网络" class="headerlink" title="(二):单层神经网络"></a>(二):单层神经网络</h2><p>1958年，计算科学家Rosenblatt提出了由两层神经元组成的神经网络。他给它起了一个名字–“感知器”（Perceptron）</p>
<p>在“感知器”中，有两个层次。分别是输入层和输出层。输入层里的“输入单元”只负责传输数据，不做计算。输出层里的“输出单元”则需要对前面一层的输入进行计算。</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5nzdqs3yj20oy0h33zg.jpg" alt="单层神经网络.png" style="zoom:67%;" />

<p>与神经元模型不同，感知器中的权值是通过训练得到的。因此，根据以前的知识我们知道，感知器类似一个<strong>逻辑回归</strong>模型，可以做线性分类任务。</p>
<h2 id="三-两层神经网络"><a href="#三-两层神经网络" class="headerlink" title="(三): 两层神经网络"></a>(三): 两层神经网络</h2><p>两层神经网络除了包含一个输入层，一个输出层以外，还增加了一个中间层。此时，中间层和输出层都是计算层。我们扩展上节的单层神经网络，在右边新加一个层次（只含有一个节点）。</p>
<p><strong>两层神经网络(中间层计算)</strong></p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5o05m8nhj20ll0eujse.jpg" alt="两层神经网络(中间层计算).png" style="zoom:67%;" />



<p><strong>两层神经网络（输出层计算）</strong></p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5o0j6e0jj20k30dj0td.jpg" alt="两层神经网络（输出层计算）.png" style="zoom:67%;" />







<p>在神经网络的每个层次中，除了输出层以外，都会含有这样一个偏置单元。正如线性回归模型与逻辑回归模型中的一样。</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5o0v3kcxj20j20mn3zt.jpg" alt="两层神经网络（考虑偏置节点）.png" style="zoom:67%;" />





<p>在两层神经网络中，我们不再使用sgn函数作为函数g，而是使用平滑函数sigmoid作为函数g。我们把函数g也称作<strong>激活函数（active function）</strong>。</p>
<p>面对复杂的非线性分类任务，两层（带一个隐藏层）神经网络可以分类的很好。</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5o1axdqfj20gm0g8q3r.jpg" alt="两层神经网络（决策分界）.png" style="zoom:67%;" />

<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5o1k8qjvj20gm0g8aer.jpg" alt="两层神经网络（空间变换）.png" style="zoom:67%;" />

<p>可以看到，输出层的决策分界仍然是直线。关键就是，从输入层到隐藏层时，数据发生了空间变换。也就是说，两层神经网络中，隐藏层对原始的数据进行了一个空间变换，使其可以被线性分类，然后输出层的决策分界划出了一个线性分类分界线，对其进行分类。</p>
<p>矩阵和向量相乘，本质上就是对向量的坐标空间进行一个变换。因此，隐藏层的参数矩阵的作用就是使得数据的原始坐标空间从线性不可分，转换成了线性可分。</p>
<p>在设计一个神经网络时，输入层的节点数需要与特征的维度匹配，输出层的节点数要与目标的维度匹配。而中间层的节点数，却是由设计者指定的。</p>
<p>如何决定这个自由层的节点数呢？目前业界没有完善的理论来指导这个决策。一般是根据经验来设置。较好的方法就是预先设定几个可选值，通过切换这几个值来看整个模型的预测效果，选择效果最好的值作为最终选择。这种方法又叫做Grid Search（网格搜索）。</p>
<p>机器学习模型训练的目的，就是使得参数尽可能的与真实的模型逼近。这就引出我们的损失函数</p>
<p>如何优化参数，能够让损失函数的值最小?</p>
<p>一般来说解决这个优化问题使用的是<strong>梯度下降</strong>算法。梯度下降算法每次计算参数在当前的梯度，然后让参数向着梯度的反方向前进一段距离，不断重复，直到梯度接近零时截止。一般这个时候，所有的参数恰好达到使损失函数达到一个最低值的状态。</p>
<p>在神经网络模型中，由于结构复杂，每次计算梯度的代价很大。因此还需要使用<strong>反向传播</strong>算法。反向传播算法是利用了神经网络的结构进行的计算。不一次计算所有参数的梯度，而是从后往前。首先计算输出层的梯度，然后是第二个参数矩阵的梯度，接着是中间层的梯度，再然后是第一个参数矩阵的梯度，最后是输入层的梯度。计算结束以后，所要的两个参数矩阵的梯度就都有了。</p>
<p><strong>反向传播算法</strong></p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5o1zjqfhj20j20ib755.jpg" alt="反向传播算法.png" style="zoom:67%;" />









<h2 id="四-多层神经网络-深度神经网络DNN"><a href="#四-多层神经网络-深度神经网络DNN" class="headerlink" title="(四): 多层神经网络(深度神经网络DNN)"></a>(四): 多层神经网络(深度神经网络DNN)</h2><p>在两层神经网络的输出层后面，继续添加层次。原来的输出层变成中间层，新加的层次成为新的输出层。所以可以得到下图。</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5o2dmthmj20r20hl0u3.jpg" alt="多层神经网络.png" style="zoom:67%;" />



<p>多层神经网络中，输出也是按照一层一层的方式来计算。从最外面的层开始，算出所有单元的值以后，再继续计算更深一层。只有当前层所有单元的值都计算完毕以后，才会算下一层。有点像计算向前不断推进的感觉。所以这个过程叫做“正向传播”。</p>
<p>多层神经网络中的参数</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5o2t1id9j20ub0o1tbg.jpg" alt="多层神经网络（较多参数）.png" style="zoom:50%;" />

<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5o31lx43j20xf0m9mzu.jpg" alt="多层神经网络（更深的层次）.png" style="zoom:50%;" />

<p>虽然参数数量仍然是33，但却有4个中间层，是原来层数的接近两倍。这意味着一样的参数数量，可以用更深的层次去表达。</p>
<p>与两层层神经网络不同。多层神经网络中的层数增加了很多。</p>
<p>增加更多的层次有什么好处？<strong>更深入的表示特征，以及更强的函数模拟能力。</strong></p>
<p>更深入的表示特征可以这样理解，随着网络的层数增加，每一层对于前一层次的抽象表示更深入。在神经网络中，每一层神经元学习到的是前一层神经元值的更抽象的表示。例如第一个隐藏层学习到的是“边缘”的特征，第二个隐藏层学习到的是由“边缘”组成的“形状”的特征，第三个隐藏层学习到的是由“形状”组成的“图案”的特征，最后的隐藏层学习到的是由“图案”组成的“目标”的特征。通过抽取更抽象的特征来对事物进行区分，从而获得更好的区分与分类能力。</p>
<p><strong>通过研究发现，在参数数量一样的情况下，更深的网络往往具有比浅层的网络更好的识别效率。</strong></p>
<p>在单层神经网络时，我们使用的激活函数是sgn函数。到了两层神经网络时，我们使用的最多的是sigmoid函数。而到了多层神经网络时，通过一系列的研究发现，ReLU函数在训练多层神经网络时，更容易收敛，并且预测性能更好。</p>
<p>三起三落的神经网络</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5o3i09agj21in0tpjvk.jpg" alt="三起三落的神经网络.png" style="zoom:67%;" />







<p>从单层神经网络，到两层神经网络，再到多层神经网络，下图说明了，随着网络层数的增加，以及激活函数的调整，神经网络所能拟合的决策分界平面的能力。</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5o3wu4scj21go0yzdjx.jpg" alt="表示能力不断增强.png" style="zoom:67%;" />







<p><strong>神经网络的类别</strong></p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5o47x2bhj21en0mfgo1.jpg" alt="神经网络的类别.png" style="zoom:67%;" />]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>DNN</tag>
      </tags>
  </entry>
  <entry>
    <title>特征工程</title>
    <url>/2019/07/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>对于一个机器学习问题，数据和特征往往决定了结果的上限，而模型、算法的选择及优化则是在逐步接近这个上限。</strong></p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5n26elowj20ob0qvq5i.jpg" alt="特征工程.jpg" style="zoom: 67%;" />



<p><strong>特征工程是利用数据领域的相关知识来创建能够使机器学习算法达到最佳性能的特征的过程。</strong> </p>
<h1 id="特征工程的重要性"><a href="#特征工程的重要性" class="headerlink" title="特征工程的重要性:"></a>特征工程的重要性:</h1><p><strong>（1）特征越好，灵活性越强</strong></p>
<p>好特征的灵活性在于它允许你选择不复杂的模型，同时运行速度也更快，也更容易理解和维护。</p>
<p><strong>（2）特征越好，构建的模型越简单</strong></p>
<p>有了好的特征，即便你的参数不是最优的，你的模型性能也能仍然会表现的很nice</p>
<p><strong>（3）特征越好，模型的性能越出色</strong></p>
<p>我们进行特征工程的最终目的就是提升模型的性能。</p>
<br>





<h1 id="一-数据预处理"><a href="#一-数据预处理" class="headerlink" title="一: 数据预处理"></a>一: 数据预处理</h1><h2 id="1-数值型数据—特征归一化-无量纲化"><a href="#1-数值型数据—特征归一化-无量纲化" class="headerlink" title="1: 数值型数据—特征归一化(无量纲化)"></a>1: 数值型数据—特征归一化(无量纲化)</h2><p>为了消除数据特征之间的量纲影响，我们需要对特征进行归一化处理，使得不同指标之间具有可比性; 对数值类型的特征做归一化可以将所有的特征都统一到一个大致相同的数值区间内.</p>
<p>例如，分析一个人的身高和体重对健康的影响，如果使用米（m）和千克（kg）作为单位，那么身高特征会在1.6～1.8m的数值范围内，体重特征会在50～100kg的范围内，分析出来的结果显然会倾向于数值差别比较大的体重特征。想要得到更为准确的结果，就需要进行特征归一化（Normalization）处理，使各指标处于同一数值量级，以便进行分析。</p>
<h3 id="1-线性函数归一化-0-1标准化"><a href="#1-线性函数归一化-0-1标准化" class="headerlink" title="1): 线性函数归一化(0-1标准化)"></a>1): 线性函数归一化(0-1标准化)</h3><p><strong>公式如下:</strong><br>$$<br>X_{norm} = \frac{X - X_{min}}{X_{max}-X_{min}}<br>$$<br>它对原始数据进行线性变换，使结果映射到[0, 1]的范围，实现对原始数据的等比缩放。</p>
<p><strong>代码实现:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line"><span class="comment">#区间缩放，返回值为缩放到[0, 1]区间的数据</span></span><br><span class="line">MinMaxScaler().fit_transform(iris.data)</span><br></pre></td></tr></table></figure>





<h3 id="2-零-均值标准化"><a href="#2-零-均值标准化" class="headerlink" title="2): 零 - 均值标准化"></a>2): 零 - 均值标准化</h3><p><strong>公式如下:</strong><br>$$<br>Z = \frac{x-\mu}{\sigma}<br>$$<br>它会将原始数据映射到均值为0、标准差为1的分布上。具体来说，假设原始特征的均值为μ、标准差为σ，那么归一化公式定义为上式</p>
<p><strong>代码实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"> </span><br><span class="line"><span class="comment">#标准化，返回值为标准化后的数据</span></span><br><span class="line">StandardScaler().fit_transform(iris.data)</span><br></pre></td></tr></table></figure>





<h3 id="3-Normalizer归一化-L1-L2范数标准化"><a href="#3-Normalizer归一化-L1-L2范数标准化" class="headerlink" title="3): Normalizer归一化(L1/L2范数标准化)"></a>3): Normalizer归一化(L1/L2范数标准化)</h3><p><strong>公式如下:</strong><br>$$<br>x^{‘}= \frac{x}{\sqrt{\sum_j^mx_j^2}}<br>$$<br>x表示当前特征, $x_j$ 表示x的第J个特征</p>
<p>L1/L2范数标准化：如果我们只是为了统一量纲，那么通过L2范数整体标准化也是可以的，具体方法是求出每个样本特征向量$\vec x$的L2范数$||\vec x||_2$，然后用$\vec x/||\vec x||_2$。代替原样本特征即可。当然L1范数标准化也是可以的，即用$\vec x/||\vec x||_1$，代替原样本特征。通常情况下，范数标准化首选L2范数标准化。在sklearn中，我们可以用Normalizer来做L1/L2范数标准化。</p>
<p><strong>代码实现:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Normalizer</span><br><span class="line"></span><br><span class="line"><span class="comment">#归一化，返回值为归一化后的数据</span></span><br><span class="line">Normalizer().fit_transform(iris.data)</span><br></pre></td></tr></table></figure>







<h2 id="2-类别型数据—离散数据-虚拟变量-哑变量"><a href="#2-类别型数据—离散数据-虚拟变量-哑变量" class="headerlink" title="2: 类别型数据—离散数据, 虚拟变量, 哑变量"></a>2: 类别型数据—离散数据, 虚拟变量, 哑变量</h2><p>类别型特征（Categorical Feature）主要是指性别（男、女）、血型（A、B、AB、O）等只在有限选项内取值的特征。类别型特征原始输入通常是字符串形式，除了决策树等少数模型能直接处理字符串形式的输入，对于逻辑回归、支持向量机等模型来说，类别型特征必须经过处理转换成数值型特征才能正确工作。</p>
<h3 id="1-独热编码-one-hot"><a href="#1-独热编码-one-hot" class="headerlink" title="1): 独热编码(one-hot)"></a>1): 独热编码(one-hot)</h3><p><strong>独热编码通常用于处理类别间不具有大小关系的特征。</strong></p>
<p>例如血型，一共有4个取值（A型血、B型血、AB型血、O型血），独热编码会把血型变成一个4维稀疏向量，A型血表示为（1, 0, 0, 0），B型血表示为（0, 1, 0, 0），AB型表示为（0, 0,1, 0），O型血表示为（0, 0, 0, 1）。</p>
<p><strong>理解独热编码:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [[<span class="string">'自有房'</span>,<span class="number">40</span>,<span class="number">50000</span>],</span><br><span class="line">       [<span class="string">'无自有房'</span>,<span class="number">22</span>,<span class="number">13000</span>],</span><br><span class="line">       [<span class="string">'自有房'</span>,<span class="number">30</span>,<span class="number">30000</span>]]</span><br></pre></td></tr></table></figure>

<p>编码后的样本矩阵变为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">40</span>,<span class="number">50000</span>],</span><br><span class="line">        [<span class="number">0</span>,<span class="number">1</span>,<span class="number">22</span>,<span class="number">13000</span>],</span><br><span class="line">        [<span class="number">1</span>,<span class="number">0</span>,<span class="number">30</span>,<span class="number">30000</span>]]</span><br></pre></td></tr></table></figure>

<p>也就是说，<strong>一个属性如果有N个可取值，它就可以扩充为N个属性，每个样本的这N个属性中，只能有一个为1，表示该样本的该属性属于这个类别，其余扩展属性都为0。</strong></p>
<p>对于类别取值较多的情况下使用独热编码需要注意以下问题。</p>
<p>（1）使用稀疏向量来节省空间。</p>
<p>在独热编码下，特征向量只有某一维取值为1，其他位置取值均为0。因此可以利用向量的稀疏表示有效地节省空间，并且目前大部分的算法均接受稀疏向量形式的输入。</p>
<p>（2）配合特征选择来降低维度。</p>
<p>高维度特征会带来几方面的问题。一是在K近邻算法中，高维空间下两点之间的距离很难得到有效的衡量；二是在逻辑回归模型中，参数的数量会随着维度的增高而增加，容易引起过拟合问题；三是通常只有部分维度是对分类、预测有帮助，因此可以考虑配合特征选择来降低维度。</p>
<p><strong>代码实现:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"></span><br><span class="line"><span class="comment">#哑编码，对IRIS数据集的目标值，返回值为哑编码后的数据</span></span><br><span class="line">OneHotEncoder().fit_transform(iris.target.reshape((<span class="number">-1</span>,<span class="number">1</span>)))</span><br></pre></td></tr></table></figure>



<h3 id="2-序号编码-标签编码"><a href="#2-序号编码-标签编码" class="headerlink" title="2): 序号编码(标签编码)"></a>2): 序号编码(标签编码)</h3><p>序号编码通常用于处理类别间具有大小关系的数据。</p>
<p>例如成绩，可以分为低、中、高三档，并且存在“高&gt;中&gt;低”的排序关系。序号编码会按照大小关系对类别型特征赋予一个数值ID，例如高表示为3、中表示为2、低表示为1，转换后依然保留了大小关系.</p>
<p><strong>代码实现:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line">le = LabelEncoder()</span><br><span class="line">le.fit([<span class="number">1</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">100</span>])</span><br><span class="line">le.transform([<span class="number">1</span>,<span class="number">1</span>,<span class="number">100</span>,<span class="number">67</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出： array([0,0,3,2,1])</span></span><br></pre></td></tr></table></figure>





<h2 id="3-连续特征的离散化处理"><a href="#3-连续特征的离散化处理" class="headerlink" title="3:  连续特征的离散化处理"></a>3:  连续特征的离散化处理</h2><h3 id="1-定量特征二值化"><a href="#1-定量特征二值化" class="headerlink" title="1): 定量特征二值化"></a>1): 定量特征二值化</h3><p>定量特征二值化的核心在于设定一个阈值，大于阈值的赋值为1，小于等于阈值的赋值为0</p>
<p>比如我们根据连续值特征的分位数，将该特征分为高，中和低三个特征。将分位数从0<del>0.3的设置为低，0.3</del>0.7的设置为中，0.7~1的设置为高。</p>
<p><strong>代码实现:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Binarizer</span><br><span class="line"></span><br><span class="line"><span class="comment">#二值化，阈值设置为3，返回值为二值化后的数据</span></span><br><span class="line">Binarizer(threshold=<span class="number">3</span>).fit_transform(iris.data)</span><br></pre></td></tr></table></figure>





<h2 id="4-缺失值处理"><a href="#4-缺失值处理" class="headerlink" title="4: 缺失值处理"></a>4: 缺失值处理</h2><h3 id="1-填充"><a href="#1-填充" class="headerlink" title="1): 填充"></a>1): 填充</h3><p>①: 连续值：可以选择该特征值的所有样本的<strong>均值</strong>或<strong>中位数</strong>来填充缺失值</p>
<p>②: 离散值：选择该特征值的所有样本中<strong>最频繁出现的类别</strong>值来填充缺失值</p>
<p>注：不可信的样本丢掉，缺省值极多的字段考虑不用（即删掉）</p>
<p><strong>代码实现:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line">data=pandas.read_csv(<span class="string">'路径.csv'</span>)</span><br><span class="line"><span class="keyword">from</span> sclera.preprocessing <span class="keyword">import</span> Imputer</span><br><span class="line"><span class="comment">#'mean','median','most_frequent'</span></span><br><span class="line"></span><br><span class="line">imputer=Imputer(strategy=<span class="string">'mean'</span>)</span><br><span class="line">imputer.fit_transform(data[[<span class="string">'需填充列的列名'</span>]])</span><br></pre></td></tr></table></figure>



<h3 id="2-删除"><a href="#2-删除" class="headerlink" title="2): 删除"></a>2): 删除</h3><p>删除缺失行</p>
<h2 id="5-异常特征样本清洗"><a href="#5-异常特征样本清洗" class="headerlink" title="5:  异常特征样本清洗"></a>5:  异常特征样本清洗</h2><p>异常数据的清洗，目标是将原始数据中异常的数据清除。</p>
<p><strong>（1）偏差检测（  聚类（KMeans）和最近邻（KNN））</strong></p>
<p>比如我们可以用KMeans聚类将训练样本分成若干个簇，如果某一个簇里的样本数很少，而且簇质心和其他所有的簇都很远，那么这个簇里面的样本极有可能是异常特征样本了。我们可以将其从训练集过滤掉。</p>
<p><strong>（2）异常点检测（iForest，one class SVM）</strong></p>
<p>主要是使用iForest或者one class SVM，使用异常点检测的机器学习算法来过滤所有的异常点。</p>
<p><strong>（3）基于统计的异常点检测</strong></p>
<p>例如极差，四分位数间距，均差，标准差等，这种方法适合于挖掘单变量的数值型数据。全距(Range)，又称极差，是用来表示统计资料中的变异量数(measures of variation) ，其最大值与最小值之间的差距；四分位距通常是用来构建箱形图，以及对概率分布的简要图表概述。</p>
<p><strong>（4）基于距离的异常点检测</strong></p>
<p>主要通过距离方法来检测异常点，将数据集中与大多数点之间距离大于某个阈值的点视为异常点，主要使用的距离度量方法有绝对距离 ( 曼哈顿距离 ) 、欧氏距离和马氏距离等方法。</p>
<p><strong>（5）基于密度的异常点检测</strong></p>
<p>考察当前点的周围密度，可以发现局部异常点，例如LOF算法</p>
<br>



<h1 id="二-特征提取-降维"><a href="#二-特征提取-降维" class="headerlink" title="二: 特征提取(降维)"></a>二: 特征提取(降维)</h1><p>它的目的是自动地构建新的特征，将原始特征转换为一组具有明显物理意义（Gabor、几何特征[角点、不变量]、纹理[LBP HOG]）或者统计意义或核的特征。比如通过变换特征取值来减少原始数据中某个特征的取值个数等。对于表格数据，你可以在你设计的特征矩阵上使用主要成分分析（Principal Component Analysis，PCA)来进行特征提取从而创建新的特征。对于图像数据，可能还包括了线或边缘检测。</p>
<p><strong>主要的方法是线性映射和非线性映射方法两大类</strong></p>
<ul>
<li>线性映射方法的代表方法有：PCA（Principal Component Analysis），LDA（Discriminant Analysis）</li>
<li>非线性映射方法的代表方法有：核方法（KernelPCA）、流形学习（ISOMap，LLE）</li>
<li>非负矩阵分解（NMF）是在矩阵中所有元素均为非负数的约束条件之下的矩阵分解方法</li>
</ul>
<h2 id="1-PCA主成分分析降维"><a href="#1-PCA主成分分析降维" class="headerlink" title="1: PCA主成分分析降维"></a>1: PCA主成分分析降维</h2><p><strong>PCA是一个非监督学习的降维方法</strong></p>
<p>PCA顾名思义，就是找出数据里最主要的方面，用数据里最主要的方面来代替原始数据。具体的，假如我们的数据集是 $n$ 维的，共有  $m$ 个数据 $(x_1, x_2, …, x_m)$ 。我们希望将这 $m$ 个数据的维度从 $n$ 维降到 $n^{‘}$ 维，希望这 $m$  个  $n^{‘}$  维的数据集尽可能的代表原始数据集。我们知道数据从 $n$ 维降到 $n^{‘}$ 维肯定会有损失，但是我们希望损失尽可能的小。</p>
<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5n4d9g59j20h90cnjui.jpg" alt="pca.png"></p>
<p> <strong>PCA算法流程</strong></p>
<p>可以看出，求样本 <img src="https://www.zhihu.com/equation?tex=x_i" alt="[公式]"> 的 <img src="https://www.zhihu.com/equation?tex=n%27" alt="[公式]"> 维的主成分其实就是求样本集的协方差矩阵 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7Bm%7DXX%5E%5Ctop" alt="[公式]"> 的前 <img src="https://www.zhihu.com/equation?tex=n%27" alt="[公式]"> 个特征值对应特征向量矩阵 <img src="https://www.zhihu.com/equation?tex=P" alt="[公式]"> ，然后对于每个样本 <img src="https://www.zhihu.com/equation?tex=x_i" alt="[公式]"> ,做如下变换 <img src="https://www.zhihu.com/equation?tex=y_i%3DPx_i" alt="[公式]"> ，即达到降维的PCA目的。</p>
<p>下面我们看看具体的算法流程：</p>
<p>输入： <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]"> 维样本集 <img src="https://www.zhihu.com/equation?tex=X%3D%28x_1%2Cx_2%2C...%2Cx_m%29" alt="[公式]"> ，要降维到的维数 <img src="https://www.zhihu.com/equation?tex=n%27" alt="[公式]"> .</p>
<p>输出：降维后的样本集 <img src="https://www.zhihu.com/equation?tex=Y" alt="[公式]"></p>
<p>1.对所有的样本进行中心化 <img src="https://www.zhihu.com/equation?tex=x_i%3Dx_i-%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bj%3D1%7D%5E%7Bm%7Dx_j" alt="[公式]"></p>
<p>2.计算样本的协方差矩阵<img src="https://www.zhihu.com/equation?tex=C%3D%5Cfrac%7B1%7D%7Bm%7DXX%5E%5Cmathsf%7BT%7D" alt="[公式]"></p>
<p>3.求出协方差矩阵的特征值及对应的特征向量</p>
<p>4.将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P</p>
<p>5.Y=PX即为降维到k维后的数据</p>
<p>这里对PCA算法做一个总结。作为一个非监督学习的降维方法，它只需要特征值分解，就可以对数据进行压缩，去噪。因此在实际场景应用很广泛。为了克服PCA的一些缺点，出现了很多PCA的变种，比如为解决非线性降维的KPCA，还有解决内存限制的增量PCA方法Incremental PCA，以及解决稀疏数据降维的PCA方法Sparse PCA等。</p>
<p><strong>PCA算法的主要优点有：</strong></p>
<ul>
<li>仅仅需要以方差衡量信息量，不受数据集以外的因素影响。　</li>
<li>各主成分之间正交，可消除原始数据成分间的相互影响的因素。</li>
<li>计算方法简单，主要运算是特征值分解，易于实现。</li>
</ul>
<p><strong>PCA算法的主要缺点有：</strong></p>
<ul>
<li>主成分各个特征维度的含义具有一定的模糊性，不如原始样本特征的解释性强。</li>
<li>方差小的非主成分也可能含有对样本差异的重要信息，因降维丢弃可能对后续数据处理有影响。</li>
</ul>
<p><a href="https://www.zhihu.com/people/wang-he-13-93" target="_blank" rel="noopener">PCA主成分分析学习总结 - 鱼遇雨欲语与余</a></p>
<h2 id="2-LDA线性判别分析降维"><a href="#2-LDA线性判别分析降维" class="headerlink" title="2: LDA线性判别分析降维"></a>2: LDA线性判别分析降维</h2><p>LDA是一种监督学习的降维技术，也就是说它的数据集的每个样本是有类别输出的。LDA的基本思想：给定训练样例集，设法将样例投影到一条直线上，使得同类样例的投影点尽可能接近、异类样例的投影点中心尽可能远离。更简单的概括为一句话，就是<strong>“投影后类内方差最小，类间方差最大”</strong>。</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5n4rvam0j20go0bqwfj.jpg" alt="LDA降维.png" style="zoom:67%;" />



<p> <strong>PCA和LDA</strong></p>
<p>PCA（主成分分析）和LDA（线性判别分析）有很多的相似点，其本质是要将初始样本映射到维度更低的样本空间中，但是PCA和LDA的映射目标不一样：PCA是为了让映射后的样本具有最大的发散性；而LDA是为了让映射后的样本有最好的分类性能。所以说PCA是一种无监督的降维方法，而LDA是一种有监督的降维方法。</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5n569ikjj21240el7if.jpg" alt="PCA和LDA.jpg" style="zoom:67%;" />





<p> <strong>小结</strong></p>
<p>LDA算法既可以用来降维，又可以用来分类，但是目前来说，主要还是用于降维。在我们进行图像识别图像识别相关的数据分析时，LDA是一个有力的工具。下面总结下LDA算法的优缺点。</p>
<p>　<strong>LDA算法的主要优点有：</strong></p>
<ul>
<li>在降维过程中可以使用类别的先验知识经验，而像PCA这样的无监督学习则无法使用类别先验知识。</li>
<li>LDA在样本分类信息依赖均值而不是方差的时候，比PCA之类的算法较优。</li>
</ul>
<p>　<strong>LDA算法的主要缺点有：</strong></p>
<ul>
<li>LDA不适合对非高斯分布样本进行降维，PCA也有这个问题。</li>
<li>LDA降维最多降到类别数k-1的维数，如果我们降维的维度大于k-1，则不能使用LDA。当然目前有一些LDA的进化版算法可以绕过这个问题。</li>
<li>LDA在样本分类信息依赖方差而不是均值的时候，降维效果不好。</li>
<li>LDA可能过度拟合数据。</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/32658341" target="_blank" rel="noopener"> LDA线性判别分析 - 鱼遇雨欲语与余</a></p>
<h2 id="3-NMF非负矩阵分解"><a href="#3-NMF非负矩阵分解" class="headerlink" title="3: NMF非负矩阵分解"></a>3: NMF非负矩阵分解</h2><p>NMF的基本思想可以简单描述为：对于任意给定的一个非负矩阵V，NMF算法能够寻找到一个非负矩阵W和一个非负矩阵H，使得满足 ，从而将一个非负的矩阵分解为左右两个非负矩阵的乘积。如下图所示，其中要求分解后的矩阵H和W都必须是非负矩阵。</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5n5kdz2ej20gs06t3ym.jpg" alt="NMF.png" style="zoom:67%;" />



<p>矩阵V分解为左矩阵W和右矩阵H，可理解为原始矩阵V的列向量是H中的所有列向量的加权和，对应的权重系数则是W的列向量的元素，所有H称为基矩阵，W称为系数矩阵。</p>
<p><a href="https://zhuanlan.zhihu.com/p/22043930" target="_blank" rel="noopener">非负矩阵分解(NMF)简介</a></p>
<h2 id="4-LLE局部线性嵌入降维法"><a href="#4-LLE局部线性嵌入降维法" class="headerlink" title="4: LLE局部线性嵌入降维法"></a>4: LLE局部线性嵌入降维法</h2><p>所谓LLE（局部线性嵌入）即”Locally Linear Embedding”的降维算法，在处理所谓流形降维的时候，效果比PCA要好很多。首先，所谓流形，我们脑海里最直观的印象就是Swiss roll,在吃它的时候喜欢把它整个摊开成一张饼再吃，其实这个过程就实现了对瑞士卷的降维操作，即从三维降到了两维。降维前，我们看到相邻的卷层之间看着距离很近，但其实摊开成饼状后才发现其实距离很远，所以如果不进行降维操作，而是直接根据近邻原则去判断相似性其实是不准确的。</p>
<p>和传统的PCA，LDA等<strong>关注样本方差</strong>的降维方法相比，LLE关注于降维时<strong>保持样本局部的线性特征（保持原有拓扑结构）</strong>，由于LLE在降维时保持了样本的局部特征，它广泛的用于图像识别，高维数据可视化等领域。<strong>LLE是非线性降维技术</strong>，可以说是流形学习方法最经典的算法之一。很多后续的流形学习、降维方法都与LLE有密切联系。</p>
<p>LLE的降维实现过程，直观的可视化效果如下图所示</p>
<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5n5wo4pmj20ae07waag.jpg" alt="LLE4.jpg"></p>
<p>LLE算法认为每一个数据点都可以由其近邻点的线性加权组合构造得到，LLE算法主要步骤：</p>
<ul>
<li>寻找每个样本点的k个近邻点；</li>
<li>由每个样本点的近邻点计算出该样本点的局部重建权值矩阵；</li>
<li>由该样本点的局部重建权值矩阵和其近邻点计算出该样本点的输出值。</li>
</ul>
<p>LLE算法示例：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"># 降维，高维数据降成低维的数据</span><br><span class="line"># manifold 流形</span><br><span class="line"><span class="keyword">from</span> sklearn.manifold <span class="keyword">import</span> LocallyLinearEmbedding</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d.axes3d <span class="keyword">import</span> Axes3D</span><br><span class="line">X,t = datasets.make_swiss_roll(n_samples=<span class="number">1500</span>,noise=<span class="number">0.05</span>)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">axes3D = Axes3D(fig)</span><br><span class="line">axes3D.view_init(<span class="number">7</span>,<span class="number">-80</span>)</span><br><span class="line">axes3D.scatter(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],X[:,<span class="number">2</span>],c = t)</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5n6bqed6j20gj0b20wd.jpg" alt="LLE5.jpg" style="zoom:67%;" />

<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pca</span> = <span class="keyword">PCA</span>(n_components= 2)</span><br><span class="line">X_pca = <span class="keyword">pca</span>.fit_transform(X)</span><br><span class="line">plt.<span class="keyword">scatter</span>(X_pca[:,0],X_pca[:,1],c = t)</span><br><span class="line"><span class="keyword">Copy</span></span><br></pre></td></tr></table></figure>

<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5n7g7i3xj20gx0az75v.jpg" alt="LLE7.jpg" style="zoom:67%;" />

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">lle = LocallyLinearEmbedding(n_neighbors=<span class="number">10</span>,n_components=<span class="number">2</span>)</span><br><span class="line">lle.fit(X)</span><br><span class="line">X_lle = lle.transform(X)</span><br><span class="line">plt.scatter(X_lle[:,<span class="number">0</span>],X_lle[:,<span class="number">1</span>],c = t)</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5n7ssl9bj20hu0aoac5.jpg" alt="LLE6.jpg" style="zoom:67%;" />









<h1 id="三-特征选择"><a href="#三-特征选择" class="headerlink" title="三: 特征选择"></a>三: 特征选择</h1><p><a href="https://zhuanlan.zhihu.com/p/32749489" target="_blank" rel="noopener">特征选择 - 鱼遇雨欲语与余</a></p>
<p>当数据预处理完成后，我们需要选择有意义的特征输入机器学习的算法和模型进行训练。通常来说，从两个方面考虑来选择特征：</p>
<ul>
<li><strong>特征是否发散：</strong>如果一个特征不发散，例如方差接近于0，也就是说样本在这个特征上基本上没有差异，这个特征对于样本的区分并没有什么用。</li>
<li><strong>特征与目标的相关性：</strong>这点比较显见，与目标相关性高的特征，应当优选选择。除方差法外，本文介绍的其他方法均从相关性考虑。</li>
</ul>
<p><strong>特征选择过程一般包括产生过程，评价函数，停止准则，验证过程，这4个部分。</strong></p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5n8w1o9mj20i9073749.jpg" alt="特征选择流程.png" style="zoom: 80%;" />

<p>(1) 产生过程( Generation Procedure )：产生过程是搜索特征子集的过程，负责为评价函数提供特征子集。</p>
<p>(2) 评价函数( Evaluation Function )：评价函数是评价一个特征子集好坏程度的一个准则。</p>
<p>(3) 停止准则( Stopping Criterion )：停止准则是与评价函数相关的，一般是一个阈值，当评价函数值达到这个阈值后就可停止搜索。</p>
<p>(4) 验证过程( Validation Procedure ) ：在验证数据集上验证选出来的特征子集的有效性。</p>
<p><strong>根据特征选择的形式可以将特征选择方法分为3种：</strong></p>
<ul>
<li><p>Filter：过滤法，按照发散性或者相关性对各个特征进行评分，设定阈值或者待选择阈值的个数，选择特征。</p>
<ul>
<li>它主要侧重于单个特征跟目标变量的相关性。</li>
<li><strong>优点</strong>是计算时间上较高效,对于过拟合问题也具有较高的鲁棒性。</li>
<li><strong>缺点</strong>就是倾向于选择冗余的特征,因为他们不考虑特征之间的相关性,有可能某一个特征的分类能力很差，但是它和某些其它特征组合起来会得到不错的效果。</li>
<li></li>
</ul>
</li>
<li><p>Wrapper：包装法，根据目标函数（通常是预测效果评分），每次选择若干特征，或者排除若干特征。</p>
<ul>
<li>封装器用选取的特征子集对样本集进行分类，分类的精度作为衡量特征子集好坏的标准,经过比较选出最好的特征子集。常用的有逐步回归（Stepwise regression）、向前选择（Forward selection）和向后选择（Backward selection）。</li>
<li><strong>优点</strong>是考虑了特征与特征之间的关联性，</li>
<li><strong>缺点</strong>是当观测数据较少时容易过拟合，而当特征数量较多时,计算时间又会增长</li>
</ul>
</li>
</ul>
<ul>
<li>Embedded：集成法，先使用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据系数从大到小选择特征。类似于Filter方法，但是是通过训练来确定特征的优劣。<ul>
<li>有时候会用Random Forest和Gradient boosting做特征选择，本质上都是基于决策树来做的特征选择，只是细节上有些区别。</li>
</ul>
</li>
</ul>
<h2 id="1-Filter过滤法-刷选器"><a href="#1-Filter过滤法-刷选器" class="headerlink" title="1: Filter过滤法(刷选器)"></a>1: Filter过滤法(刷选器)</h2><p>它按照特征的发散性或者相关性指标对各个特征进行评分，设定评分阈值或者待选择阈值的个数，选择合适的特征。</p>
<h3 id="1-方差选择法"><a href="#1-方差选择法" class="headerlink" title="(1): 方差选择法"></a>(1): 方差选择法</h3><p><strong>使用方差选择法，先要计算各个特征的方差，然后根据阈值，选择方差大于阈值的特征。</strong>（方差越大的特征，那么我们可以认为它是比较有用的。如果方差较小，比如小于1，那么这个特征可能对我们的算法作用没有那么大。最极端的，如果某个特征方差为0，即所有的样本该特征的取值都是一样的，那么它对我们的模型训练没有任何作用，可以直接舍弃。在实际应用中，我们会指定一个方差的阈值，当方差小于这个阈值的特征会被我们筛掉。）</p>
<p><strong>代码实现:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> VarianceThreshold</span><br><span class="line"></span><br><span class="line"><span class="comment">#方差选择法，返回值为特征选择后的数据</span></span><br><span class="line"><span class="comment">#参数threshold为方差的阈值</span></span><br><span class="line">VarianceThreshold(threshold=<span class="number">3</span>).fit_transform(iris.data)</span><br></pre></td></tr></table></figure>



<h3 id="2-相关系数法"><a href="#2-相关系数法" class="headerlink" title="(2): 相关系数法"></a>(2): 相关系数法</h3><p>这个主要用于输出连续值的监督学习算法中。我们分别计算所有训练集中各个特征与输出值之间的相关系数，设定一个阈值，选择相关系数较大的部分特征。<strong>即使用相关系数法，先要计算各个特征对目标值的相关系数以及相关系数的P值。</strong></p>
<p><strong>代码实现:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> pearsonr</span><br><span class="line"></span><br><span class="line"><span class="comment">#选择K个最好的特征，返回选择特征后的数据</span></span><br><span class="line"><span class="comment">#第一个参数为计算评估特征是否好的函数，该函数输入特征矩阵和目标向量，输出二元组（评分，P值）的数组，数组第i项为第i个特征的评分和P值。在此定义为计算相关系数</span></span><br><span class="line"><span class="comment">#参数k为选择的特征个数</span></span><br><span class="line">SelectKBest(<span class="keyword">lambda</span> X, Y: array(map(<span class="keyword">lambda</span> x:pearsonr(x, Y), X.T)).T, k=<span class="number">2</span>).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure>



<h3 id="3-假设检验法（卡方检验、F检验、t检验）"><a href="#3-假设检验法（卡方检验、F检验、t检验）" class="headerlink" title="(3): 假设检验法（卡方检验、F检验、t检验）"></a>(3): 假设检验法（卡方检验、F检验、t检验）</h3><p>卡方检验可以检验某个特征分布和输出值分布之间的相关性。</p>
<p>经典的卡方检验是检验定性自变量对定性因变量的相关性。假设自变量有N种取值，因变量有M种取值，考虑自变量等于i且因变量等于j的样本频数的观察值与期望的差距。</p>
<p>我们还可以使用F检验和t检验，它们都是使用假设检验的方法，只是使用的统计分布不是卡方分布，而是F分布和t分布而已。</p>
<p><strong>代码实现:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</span><br><span class="line"></span><br><span class="line"><span class="comment">#选择K个最好的特征，返回选择特征后的数据</span></span><br><span class="line">SelectKBest(chi2, k=<span class="number">2</span>).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure>



<h3 id="4-互信息"><a href="#4-互信息" class="headerlink" title="(4): 互信息"></a>(4): 互信息</h3><p>即从信息熵的角度分析各个特征和输出值之间的关系评分。在决策树算法中我们讲到过互信息（信息增益）。互信息值越大，说明该特征和输出值之间的相关性越大。</p>
<p>经典的互信息也是评价定性自变量对定性因变量的相关性。</p>
<p><strong>代码实现:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"> <span class="keyword">from</span> minepy <span class="keyword">import</span> MINE</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#由于MINE的设计不是函数式的，定义mic方法将其为函数式的，返回一个二元组，二元组的第2项设置成固定的P值0.5</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">mic</span><span class="params">(x, y)</span>:</span></span><br><span class="line">     m = MINE()</span><br><span class="line">     m.compute_score(x, y)</span><br><span class="line">     <span class="keyword">return</span> (m.mic(), <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#选择K个最好的特征，返回特征选择后的数据</span></span><br><span class="line">SelectKBest(<span class="keyword">lambda</span> X, Y: array(map(<span class="keyword">lambda</span> x:mic(x, Y), X.T)).T, k=<span class="number">2</span>).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure>





<h2 id="2-Wrapper包装法-封装器"><a href="#2-Wrapper包装法-封装器" class="headerlink" title="2: Wrapper包装法(封装器)"></a>2: Wrapper包装法(封装器)</h2><p>根据目标函数，通常是预测效果评分，每次选择部分特征，或者排除部分特征。</p>
<h3 id="1-递归消除特征算法"><a href="#1-递归消除特征算法" class="headerlink" title="(1): 递归消除特征算法"></a>(1): 递归消除特征算法</h3><p>递归消除特征法使用一个机器学习模型来进行多轮训练，每轮训练后，消除若干权值系数的对应的特征，再基于新的特征集进行下一轮训练。</p>
<p><strong>代码实现:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> RFE</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line"><span class="comment">#递归特征消除法，返回特征选择后的数据</span></span><br><span class="line"><span class="comment">#参数estimator为基模型</span></span><br><span class="line"><span class="comment">#参数n_features_to_select为选择的特征个数</span></span><br><span class="line">RFE(estimator=LogisticRegression(), n_features_to_select=<span class="number">2</span>).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure>





<h2 id="3-Embedded集成法"><a href="#3-Embedded集成法" class="headerlink" title="3: Embedded集成法"></a>3: Embedded集成法</h2><p>先使用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据权值系数从大到小来选择特征。（类似于Filter方法，但是是通过训练来确定特征的优劣。）</p>
<h3 id="1-基于惩罚项的特征选择方法"><a href="#1-基于惩罚项的特征选择方法" class="headerlink" title="(1): 基于惩罚项的特征选择方法"></a>(1): 基于惩罚项的特征选择方法</h3><p>使用带惩罚项的基模型，除了筛选出特征外，同时也进行了降维。</p>
<p>最常用的是使用L1正则化和L2正则化来选择特征。正则化惩罚项越大，那么模型的系数就会越小。当正则化惩罚项大到一定的程度的时候，部分特征系数会变成0，当正则化惩罚项继续增大到一定程度时，所有的特征系数都会趋于0. 但是我们会发现一部分特征系数会更容易先变成0，这部分系数就是可以筛掉的。也就是说，我们选择特征系数较大的特征。常用的L1正则化和L2正则化来选择特征的基学习器是逻辑回归。（L1惩罚项降维的原理在于保留多个对目标值具有同等相关性的特征中的一个，所以没选到的特征不代表不重要。故，可结合L2惩罚项来优化。具体操作为：若一个特征在L1中的权值为1，选择在L2中权值差别不大且在L1中权值为0的特征构成同类集合，将这一集合中的特征平分L1中的权值，故需要构建一个新的逻辑回归模型）</p>
<p><strong>代码实现:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line"><span class="comment">#带L1惩罚项的逻辑回归作为基模型的特征选择</span></span><br><span class="line">SelectFromModel(LogisticRegression(penalty=<span class="string">"l1"</span>, C=<span class="number">0.1</span>)).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure>



<h3 id="2-基于树模型的特征选择法"><a href="#2-基于树模型的特征选择法" class="headerlink" title="(2): 基于树模型的特征选择法"></a>(2): 基于树模型的特征选择法</h3><p>可以使用决策树或者GBDT。一般来说，可以得到特征系数coef或者可以得到特征重要度(feature importances)的算法才可以做为嵌入法的基学习器。</p>
<p>树模型中GBDT也可用来作为基模型进行特征选择，使用feature_selection库的SelectFromModel类结合GBDT模型。</p>
<p><strong>代码实现:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment">#GBDT作为基模型的特征选择</span></span><br><span class="line">SelectFromModel(GradientBoostingClassifier()).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>特征工程</tag>
        <tag>特征选择</tag>
        <tag>特征提取（降维）</tag>
        <tag>主成成分分析</tag>
      </tags>
  </entry>
  <entry>
    <title>模型选择</title>
    <url>/2019/08/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<p><strong>模型选择:</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5ni7918tj21my10r7on.jpg" alt="模型选择.png"></p>
<p><strong>模型评估:</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5nil833sj21130fn40u.jpg" alt="模型选择和评估的方法.png"></p>
<h1 id="一-交叉验证-划分数据集"><a href="#一-交叉验证-划分数据集" class="headerlink" title="一: 交叉验证(划分数据集)"></a>一: 交叉验证(划分数据集)</h1><p>交叉验证，顾名思义，就是重复的使用数据，把得到的样本数据进行切分，组合为不同的训练集和测试集，用训练集来训练模型，用测试集来评估模型预测的好坏。在此基础上可以得到多组不同的训练集和测试集，某次训练集中的某样本在下次可能成为测试集中的样本，即所谓“交叉”。</p>
<p>那么什么时候才需要交叉验证呢？交叉验证用在数据不是很充足的时候。如果我们训练出的模型只在训练集上表现极好，但在未知的数据上效果很差，说明出现了过拟合，为了避免这种现象的出现，我们需要验证集来评估我们的模型。比如在我日常项目里面，对于普通适中问题，如果数据样本量小于一万条，我们就会采用交叉验证来训练优化选择模型。如果样本大于一万条的话，我们一般随机的把数据分成三份，一份为训练集（Training Set），一份为验证集（Validation Set），最后一份为测试集（Test Set）。用训练集来训练模型，用验证集来评估模型预测的好坏和选择模型及其对应的参数。把最终得到的模型再用于测试集，最终决定使用哪个模型以及对应参数。</p>
<p>当我们在训练集上训练好一个模型后，现在验证集上对模型进行，如果验证集上的效果比较好时，再到测试集上就行最后的评估。但是单纯的将数据集分为三部分，会大大减少模型学习的数据量（因为有时数据是很难获取的，数目可能会比较少），并且最后模型的效果也依赖于我们对于数据集的划分。这时我们就可以使用交叉验证，很好解决这个问题。</p>
<h2 id="1-简单交叉验证-随机交叉"><a href="#1-简单交叉验证-随机交叉" class="headerlink" title="1: 简单交叉验证(随机交叉)"></a>1: 简单交叉验证(随机交叉)</h2><p>我们随机的将样本数据分为两部分（比如： 70%的训练集，30%的测试集），然后用训练集来训练模型，在测试集上验证模型及参数。接着，我们再把样本打乱，重新选择训练集和测试集，继续训练数据和检验模型。最后我们选择损失函数评估最优的模型和参数。　</p>
<p>代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf = svm.SVC(kernel=<span class="string">'linear'</span>, C=<span class="number">1</span>)</span><br><span class="line">scores = cross_val_score(clf, iris.data, iris.target, cv=<span class="number">5</span>)  <span class="comment">#cv为迭代次数。</span></span><br><span class="line">print(scores)</span><br></pre></td></tr></table></figure>

<p>cross_val_score 默认使用 KFold 或 StratifiedKFold 策略</p>
<h2 id="2-K折交叉验证"><a href="#2-K折交叉验证" class="headerlink" title="2: K折交叉验证"></a>2: K折交叉验证</h2><p>将全部训练及S分成K个不相交的子集，假设S中样本个数为M，那么，每一个子集的训练样本个数为M/K相应的子集称做${S_{1},S_{2},…,S_{K}}$ 每次从分好的训练只集中拿出一个测试集。其他<code>K-1</code>一个作为训练集。在<code>K-1</code>一个训练集上训练出学习器模型，把这个模型放到测试集上，得到分类率.计算<code>K</code>求得分类率的平均值。作为该模型的真实分类率。</p>
<p><strong>优点</strong>：充分利用了所有样本</p>
<p><strong>缺点</strong>：计算繁琐。计算K次，测试K次</p>
<p><strong>代码:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">KFold_practice</span><span class="params">()</span>:</span></span><br><span class="line">    x = np.arange(<span class="number">12</span>)</span><br><span class="line">    X = x.reshape(<span class="number">6</span>, <span class="number">2</span>)</span><br><span class="line">    y = np.arange(<span class="number">15</span>, <span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">    kf = model_selection.KFold(n_splits=<span class="number">3</span>)  <span class="comment"># 定义一个K折分割器  还有参数shuffle，random_state</span></span><br><span class="line">    <span class="string">'KFold.split(x)返回的是索引，训练样本和测试样本是什么要将索引带到数据集中去'</span></span><br><span class="line">    <span class="keyword">for</span> train_index, test_index <span class="keyword">in</span> kf.split(X):</span><br><span class="line">        print(<span class="string">"TRAIN Index:"</span>, train_index,<span class="string">"TEST Index:"</span>, test_index)</span><br><span class="line"></span><br><span class="line">        X_train, X_test = X[train_index], X[test_index]</span><br><span class="line">        y_train, y_test = y[train_index], y[test_index]</span><br><span class="line">        print(<span class="string">"TRAIN Subset:\n"</span>, X_train)</span><br><span class="line">        print(<span class="string">"TEST Subset:\n"</span>, X_test)</span><br><span class="line">KFold_practice()</span><br></pre></td></tr></table></figure>



<h2 id="3-留一法"><a href="#3-留一法" class="headerlink" title="3: 留一法"></a>3: 留一法</h2><p>对于N个样本，每次选择N-1个样本来训练数据，留一个样本来验证模型预测的好坏。此方法主要用于样本量非常少的情况，比如对于普通适中问题，N小于50时，我一般采用留一交叉验证。</p>
<p><strong>留P法</strong></p>
<p>对于N个样本，每次选择N-P个样本来训练数据，留P个样本来验证模型预测的好坏。这样得到$C_{n}^{P}$个训练-测试集对（train-test pairs）</p>
<p><strong>代码:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leave_one_out</span><span class="params">()</span>:</span></span><br><span class="line">    x = np.arange(<span class="number">5</span>,<span class="number">13</span>)</span><br><span class="line">    X = x.reshape(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">    y = np.arange(<span class="number">15</span>, <span class="number">21</span>)</span><br><span class="line">    loo = model_selection.LeaveOneOut()</span><br><span class="line">    <span class="keyword">for</span> train_index,test_index <span class="keyword">in</span> loo.split(X):</span><br><span class="line">        print(<span class="string">"TRAIN INDEX:"</span>, train_index, <span class="string">"TEST INDEX:"</span>, test_index)</span><br><span class="line">        X_train, X_test = X[train_index], X[test_index]</span><br><span class="line">        <span class="comment"># y_train, y_test = y[train_index], y[test_index]</span></span><br><span class="line">        print(<span class="string">"TRAIN X:"</span>, X_train, <span class="string">"TEST X:"</span>, X_test)</span><br></pre></td></tr></table></figure>





<p>此外还有一种比较特殊的交叉验证方式，也是用于样本量少的时候。叫做<strong>自助法</strong>(bootstrapping)。比如我们有m个样本（m较小），每次在这m个样本中随机采集一个样本，放入训练集，采样完后把样本放回。这样重复采集m次，我们得到m个样本组成的训练集。当然，这m个样本中很有可能有重复的样本数据。同时，用没有被采样到的样本做测试集。这样接着进行交叉验证。由于我们的训练集有重复数据，这会改变数据的分布，因而训练结果会有估计偏差，因此，此种方法不是很常用，除非数据量真的很少，比如小于20个。</p>
<h1 id="二-超参数调优"><a href="#二-超参数调优" class="headerlink" title="二: 超参数调优"></a>二: 超参数调优</h1><h2 id="1-网格搜索-Grid-Search-GS"><a href="#1-网格搜索-Grid-Search-GS" class="headerlink" title="1: 网格搜索(Grid Search, GS)"></a>1: 网格搜索(Grid Search, GS)</h2><p>在每种参数组合下计算在N折交叉验证的每一折中计算训练集和测试集上的得分。</p>
<p>GridSearchCV(GridSearch和CV即网格搜索和交叉验证)可以保证在指定的参数范围内找到精度最高的参数，但是这也是网格搜索的缺陷所在，他要求遍历所有可能参数的组合，在面对大数据集和多参数的情况下，非常耗时。</p>
<p>Grid Search：也叫穷举搜索, 在所有候选的参数选择中，通过循环遍历，尝试每一种可能性，表现最好的参数就是最终的结果。</p>
<p>所以网格搜索适用于三四个（或者更少）的超参数（当超参数的数量增长时，网格搜索的计算复杂度会呈现指数增长，这时候则使用随机搜索）</p>
<p><strong>示例代码:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line">param_grid = [</span><br><span class="line">&#123;<span class="string">'n_estimators'</span>: [<span class="number">3</span>, <span class="number">10</span>, <span class="number">30</span>], <span class="string">'max_features'</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]&#125;,</span><br><span class="line">&#123;<span class="string">'bootstrap'</span>: [<span class="literal">False</span>], <span class="string">'n_estimators'</span>: [<span class="number">3</span>, <span class="number">10</span>], <span class="string">'max_features'</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;,</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">forest_reg = RandomForestRegressor()</span><br><span class="line">grid_search = GridSearchCV(forest_reg, param_grid, cv=<span class="number">5</span>,</span><br><span class="line">                          scoring=<span class="string">'neg_mean_squared_error'</span>)</span><br><span class="line"> </span><br><span class="line">grid_search.fit(housing_prepared, housing_labels)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>参见:</p>
<p><a href="https://www.cnblogs.com/wj-1314/p/10422159.html" target="_blank" rel="noopener">Python机器学习笔记：Grid SearchCV（网格搜索）</a></p>
<p><a href="https://blog.csdn.net/AIjiankeji/article/details/103106630" target="_blank" rel="noopener">网格搜索（GridSearch）及参数说明，实例演示</a></p>
</blockquote>
<h2 id="2-随机搜索-Random-Search-RS"><a href="#2-随机搜索-Random-Search-RS" class="headerlink" title="2: 随机搜索(Random Search,RS)"></a>2: 随机搜索(Random Search,RS)</h2><p>当超参数个数比较多的时候再用网格搜索进行参数调优就会比较耗时, 这时我们可以使用<strong>随机搜索</strong>的方法，随机在超参数空间中搜索几十几百个点，其中就有可能有比较小的值。这种做法比上面稀疏化网格的做法快，而且实验证明，随机搜索法结果比稀疏网格法稍好。</p>
<p><strong>随机搜索通过选择每一个超参数的一个随机值的特定数量的随机组合</strong></p>
<ul>
<li>如果你让随机搜索运行， 比如1000次，它会探索每个超参数的1000个不同的值（而不是像网格搜索那样，只搜索每个超参数的几个值）</li>
<li>你可以方便的通过设定搜索次数，控制超参数搜索的计算量。</li>
</ul>
<p>代码示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"><span class="keyword">from</span> sklearn.grid_search <span class="keyword">import</span> RandomizedSearchCV</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#导入训练数据</span></span><br><span class="line">traindata = pd.read_csv(<span class="string">"/traindata.txt"</span>,sep = <span class="string">','</span>)</span><br><span class="line">traindata = traindata.set_index(<span class="string">'instance_id'</span>)</span><br><span class="line">trainlabel = traindata[<span class="string">'is_trade'</span>]</span><br><span class="line"><span class="keyword">del</span> traindata[<span class="string">'is_trade'</span>]</span><br><span class="line">print(traindata.shape,trainlabel.shape)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#分类器使用 xgboost</span></span><br><span class="line">clf1 = xgb.XGBClassifier()</span><br><span class="line">  </span><br><span class="line"><span class="comment">#设定搜索的xgboost参数搜索范围，值搜索XGBoost的主要6个参数</span></span><br><span class="line">param_dist = &#123;</span><br><span class="line">        <span class="string">'n_estimators'</span>:range(<span class="number">80</span>,<span class="number">200</span>,<span class="number">4</span>),</span><br><span class="line">        <span class="string">'max_depth'</span>:range(<span class="number">2</span>,<span class="number">15</span>,<span class="number">1</span>),</span><br><span class="line">        <span class="string">'learning_rate'</span>:np.linspace(<span class="number">0.01</span>,<span class="number">2</span>,<span class="number">20</span>),</span><br><span class="line">        <span class="string">'subsample'</span>:np.linspace(<span class="number">0.7</span>,<span class="number">0.9</span>,<span class="number">20</span>),</span><br><span class="line">        <span class="string">'colsample_bytree'</span>:np.linspace(<span class="number">0.5</span>,<span class="number">0.98</span>,<span class="number">10</span>),</span><br><span class="line">        <span class="string">'min_child_weight'</span>:range(<span class="number">1</span>,<span class="number">9</span>,<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">#RandomizedSearchCV参数说明，clf1设置训练的学习器</span></span><br><span class="line"><span class="comment">#param_dist字典类型，放入参数搜索范围</span></span><br><span class="line"><span class="comment">#scoring = 'neg_log_loss'，精度评价方式设定为“neg_log_loss“</span></span><br><span class="line"><span class="comment">#n_iter=300，训练300次，数值越大，获得的参数精度越大，但是搜索时间越长</span></span><br><span class="line"><span class="comment">#n_jobs = -1，使用所有的CPU进行训练，默认为1，使用1个CPU</span></span><br><span class="line">grid = RandomizedSearchCV(clf1,param_dist,cv = <span class="number">3</span>,scoring = <span class="string">'neg_log_loss'</span>,n_iter=<span class="number">300</span>,n_jobs = <span class="number">-1</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">#在训练集上训练</span></span><br><span class="line">grid.fit(traindata.values,np.ravel(trainlabel.values))</span><br><span class="line"><span class="comment">#返回最优的训练器</span></span><br><span class="line">best_estimator = grid.best_estimator_</span><br><span class="line">print(best_estimator)</span><br><span class="line"><span class="comment">#输出最优训练器的精度</span></span><br><span class="line">print(grid.best_score_)</span><br></pre></td></tr></table></figure>







<p><strong>网格搜索&amp;随机搜索</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_20newsgroups</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">news = fetch_20newsgroups(subset=<span class="string">'all'</span>)</span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="comment">#取前3000条新闻文本进行数据分割</span></span><br><span class="line">X_train,X_test,y_train,y_test=train_test_split(news.data[:<span class="number">3000</span>],</span><br><span class="line">                                            news.target[:<span class="number">3000</span>],test_size=<span class="number">0.25</span>,random_state=<span class="number">33</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"><span class="comment">#*************导入pipeline*************</span></span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="comment">#使用Pipeline简化系统搭建流程，sklean提供的pipeline来将多个学习器组成流水线，通常流水线的形式为：</span></span><br><span class="line"><span class="comment">#将数据标准化的学习器---特征提取的学习器---执行预测的学习器</span></span><br><span class="line"><span class="comment">#将文本特征与分类器模型串联起来,[(),()]里有两个参数</span></span><br><span class="line"><span class="comment">#参数1:执行 vect = TfidfVectorizer(stop_words='english',analyzer='word')操作</span></span><br><span class="line"><span class="comment">#参数2:执行 svc = SVC()操作</span></span><br><span class="line">clf = Pipeline([(<span class="string">'vect'</span>,TfidfVectorizer(stop_words=<span class="string">'english'</span>,analyzer=<span class="string">'word'</span>)),(<span class="string">'svc'</span>,SVC())])</span><br><span class="line"> </span><br><span class="line"><span class="comment">#这里需要试验的2个超参数svc_gamma和svc_C的元素个数分别为4、3,这样我们一共有12种超参数对集合</span></span><br><span class="line"><span class="comment">#numpy.linspace用于创建等差数列，numpy.logspace用于创建等比数列</span></span><br><span class="line"><span class="comment">#logspace中，开始点和结束点是10的幂</span></span><br><span class="line"><span class="comment">#例如logspace(-2,1,4)表示起始数字为10^-2，结尾数字为10^1即10，元素个数为4的等比数列</span></span><br><span class="line"><span class="comment">#parameters变量里面的key都有一个前缀,这个前缀其实就是在Pipeline中定义的操作名。二者相结合，使我们的代码变得十分简洁。</span></span><br><span class="line"><span class="comment">#还有注意的是，这里对参数名是&lt;两条&gt;下划线 __</span></span><br><span class="line">parameters = &#123;<span class="string">'svc__gamma'</span>:np.logspace(<span class="number">-2</span>,<span class="number">1</span>,<span class="number">4</span>),<span class="string">'svc__C'</span>:np.logspace(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">3</span>)&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#从sklearn.grid_search中导入网格搜索模块GridSearchCV</span></span><br><span class="line"><span class="keyword">from</span> sklearn.grid_search <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="comment">#GridSearchCV参数解释:</span></span><br><span class="line"><span class="comment">#1.estimator : estimator(评估) object.</span></span><br><span class="line"><span class="comment">#2.param_grid : dict or list of dictionaries</span></span><br><span class="line"><span class="comment">#3.verbose:Controls the verbosity(冗余度): the higher, the more messages.</span></span><br><span class="line"><span class="comment">#4.refit:default=True, Refit(再次拟合)the best estimator with the entire dataset</span></span><br><span class="line"><span class="comment">#5.cv : int, cross-validation generator 此处表示3折交叉验证</span></span><br><span class="line">gs = GridSearchCV(clf,parameters,verbose=<span class="number">2</span>,refit=<span class="literal">True</span>,cv=<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#执行单线程网格搜索</span></span><br><span class="line">gs.fit(X_train,y_train)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> gs.best_params_,gs.best_score_</span><br><span class="line"> </span><br><span class="line"><span class="comment">#最后输出最佳模型在测试集上的准确性</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'the accuracy of best model in test set is'</span>,gs.score(X_test,y_test)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#小结：</span></span><br><span class="line"><span class="comment">#1.由输出结果可知，使用单线程的网格搜索技术 对朴素贝叶斯模型在文本分类任务中的超参数组合进行调优，</span></span><br><span class="line"><span class="comment">#  共有12组超参数组合*3折交叉验证 =36项独立运行的计算任务</span></span><br><span class="line"><span class="comment">#2.在本机上，该过程一共运行了2.9min，寻找到最佳的超参数组合在测试集上达到的分类准确性为82.27%</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>参见:</p>
<p><a href="https://www.cnblogs.com/wj-1314/p/10422159.html" target="_blank" rel="noopener">Python机器学习笔记：Grid SearchCV（网格搜索）</a></p>
</blockquote>
<h2 id="3-贝叶斯优化-Bayesian-Optimization-BO"><a href="#3-贝叶斯优化-Bayesian-Optimization-BO" class="headerlink" title="3: 贝叶斯优化(Bayesian Optimization,BO)"></a>3: 贝叶斯优化(Bayesian Optimization,BO)</h2><blockquote>
<p>参见:</p>
<p><a href="https://blog.csdn.net/u010159842/article/details/83030571" target="_blank" rel="noopener">贝叶斯优化: 一种更好的超参数调优方式</a></p>
<p><a href="https://www.cnblogs.com/yangruiGB2312/p/9374377.html" target="_blank" rel="noopener">强大而精致的机器学习调参方法：贝叶斯优化</a></p>
</blockquote>
<h1 id="三-模型评估"><a href="#三-模型评估" class="headerlink" title="三: 模型评估"></a>三: 模型评估</h1><blockquote>
<p>以下内容整理自:</p>
<p><a href="https://blog.csdn.net/qq_39751437/article/details/86258163" target="_blank" rel="noopener">机器学习的模型评估(使用sklearn工具)</a></p>
</blockquote>
<h2 id="1-分类模型评估方法"><a href="#1-分类模型评估方法" class="headerlink" title="1: 分类模型评估方法"></a>1: 分类模型评估方法</h2><h3 id="1-混淆矩阵-confusion-matrix"><a href="#1-混淆矩阵-confusion-matrix" class="headerlink" title="(1): 混淆矩阵(confusion_matrix)"></a>(1): 混淆矩阵(confusion_matrix)</h3><p>如果我们用的是个二分类的模型，那么把预测情况与实际情况的所有结果两两混合，结果就会出现以下4种情况，就组成了混淆矩阵。</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5njivqgyj20e707gjrr.jpg" alt="混淆矩阵.png" style="zoom:67%;" />

<p>由于1和0是数字，阅读性不好，所以我们分别用P和N表示1和0两种结果。变换之后为PP，PN，NP，NN，阅读性也很差，我并不能轻易地看出来预测的正确性与否。因此，为了能够更清楚地分辨各种预测情况是否正确，我们将其中一个符号修改为T和F，以便于分辨出结果。</p>
<img src="http://ww1.sinaimg.cn/large/e3ee7ad0gy1gn5njtdtibj20hn07ldg8.jpg" alt="混淆矩阵2.png" style="zoom:67%;" />



<p>P(Positive):代表1</p>
<p>N(Negative):代表0</p>
<p>T(True):代表预测正确</p>
<p>F(False):代表错误</p>
<p>11为TP，10为FP，01为FN，00为TN。</p>
<p>代码示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sklearn.metrics.confusion_matrix(y_true, y_pred, labels=<span class="literal">None</span>, sample_weight=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>







<h3 id="2-召回率-recall-score"><a href="#2-召回率-recall-score" class="headerlink" title="(2): 召回率(recall_score)"></a>(2): 召回率(recall_score)</h3><p>（召回率针对原样本，含义是预测正确的样本数占实际为正样本的百分比），分母为实际为正的样本数。<br>$$<br>R = \frac{TP}{TP+FN}<br>$$<br>代码实现:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">recall_score=recall_score(y_true, y_pred,labels=<span class="literal">None</span>,pos_label=<span class="number">1</span>,average=<span class="string">'binary'</span>, sample_weight=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>





<h3 id="3-精确率"><a href="#3-精确率" class="headerlink" title="(3): 精确率"></a>(3): 精确率</h3><p>它是针对预测结果而言的，它的含义是预测正确的样本数占预测为正样本的百分比，意思就是在预测为正样本的结果中，我们有多少把握可以预测正确，即预测的有多少个为正样本。分母为预测为正的样本数</p>
<p>精确率代表对正样本结果中的预测准确程度，而准确率则代表整体的预测准确程度，既包括正样本，也包括负样本，和样本比例有很大关系。<br>$$<br>P = \frac{TP}{TP+FP}<br>$$</p>
<p>代码示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">precision_score=precision_score(y_true, y_pred[, labels, …])</span><br></pre></td></tr></table></figure>







<h3 id="4-准确率-accuracy-score"><a href="#4-准确率-accuracy-score" class="headerlink" title="(4): 准确率(accuracy_score)"></a>(4): 准确率(accuracy_score)</h3><p>准确率是指预测正确的样本数占总样本百分比<br>$$<br>accuracy = \frac{TP+FN}{TP+TN+FP+FN}<br>$$</p>
<p>准确率是分类问题中最简单也是最直观的评价指标， 但存在明显的缺陷。 比如， 当负样本占99%时， 分类器把所有样本都预测为负样本也可以获得99%的准确率。 所以， <strong>当不同类别的样本比例非常不均衡时， 占比大的类别往往成为影响准确率的最主要因素</strong></p>
<p>代码示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">accuracy_score=accuracy_score(y_true, y_pred, normalize=<span class="literal">True</span>, sample_weight=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>





<h3 id="5-F1-score"><a href="#5-F1-score" class="headerlink" title="(5): F1-score"></a>(5): F1-score</h3><p>F1-score是精准率和召回率二者的评估，F1分数同时考虑了精准率和召回率，让二者同时达到最高，取一个平衡。F1分数的公式为 = 2<em>精准率</em>召回率 / (精准率 +召回率)。<br>$$<br>\frac{2}{F} = \frac{1}{P}+\frac{1}{R}<br>$$<br>代码示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f1_score=f1_score(y_true, y_pred)</span><br></pre></td></tr></table></figure>



<h3 id="6-classification-report函数"><a href="#6-classification-report函数" class="headerlink" title="(6): classification_report函数"></a>(6): classification_report函数</h3><p>classification_report函数会输出包含召回率，精确率，F1值的表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line">y_true = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">y_pred = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">target_names = [<span class="string">'class 0'</span>, <span class="string">'class 1'</span>, <span class="string">'class 2'</span>]</span><br><span class="line">print(classification_report(y_true, y_pred, target_names=target_names))</span><br></pre></td></tr></table></figure>



<h3 id="7-P-R曲线"><a href="#7-P-R曲线" class="headerlink" title="(7): P-R曲线"></a>(7): P-R曲线</h3><p>P-R曲线综合考虑了精确率和召回率，P-R曲线的横轴是召回率， 纵轴是精确率。 对于一个排序模型来说， 其P-R曲线上的一个点代表着， 在某一阈值下， 模型将大于该阈值的结果判定为正样本，小于该阈值的结果判定为负样本， 此时返回结果对应的召回率和精确率。整条P-R曲线是通过将阈值从高到低移动而生成的。</p>
<h2 id="2-回归算法的评估方法"><a href="#2-回归算法的评估方法" class="headerlink" title="2: 回归算法的评估方法"></a>2: 回归算法的评估方法</h2><h3 id="（1）平均绝对百分比误差MAPE与均方根误差RMSE"><a href="#（1）平均绝对百分比误差MAPE与均方根误差RMSE" class="headerlink" title="（1）平均绝对百分比误差MAPE与均方根误差RMSE"></a>（1）平均绝对百分比误差MAPE与均方根误差RMSE</h3><p>RMSE经常被用来衡量<strong>回归模型</strong>的好坏，一般情况下， RMSE能够很好地反映回归模型预测值与真实值的偏离程度。 但在实际问题中， 如果存在个别偏离程度非常大的<strong>离群点</strong> 时， 即使离群点数量非常少， 也会让RMSE指标变得很差。<br>$$<br>RMSE=\sqrt{\frac{\sum\limits_{i=1}^n (y_i-\hat y_i)^2}{n}}<br>$$<br><strong>存在离群点解决办法：</strong></p>
<ul>
<li>第一， 如果我们认定这些离群点是“噪声点”的话， 就需要在数据预处理的阶段把这些噪声点过滤掉。</li>
<li>第二， 如果不认为这些离群点是“噪声点”的话， 就需要进一步提高模型的<br>预测能力， 将离群点产生的机制建模进去。</li>
<li>第三， 可以找一个更合适的指标来评估该模型, 比如平均绝对百分比误差MAPE。</li>
<li></li>
</ul>
<p>$$<br>MAPE = \sum_{i=1}^n |\frac{y_i-\hat y_i}{y_i}| \times \frac{100}{n}<br>$$</p>
<p>相比RMSE， MAPE相当于把每个点的误差进行了归一化， 降低了个别离群点带来的绝对误差的影响。</p>
<h2 id="3-ROC和AUC曲线"><a href="#3-ROC和AUC曲线" class="headerlink" title="3: ROC和AUC曲线"></a>3: ROC和AUC曲线</h2><h3 id="1-TPR和FPR"><a href="#1-TPR和FPR" class="headerlink" title="(1): TPR和FPR"></a>(1): TPR和FPR</h3><p>TPR和FPR都主要关注正样本</p>
<p><strong>真正率FPR为有多少负样本被错误预测为正样本</strong></p>
<p><strong>假正率TPR为有多少正样本被正确预测为正样本</strong></p>
<p>ROC曲线的横坐标为假阳性率（False Positive Rate，FPR）；纵坐标为真阳性率（True Positive Rate，TPR）。FPR和TPR的计算方法分别为<br>$$<br>FPR = \frac{FP}{N}\<br>TPR = \frac{TP}{P}<br>$$<br>其中P是真实的正样本的数量，N是真实的负样本的数量，TP是P个正样本中被分类器预测为正样本的个数，FP是N个负样本中被分类器预测为正样本的个数</p>
<h3 id="2-ROC曲线"><a href="#2-ROC曲线" class="headerlink" title="(2): ROC曲线"></a>(2): ROC曲线</h3><p>ROC曲线中的主要两个指标就是真正率和假正率，其中横坐标为真正率（FPR），纵坐标为假正率（TPR）<br>ROC曲线也是通过遍历所有阈值来绘制整条曲线的，改变阈值只是不断地改变预测的正负样本数，曲线是不会变的。</p>
<p>FPR表示模型虚报的响应程度，而TPR表示模型预测响应的覆盖程度。</p>
<p>使用ROC曲线评估分类模型是非常通用的手段，但是，使用它的时候要注意两点：</p>
<ul>
<li><p>（1）分类的类型，必须为数值型。</p>
</li>
<li><p>（2） 且只针对二分类问题。</p>
</li>
</ul>
<p><strong>二分类的时候，可以利用roc_curve计算fpr,tpr,和阈值thresholds;，并画出roc曲线，利用roc_auc_score计算auc的值</strong></p>
<p><strong>曲线绘制代码:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fpr,tpr,thresholds=roc_curve(y_test,y_pred, pos_label=<span class="literal">None</span>, sample_weight=<span class="literal">None</span>, drop_intermediate=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">print</span> (tpr,fpr,thresholds)</span><br><span class="line">roc_auc = auc(fpr, tpr)<span class="comment">#计录auc的值，在（0,1）之间</span></span><br><span class="line">plt.plot(fpr, tpr, lw=<span class="number">1</span>, label=<span class="string">'ROC(area = %0.2f)'</span> % (roc_auc))</span><br><span class="line">plt.xlabel(<span class="string">"FPR (False Positive Rate)"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"TPR (True Positive Rate)"</span>)</span><br><span class="line">plt.title(<span class="string">"Receiver Operating Characteristic, ROC(AUC = %0.2f)"</span>% (roc_auc))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>



<p><strong>优点:</strong> </p>
<p>(1)ROC曲线能很容易的查出任意阈值对学习器的泛化性能影响。</p>
<p>(2)有助于选择最佳的阈值。ROC曲线越靠近左上角，模型的查全率就越高。最靠近左上角的ROC曲线上的点是分类错误最少的最好阈值，其假正例和假反例总数最少。</p>
<p>(3)可以对不同的学习器比较性能。将各个学习器的ROC曲线绘制到同一坐标中，直观地鉴别优劣，靠近左上角的ROC曲所代表的学习器准确性最高</p>
<h3 id="3-使用AUC面积值来判断ROC曲线好坏"><a href="#3-使用AUC面积值来判断ROC曲线好坏" class="headerlink" title="(3): 使用AUC面积值来判断ROC曲线好坏"></a>(3): 使用AUC面积值来判断ROC曲线好坏</h3><p><strong>AUC面积的一般判断标准，面积在0到1之间，AUC越高，模型区分能力越好</strong></p>
<p>0.5 - 0.7：效果较低，但用于预测股票已经很不错了</p>
<p>0.7 - 0.85：效果一般</p>
<p>0.85 - 0.95：效果很好</p>
<p>0.95 - 1：效果非常好，但一般不太可能</p>
<p><strong>AUC两种计算方法</strong></p>
<p>(1)<strong>roc_auc_score</strong>: 根据预测值和真实值确定AUC的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">scores = np.array([<span class="number">0.1</span>, <span class="number">0.4</span>, <span class="number">0.35</span>, <span class="number">0.8</span>])</span><br><span class="line">AUC=roc_auc_score(y_true, y_pred)</span><br><span class="line"><span class="keyword">print</span> (AUC)</span><br></pre></td></tr></table></figure>

<p>(2)<strong>roc_curve（二分类有效）</strong>: 根据曲线上的值确定AUC的值</p>
<p>roc_curve返回这三个变量：fpr,tpr,和阈值thresholds;</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">y = np.<span class="built_in">array</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">scores = np.<span class="built_in">array</span>([<span class="number">0.1</span>, <span class="number">0.4</span>, <span class="number">0.35</span>, <span class="number">0.8</span>])</span><br><span class="line">fpr, tpr, thresholds = roc_curve(y, scores, pos_label=<span class="number">2</span>)</span><br><span class="line">print (fpr,tpr,thresholds)</span><br><span class="line">print (auc(fpr, tpr))</span><br></pre></td></tr></table></figure>





<h3 id="4-P-R曲线和ROC曲线区别"><a href="#4-P-R曲线和ROC曲线区别" class="headerlink" title="(4): P-R曲线和ROC曲线区别"></a>(4): P-R曲线和ROC曲线区别</h3><p>ROC曲线有一个特点， 当正负样本的分布发生变化时， ROC曲线的形状能够基本保持不变， 而P-R曲线的形状一般会发生较剧烈的变化。</p>
<p>ROC曲线也是通过遍历所有阈值来绘制整条曲线的，改变阈值只是不断地改变预测的正负样本数，曲线是不会变的，这让ROC曲线能够尽量降低不同测试集带来的干扰， 更加客观地衡量模型本身的性能，实际场景中样本一般不均衡，所以ROC曲线更加稳定。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>模型选择</tag>
        <tag>模型评估</tag>
        <tag>交叉验证</tag>
        <tag>参数调优</tag>
      </tags>
  </entry>
</search>
