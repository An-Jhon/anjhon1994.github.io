{"meta":{"title":"Anjhon","subtitle":"小安","description":"佛系分享","author":"Anjhon","url":"https://anjhon1994.github.io","root":"/"},"pages":[{"title":"","date":"2019-12-20T05:12:25.000Z","updated":"2020-01-13T05:33:31.631Z","comments":true,"path":"about/index.html","permalink":"https://anjhon1994.github.io/about/index.html","excerpt":"","text":"关于我90后程序员, 坐标成都, 爱好: 看书, 看片, 看妹子 关于本站本站基于Hexo博客框架, 托管于GitHub, 于2019年12月20日建站成功 后续更新,敬请期待!"},{"title":"博客分类","date":"2019-12-19T14:58:28.000Z","updated":"2020-01-08T15:53:41.434Z","comments":true,"path":"categories/index.html","permalink":"https://anjhon1994.github.io/categories/index.html","excerpt":"","text":""},{"title":"Category","date":"2021-01-17T03:35:38.476Z","updated":"2020-01-12T10:08:43.444Z","comments":true,"path":"category/index.html","permalink":"https://anjhon1994.github.io/category/index.html","excerpt":"","text":""},{"title":"search","date":"2021-01-09T08:10:06.000Z","updated":"2021-01-09T08:10:07.019Z","comments":true,"path":"search/index-1.html","permalink":"https://anjhon1994.github.io/search/index-1.html","excerpt":"","text":""},{"title":"Search","date":"2021-01-09T08:14:19.867Z","updated":"2021-01-09T08:14:19.867Z","comments":true,"path":"search/index.html","permalink":"https://anjhon1994.github.io/search/index.html","excerpt":"","text":""},{"title":"相册","date":"2019-04-01T11:10:05.000Z","updated":"2021-01-09T14:18:33.576Z","comments":true,"path":"photos/index.html","permalink":"https://anjhon1994.github.io/photos/index.html","excerpt":"","text":".posts-expand .post-body img{ padding: 1px; } .footer{ display: none !important; } /*不展示底部*/ .footer-inner{ display: none !important; } .v * { color: #f4f4f4 !important; } .v .vwrap .vmark .valert .vcode { background: #00050b !important; } /*不展示侧栏*/ .sidebar-toggle{ display: none !important; } /*修改相册页面内容宽度为全屏*/ .main-inner{ width: 100%; margin-top: unset; } /*修改主体页面样式*/ .main { padding-bottom: 150px; margin-top: 0px; background: #121212; } /*body体样式*/ body { background-image: unset; background-attachment: unset; background-size: 100%; } .header{ background: rgba(28, 25, 25, 0.6); border-bottom: unset; } .menu .menu-item a{ font-weight: 300; color: #222; } .imgbox{ width: 100%; overflow: hidden; border-right: 0px solid #bcbcbc; } .box{ visibility: visible; overflow: auto; zoom: 1; } .box li{ float: left; width: 25%; /*每个框占25%*/ position: relative; overflow: hidden; text-align: center; list-style: none; margin: 0; /*display: inline;*/ padding: 0; height: 400px; /*固定高度*/ } .box li span{ display: block; padding: 4% 7% 10% 7%; min-height: 80px; background: #fff; color: #fff; font-size: 16px; background: #121212; font-weight: 600; line-height: 26px; -webkit-box-sizing: border-box; box-sizing: border-box; } img.imgitem{ padding: unset; padding: unset; border: unset; position: relative; padding: 0px; width: 100%; height: 350px; } div#comments.comments.v { border: 0px; margin: auto !important; margin-top: unset; margin-left: unset; margin-right: unset; width: 60%; padding-top: 50px; } div#posts.posts-expand { border: unset; padding: unset; margin-bottom: 10px; } .valine .vlist .vcard .vcomment-body .vhead .vname{ color: #fff; } .valine .vlist .vcard .vcomment-body .text-wrapper .vcomment p{ color: #fff; } .box p{ display: block; background: #121212; color: #fff; font-size: 12px; font-family: 'SwisMedium'; text-align: center; } .box span strong{ background: rgba(0,0,0,0.4); padding: 20px; font-family: serif, sans-serif; } .posts-expand .post-title { display: none; } .title{ display: inline-block; vertical-align: middle; font: 85px/250px 'ChaletComprimeMilanSixty'; background-position: left bottom !important; color: #fff; background-size: 100% auto !important; -webkit-background-size: cover; -moz-background-size: cover; -o-background-size: cover; width: 100%; text-align: center; border: unset; height: 580px; cursor: unset !important; -webkit-box-sizing: border-box; /*box-sizing: border-box;*/ } .btn-more-posts{ display: inline-block; vertical-align: middle; font: 85px/250px 'ChaletComprimeMilanSixty'; color: #000; width: 100%; text-align: center; border: unset; height: 400px; background-color: #121212; /*-webkit-box-sizing: border-box;*/ /*box-sizing: border-box;*/ } @media (max-width: 767px){ .box li { width: 100%; height: auto; } .title { height: 200px; } .posts-expand .post-body img{ box-sizing: none; padding: 0px !important; } .box span { min-height: 80px; border-right: unset; font-size: 17px; } .box p{ border-right: unset; font-size: 12px; } .posts-expand { margin: unset; } div#comments.comments.v { width: 96%; padding-top: 50px; } } @media (min-width: 1300px){ .container .main-inner{ width: 100%; } } function loadXMLDoc(xmlUrl){ try //Internet Explorer { xmlDoc=new ActiveXObject(“Microsoft.XMLDOM”); } catch(e) { try //Firefox, Mozilla, Opera, etc. { xmlDoc=document.implementation.createDocument(“”,””,null); } catch(e) {alert(e.message)} } try { xmlDoc.async=false; xmlDoc.load(xmlUrl); } catch(e) { try //Google Chrome { var chromeXml = new XMLHttpRequest(); chromeXml.open(&quot;GET&quot;, xmlUrl, false); chromeXml.send(null); xmlDoc = chromeXml.responseXML.documentElement; //alert(xmlDoc.childNodes[0].nodeName); //return xmlDoc; } catch(e) { alert(e.message) } } return xmlDoc; } xmlDoc=loadXMLDoc(“https://anjhon-blog-imags-1300562301.cos.ap-nanjing.myqcloud.com/&quot;); var urls = xmlDoc.getElementsByTagName(‘Key’);var date = xmlDoc.getElementsByTagName(‘LastModified’);var wid = 350;var showNum = 21; //每个相册一次展示多少照片if ((window.innerWidth) &gt; 1200) { wid = (window.innerWidth * 3) / 18;}var box = document.getElementById(‘box’);var i = 0; var content = new Array();var tmp=0;var kkk=-1;for (var t = 0; t &lt; urls.length ; t++) { var bucket=urls[t].innerHTML; var length=bucket.indexOf(‘/‘); if(length===bucket.length-1){ kkk++; content[kkk]=new Array(); content[kkk][0]={‘url’:bucket,’date’:date[t].innerHTML.substring(0,10)}; tmp=1; } else { content[kkk][tmp++]={‘url’:bucket.substring(length+1),’date’:date[t].innerHTML.substring(0,10)}; }} for (var i = 0; i &lt; content.length; i++) { var conBox=document.createElement(“div”); conBox.id=’conBox’+i; box.appendChild(conBox); var item=document.createElement(“div”); var title=content[i][0].url; item.innerHTML=”&lt;button class=title style=background:url(https://anjhon-blog-imags-1300562301.cos.ap-nanjing.myqcloud.com/&quot; + title + “封面.jpg”+”);background-repeat:no-repeat;&gt;“ + title.substring(0,title.length - 1) + ““; conBox.appendChild(item); for (var j = 1; j &lt; content[i].length &amp;&amp; j &lt; showNum+1; j++) { var con=content[i][j].url; var item=document.createElement(&quot;li&quot;); if(con.substring(0,con.length-4) != &quot;封面&quot;){ item.innerHTML=&quot;&lt;div class=imgbox id=imgbox style=height:&quot;+wid+&quot;px;&gt;&lt;img class=imgitem src=https://anjhon-blog-imags-1300562301.cos.ap-nanjing.myqcloud.com/ &quot; + title + con +&quot; alt=&quot; + con + &quot;&gt;&lt;/div&gt;&lt;span&gt;&quot; + con.substring(0,con.length-4); conBox.appendChild(item); } } if(content[i].length &gt; showNum){ var moreItem=document.createElement(&quot;button&quot;); moreItem.className = &quot;btn-more-posts&quot;; moreItem.id = &quot;more&quot; + i; moreItem.value = showNum + 1; let cur = i; moreItem.onclick = function (){ moreClick(this,cur,content[cur],content[cur][0].url); } moreItem.innerHTML=&quot;&lt;span style=display:inline;&gt;&lt;strong style=color:#f0f3f6;&gt;加载更多&lt;/strong&gt;&lt;/span&gt;&quot;; conBox.appendChild(moreItem); }} function moreClick(obj,cur,cont,title){ var parent = obj.parentNode; parent.removeChild(obj); var j=obj.value; var begin=j; for ( ; j &lt; cont.length &amp;&amp; j &lt; Number(showNum) + Number(begin); j++) { var con=cont[j].url; var item=document.createElement(“li”); item.innerHTML=”&lt;div class=imgbox id=imgbox style=height:”+wid+”px;&gt;&lt;img class=imgitem src=https://anjhon-blog-imags-1300562301.cos.ap-nanjing.myqcloud.com/ “+title+con+” alt=”+con+”&gt;“+con.substring(0,con.length-4); parent.appendChild(item); var v=item.getElementsByTagName(‘img’); v[0].id=imgid; imgid++; } if(cont.length &gt; j){ obj.value=j; parent.appendChild(obj); }}"},{"title":"Tag","date":"2020-01-12T10:08:26.626Z","updated":"2020-01-12T10:08:26.626Z","comments":true,"path":"tag/index.html","permalink":"https://anjhon1994.github.io/tag/index.html","excerpt":"","text":""},{"title":"我的标签","date":"2019-12-19T16:22:53.000Z","updated":"2019-12-22T07:54:11.365Z","comments":true,"path":"tags/index.html","permalink":"https://anjhon1994.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"手推维特比算法实现词性标注","slug":"NLP/手写维特比算法实现词性标注","date":"2021-08-14T16:00:00.000Z","updated":"2021-01-17T03:49:15.465Z","comments":true,"path":"2021/08/15/NLP/手写维特比算法实现词性标注/","link":"","permalink":"https://anjhon1994.github.io/2021/08/15/NLP/%E6%89%8B%E5%86%99%E7%BB%B4%E7%89%B9%E6%AF%94%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%AF%8D%E6%80%A7%E6%A0%87%E6%B3%A8/","excerpt":"","text":"一、词性标注简单原理现有已经标注好的词和对应的词性，作为训练数据。 假设给定一个句子，我们要通过构建一个维特比算法写的模型，来为这个句子标注出正确的词性。 二、维特比算法维特比算法（英语：Viterbi algorithm）是一种动态规划算法。它用于寻找最有可能产生观测事件序列的维特比路径——隐含状态序列，特别是在马尔可夫信息源上下文和隐马尔可夫模型中。术语“维特比路径”和“维特比算法”也被用于寻找观察结果最有可能解释相关的动态规划算法。例如在统计句法分析中动态规划算法可以被用于发现最可能的上下文无关的派生（解析）的字符串，有时被称为“维特比分析”。 —— 维基百科 假设句子S：$S=w_1 w_2 w_3…w_n$，用 $Z$ 代表句子 $S$ 的词性，那么就可以写成：$$\\hat Z = \\underset{z}{\\operatorname{argmax}} P(Z|S)$$解读为: 给定一个句子 $S$ , 求它最大概率的词性序列 $Z$$$\\begin{aligned}&amp; 根据贝叶斯定理可得: \\\\&amp; \\\\P(Z|S) &amp;= \\frac{P(S|Z)·P(Z)}{P(S)}\\\\&amp; \\\\&amp; 又根据噪声信道模型(Noise Channel Model)可得: \\\\&amp; \\\\P(Z|S)&amp; \\propto P(S|Z)·P(Z)\\\\&amp; = P(S_1,S_2,S_3…S_n|Z_1,Z_1,Z_3…Z_n)·P(Z_1,Z_1,Z_3…Z_n)\\\\&amp; \\\\&amp; 假设每个单词的 词与词性 是互相独立的, 那么:\\\\&amp; \\\\&amp; = P(S_1|Z_1)·P(S_2|Z_2),P(S_3|Z_3)…P(S_n|Z_n)·P(Z_1,Z_1,Z_3…Z_n)\\\\&amp; = \\prod_{i=1}^n P(S_i|Z_i)·P(Z_1,Z_1,Z_3…Z_n)\\\\&amp; \\\\&amp; 通过bigram模型来展开,那么:\\\\&amp; \\\\&amp; = \\prod_{i=1}^n P(S_i|Z_i)·P(Z_1)·P(Z_2|Z_1)·P(Z_3|Z_2)…P(Z_n|Z_{n-1})\\\\&amp; = \\prod_{i=1}^n P(S_i|Z_i)·P(Z_1)·\\prod_{t=2}^nP(Z_t|Z_{t-1})\\\\&amp; \\\\&amp; 在前面加log并展开:\\\\&amp; \\\\&amp; = log(\\prod_{i=1}^n P(S_i|Z_i)·P(Z_1)·\\prod_{t=2}^n P(Z_t|Z_{t-1}))\\\\&amp; = \\sum_{i=1}^n log(P(S_i|Z_i)) + log(P(Z_1)) + \\sum_{t=2}^n log(P(Z_t|Z_{t-1}))\\\\\\end{aligned}$$ 最终得到:$$\\hat Z = \\underset{z}{\\operatorname{argmax}} (\\sum_{i=1}^n log(P(S_i|Z_i)) + log(P(Z_1)) + \\sum_{t=2}^n log(P(Z_t|Z_{t-1})))$$ 这里的 $\\hat Z$ 最终输出的是一个（概率最大的）词性序列，得到上面这个公式之后，我们就可以用维特比算法进行求解 由于篇幅原因，这里就不展开介绍维特比算法了。 这里有更好的文章：如何通俗地讲解 viterbi 算法？ $A = P(S_i|Z_i)$ 表示给定一个词性, 出现某个单词的概率 $\\pi = P(Z_1)$ 表示该词性出现在句首的概率 $B = P(Z_t|Z_{t-1})$ 表示句子中出现 $Z_{t-1}$ 之后出现 $Z_t$ 的概率(词性转移的概率) 以上三个参数都可以在训练数据中可以统计出来 假设, 训练数据中单词的个数(词典的长度)为M, 词性的个数为N, 那么: A 是一个 M*N的矩阵; $\\pi$ 是一个长度为N的向量, B 是一个N*N的矩阵 接下来就是愉快的代码时间了 三、代码实现1: 建立单词和词性的map123456789101112131415161718# 建立map，以便后面在更新矩阵和向量时统计次数，并求出概率tag2id, id2tag = &#123;&#125;, &#123;&#125;word2id, id2word = &#123;&#125;, &#123;&#125;for line in open('traindata.txt'): items = line.split('/') word, tag = items[0], items[1].rstrip() if word not in word2id: word2id[word] = len(word2id) id2word[len(id2word)] = word if tag not in tag2id: tag2id[tag] = len(tag2id) id2tag[len(id2tag)] = tag M = len(word2id) # 词典大小N = len(tag2id) # 词性个数print(M, N) 2: 代码实现计算参数A, $\\pi$ , B123456789101112131415161718192021222324252627282930313233import numpy as np# 计算参数# 初始化参数pi = np.zeros(N)A = np.zeros((N, M))B = np.zeros((N, N))prev_tag = '' # 用来保存上一个词的词性for line in open('traindata.txt'): items = line.split('/') wordid, tagid = word2id[items[0]], tag2id[items[1].rstrip()] # 获取词和词性对应的id # 先统计pi A B对应位置的次数 if prev_tag == '': # 判断当前单词是否为句子的开始 pi[tagid] += 1 A[tagid][wordid] += 1 else: A[tagid][wordid] += 1 B[tag2id[prev_tag]][tagid] += 1 if items[0] == '.': # 如果当前单词为句号，那么更新prev_tag的状态，以便下次循环判断是否为句子的开始 prev_tag = '' else: # 否则就记录当前词的词性 prev_tag = items[1].rstrip() # 将次数转换成概率pi = pi / sum(pi)for i in range(N): A[i] = A[i] / sum(A[i]) # 求矩阵中每个数在每一行的占比（概率） B[i] = B[i] / sum(B[i]) 3: 建立模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 建立模型def log(v): if v == 0: return np.log(v + 0.00000001) # 平滑操作 return np.log(v) def viterbi(x, pi, A, B): \"\"\" x: 需要预测词性的句子 pi: 词性出现句首的概率 A：给定词性，每个单词出现的概率 B：词性质检转换的概率（上个单词的词性为a，下个单词的词性为b的概率） \"\"\" x =[word2id[word] for word in x.split(' ')] # 输入为因为句子，直接用空格切割；如果为中文，则需要分词 T = len(x) # 定义一个二维数组dp，dp[i][j]表示从第一个单词到第i个单词,第j个词性的最优路径 dp = np.zeros([T,N]) # 定义一个二维数组ptr，记录当前dp节点最好路径得分 是由上一次哪一个词性计算得来的 ptr = np.array([[0 for y in range(N)] for x in range(T)]) # 计算dp 第一例（第一个单词）在每个词性下的路径值 for j in range(N): dp[0][j] = log(pi[j]) + log(A[j][x[0]]) # 计算第二个词往后的所有路径得分 for i in range(1, T): # 每个单词 for j in range(N): # 每个词性 dp[i][j] = -999999 for k in range(N): # 上一个词的词性 score = dp[i-1][k] + log(A[j][x[i]]) + log(B[k][j]) # 计算每个路径的值 if score &gt; dp[i][j]: dp[i][j] = score # 获取最优值,填到dp中 ptr[i][j] = k # 记录最优值路径 best_seq = [0]*T best_seq[T-1] = np.argmax(dp[T-1]) # 求出最后一个单词 的最大可能性 的词性 的下标 for i in range(T-2, -1, -1): best_seq[i] = ptr[i+1][best_seq[i+1]] # 获取被预测句子的每个词的最优词性的id for i in range(len(best_seq)): print(id2tag[best_seq[i]]) # 将最优词性的id转为对应的词性 4: 测试12x = \"Social Security number , passport number and details about the services provided for the payment\"viterbi(x, pi, A, B) 1&#123;% btn #, 文本 &amp; 标题,, 标题 %&#125;","categories":[{"name":"NLP","slug":"NLP","permalink":"https://anjhon1994.github.io/categories/NLP/"}],"tags":[{"name":"词性标注","slug":"词性标注","permalink":"https://anjhon1994.github.io/tags/%E8%AF%8D%E6%80%A7%E6%A0%87%E6%B3%A8/"},{"name":"自然语言处理","slug":"自然语言处理","permalink":"https://anjhon1994.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"},{"name":"NLP","slug":"NLP","permalink":"https://anjhon1994.github.io/tags/NLP/"},{"name":"viterbi","slug":"viterbi","permalink":"https://anjhon1994.github.io/tags/viterbi/"}]},{"title":"集成算法","slug":"机器学习/集成算法","date":"2020-04-17T16:00:00.000Z","updated":"2021-01-17T05:33:08.072Z","comments":true,"path":"2020/04/18/机器学习/集成算法/","link":"","permalink":"https://anjhon1994.github.io/2020/04/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%9B%86%E6%88%90%E7%AE%97%E6%B3%95/","excerpt":"","text":"一: 概述集成学习(ensemble learning)可以说是现在非常火爆的机器学习方法了。它本身不是一个单独的机器学习算法，而是通过构建并结合多个机器学习器来完成学习任务。也就是我们常说的“博采众长”。集成学习可以用于分类问题集成，回归问题集成，特征选取集成，异常点检测集成等等，可以说所有的机器学习领域都可以看到集成学习的身影。 集成学习有两个主要的问题需要解决，第一是如何得到若干个个体学习器，第二是如何选择一种结合策略，将这些个体学习器集合成一个强学习器。 集成学习分为两种: 第一种就是所有的个体学习器都是一个种类的，或者说是同质的。比如都是决策树个体学习器，或者都是神经网络个体学习器。 第二种是所有的个体学习器不全是一个种类的，或者说是异质的。比如我们有一个分类问题，对训练集采用支持向量机个体学习器，逻辑回归个体学习器和朴素贝叶斯个体学习器来学习，再通过某种结合策略来确定最终的分类强学习器。 目前来说，同质个体学习器的应用是最广泛的，一般我们常说的集成学习的方法都是指的同质个体学习器。而同质个体学习器使用最多的模型是CART决策树和神经网络。同质个体学习器按照个体学习器之间是否存在依赖关系可以分为两类，第一个是个体学习器之间存在强依赖关系，一系列个体学习器基本都需要串行生成，代表算法是boosting系列算法，第二个是个体学习器之间不存在强依赖关系，一系列个体学习器可以并行生成，代表算法是bagging和随机森林（Random Forest）系列算法。 二: 同质学习器的分类1: bagging 具体过程： 从原始样本集中抽取训练集。每轮从原始样本集中使用 Bootstraping 的方法抽取 n 个训练样本（在训练集中，有些样本可能被多次抽取到，而有些样本可能一次都没有被抽中 - 有放回抽样）。共进行 k 轮抽取，得到 k 个训练集。（k 个训练集之间是相互独立的） 每次使用一个训练集得到一个模型，k 个训练集共得到 k 个模型。 Bagging 的思路是所有基础模型都一致对待，每个基础模型手里都只有一票。然后使用民主投票的方式得到最终的结果。 大部分情况下， 经过 bagging 得到的结果方差（variance）更小 。 随机森林是bagging的一个特化进阶版，所谓的特化是因为随机森林的弱学习器都是决策树。所谓的进阶是随机森林在bagging的样本随机采样基础上，又加上了特征的随机选择，其基本思想没有脱离bagging的范畴。 2: boosting 具体过程： 通过加法模型将基础模型进行线性的组合。 每一轮训练都提升那些错误率小的基础模型权重，同时减小错误率高的模型权重。 在每一轮改变训练数据的权值或概率分布，通过提高那些在前一轮被弱分类器分错样例的权值，减小前一轮分对样例的权值，来使得分类器对误分的数据有较好的效果。 Boosting算法的工作机制是首先从训练集用初始权重训练出一个弱学习器，根据弱学习的学习误差率表现来更新训练样本的权重，使得之前弱学习器学习误差率高的训练样本点的权重变高，使得这些误差率高的点在后面的弱学习器中得到更多的重视。 Boosting通过加法模型将弱分类器进行线性组合，比如AdaBoost通过加权多数表决的方式，即增大错误率小的分类器的权值，同时减小错误率较大的分类器的权值。 Boosting 和 bagging 最本质的差别在于他对基础模型不是一致对待的，而是经过不停的考验和筛选来挑选出精英，然后给精英更多的投票权，表现不好的基础模型则给较少的投票权，然后综合所有人的投票得到最终结果。 大部分情况下， 经过 boosting 得到的结果偏差（bias）更小 。 3: Bagging 和 Boosting 的差别样本选择上： Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。 Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。 样例权重： Bagging：使用均匀取样，每个样例的权重相等 Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。 预测函数： Bagging：所有预测函数的权重相等。 Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。 并行计算： Bagging：各个预测函数可以并行生成 Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。 三: 集成学习的结合策略1: 平均法对于数值类的回归预测问题，通常使用的结合策略是平均法，也就是说，对于若干个弱学习器的输出进行平均得到最终的预测输出。$$H(x)=\\frac{1}{T}\\sum_{i=1}^Th_i(x)$$$T$代表基础模型数量; $h_i(x)$为每个模型预测的结果 2: 投票法对于分类问题的预测，我们通常使用的是投票法。 最简单的投票法是相对多数投票法，也就是我们常说的少数服从多数，如果不止一个类别获得最高票，则随机选择一个做最终类别。 稍微复杂的投票法是绝对多数投票法，也就是我们常说的要票过半数。在相对多数投票法的基础上，不光要求获得最高票，还要求票过半数。否则会拒绝预测。 更加复杂的是加权投票法，和加权平均法一样，每个弱学习器的分类票数要乘以一个权重，最终将各个类别的加权票数求和，最大的值对应的类别为最终类别。 3: 学习法学习法，代表方法是stacking，当使用stacking的结合策略时， 我们不是对弱学习器的结果做简单的逻辑处理，而是再加上一层学习器，也就是说，我们将训练集弱学习器的学习结果作为输入，将训练集的输出作为输出，重新训练一个学习器来得到最终结果。 在这种情况下，我们将弱学习器称为初级学习器，将用于结合的学习器称为次级学习器。对于测试集，我们首先用初级学习器预测一次，得到次级学习器的输入样本，再用次级学习器预测一次，得到最终的预测结果。 四: bagging之随机森林系列算法1: 随机森林(1): 构建随机森林 假如有N个样本，则有放回的随机选择n个样本(每次随机选择一个样本，然后返回继续选择)。这选择好了的N个样本用来训练一个决策树，作为决策树根节点处的样本。 当每个样本有M个属性时，在决策树的每个节点需要分裂时，随机从这M个属性中选取出m个属性，满足条件m &lt;&lt; M。然后从这m个属性中采用某种策略（比如说信息增益）来选择1个属性作为该节点的分裂属性。 决策树形成过程中每个节点都要按照步骤2来分裂（很容易理解，如果下一次该节点选出来的那一个属性是刚刚其父节点分裂时用过的属性，则该节点已经达到了叶子节点，无须继续分裂了）。一直到不能够再分裂为止。注意整个决策树形成过程中没有进行剪枝。 按照步骤1~3建立大量的决策树，这样就构成了随机森林了。 (2): 随机森林的优缺点优点 1、训练可以并行化，对于大规模样本的训练具有速度的优势。 2、由于进行随机选择决策树划分特征列表，这样在样本维度比较高的时候，仍然具有比较高的训练性能。 3、可以给出各个特征值的重要性列表。 4、由于存在随机抽样，训练出来的模型方差小，泛化能力强。 5、RF实现简单。 6、对于部分特征的丢失不敏感。 缺点 1、噪音过大的特征上，容易过拟合。 2、取值比较多的划分特征对RF的决策会产生更大的影响，从而有可能影响模型的效果。 (3): 随机森林的应用方向 (4): 随机森林参数详解刘建平老师 - scikit-learn随机森林调参小结 2: 机限随机森林(extra trees)1、RF会随机采样来作为子决策树的训练集，而Extra Tree每个子决策树采用原始数据集训练。 2、RF在选择划分特征点的时候会和传统决策树一样，会基于信息增益、信息增益率、基尼系数、均方差等原则来选择最优的特征值。Extra Tree则是随机选择一个特征值来划分决策树。 从第二点可以看出，由于随机选择了特征值的划分点位，而不是最优点位，这样会导致生成的决策树的规模一般会大于RF所生成的决策树。也就是说，模型的方差相对于RF进一步减少，但是偏倚相对于RF进一步增大。在某些时候，extra trees的泛化能力比RF更好。 本文强烈参考的文章: 一文看懂集成学习（详解 bagging、boosting 以及他们的 4 点区别） 刘建平老师 - 集成学习原理小结 五: bosting系列算法(一): AdaBoost算法1: AdaBoost算法概述Adaboost既可以用作分类，也可以用作回归。 在boosting中我们介绍过, Boosting算法的工作机制是首先从训练集用初始权重训练出一个弱学习器1，根据弱学习的学习误差率表现来更新训练样本的权重，使得之前弱学习器1学习误差率高的训练样本点的权重变高，使得这些误差率高的点在后面的弱学习器2中得到更多的重视。然后基于调整权重后的训练集来训练弱学习器2.，如此重复进行，直到弱学习器数达到事先指定的数目T，最终将这T个弱学习器通过集合策略进行整合，得到最终的强学习器。 只要是boosting大家族的算法，都要解决下面4个问题。 1）如何计算学习误差率e? 2) 如何得到弱学习器权重系数α? 3）如何更新样本权重D? 4) 使用何种结合策略？ 2: AdaBoost算法原理输入为样本集 $T={(x_1,y_1),(x_2,y_2),…(x_m,y_m)}$ 输出为 ${-1, +1}$ ，弱分类器算法, 弱分类器迭代次数K。 输出为最终的强分类器 $f(x)$ 1) 初始化样本集权重为 $$D(1)=(w_{11}),w_{12}),…w_{1m}))$$ $$ w_{1i}=\\frac{1}{m}, i=1,2…m$$ 2) 对于k=1,2，…K: a) 使用具有权重 $D_k$ 的样本集来训练数据，得到弱分类器$G_k(x)$ b) 计算$G_k(x)$的分类误差率$$e_k=P(G_k(x_i)≠y_i)=\\sum_{i=1}^m w_{ki}I(G_k(x_i)≠y_i)$$ c) 计算弱分类器的系数 $$α_k=\\frac{1}{2}log(\\frac{1-e_k}{e_k})$$ d) 更新样本集的权重分布$$w _{k+1, i}=\\frac{w _{ki}}{Z_K}exp(−α_ky_iG_k(x_i)), i=1,2,…m$$ 这里ZkZk是规范化因子$$Z_k=\\sum_{i=1}^m w_{ki}exp(−α_k y_i G_k(x_i))$$ 3) 构建最终分类器为：$$f(x)=sign(\\sum_{k=1}^K α_k G_k(x))$$ 对于Adaboost多元分类算法，其实原理和二元分类类似，最主要区别在弱分类器的系数上。比如Adaboost SAMME算法，它的弱分类器的系数$$α_k=\\frac{1}{2}log(\\frac{1-e_k}{e_k})+log(R−1)$$其中R为类别数。从上式可以看出，如果是二元分类，R=2，则上式和我们的二元分类算法中的弱分类器的系数一致。 3: 代码实现Adaboost算法二分类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153from sklearn.ensemble import AdaBoostClassifierimport numpy as npfrom sklearn import treeX = np.arange(10).reshape(-1,1)y = np.array([1,1,1,-1,-1,-1,1,1,1,-1])# 第一棵树!!!!!!# 样本的初始权重，还没有开始进行训练，所以，所有样本权重一样？w1 = np.full(shape = 10,fill_value=0.1)# 样本中10个数据，划分，0到1之间(threshold阈值0.5)划分；1到2之间（1.5）划分……thresholds = np.arange(0.5,10) # 生成0.5到9.5中间间隔1的10个数for i,t in enumerate(thresholds,start = 1): #enumerate,获取索引，默认从0开始， y_ = np.array([1]*i + [-1]*(10-i)) # 计算预测值 print(t,((y !=y_)*w1).sum()) # 计算每个分割点的误差率'''0.5 0.51.5 0.42.5 0.300000000000000043.5 0.44.5 0.55.5 0.66.5 0.57.5 0.48.5 0.300000000000000049.5 0.4'''# 阈值是2.5或者8.5，误差最小的：0.3; 选择2.5或者8.5作为裂分条件，代码中一般选择，前面的索引# 计算第一个弱学习器的权重，相当于大夫的话语权e1 = 0.3a1 = 1/2*np.log((1 -e1)/e1 )print('第一个弱学习器的权重:',a1)'''第一个弱学习器的权重: 0.42364893019360184'''# 更新样本的权重# 在w1的基础上，进行更新 w1 = [0.1,0.1,0.1……]y_ = np.array([1]*3 + [-1]*(10-3))w2 = w1*np.exp(-y*y_*a1)w2 = w2/w2.sum()print(w2)'''[0.07142857 0.07142857 0.07142857 0.07142857 0.07142857 0.07142857 0.16666667 0.16666667 0.16666667 0.07142857] '''# 第二棵树!!!!!!!!!!thresholds = np.arange(0.5,10)for i,t in enumerate(thresholds,start = 1): #enumerate,获取索引，默认从0开始， y_ = np.array([1]*i + [-1]*(10-i)) # 计算预测值 print(t,((y !=y_)*w2).sum()) # 计算每个分割点的误差率'''0.5 0.64285714285714281.5 0.57142857142857142.5 0.53.5 0.57142857142857144.5 0.64285714285714285.5 0.71428571428571426.5 0.54761904761904767.5 0.380952380952380938.5 0.214285714285714259.5 0.28571428571428564'''# 阈值，如果是8.5，那么左边9个数，右边是1个数，计算误差率y_ = np.array([1]*9 + [-1]*(10-9))#预测值display(y,y_)e2 = ((y != y_)*w2).sum() # 误差率print('第二棵树的误差率：',e2)'''第二棵树的误差率： 0.21428571428571425'''a2 =np.round( 1/2*np.log((1 - e2)/e2),4)print('第二棵树，权重是：',a2) # 计算第二棵树的权重'''第二棵树，权重是： 0.6496'''# 更新样本权重w3 = w2*np.exp(-y*y_*a2)w3 = w3/w3.sum()print('更新样本权重：',w3)'''[0.04545643 0.04545643 0.04545643 0.16665975 0.16665975 0.16665975 0.10606501 0.10606501 0.10606501 0.04545643]'''# 第三棵树!!!!!!!!!!thresholds = np.arange(0.5,10)for i,t in enumerate(thresholds,start = 1):#enumerate,获取索引，默认从0开始， y_ = np.array([1]*i + [-1]*(10-i)) print(t,((y !=y_)*w3).sum()) #误差率 + 准确率 = 1'''0.5 0.409107883117543651.5 0.363651451660038762.5 0.3181950202025343.5 0.48485477152501614.5 0.65151452284749835.5 0.81817427416998066.5 0.71210926743580267.5 0.60604426070162458.5 0.49997925396744669.5 0.5454356854249515'''e3 = 0.1820# 计算第三棵树的权重y_ = np.array([-1]*6 + [1]*(10-6))a3 = 1/2*np.log((1 - e3)/e3)print('第三棵树的权重是：',a3)'''第三棵树的权重是： 0.7514278247629759'''# 更新第三棵树的，样本权值分布，权重w4 = w3*np.exp(-y*y_*a3)w4 = w4/w4.sum()print('第三棵树，更新样本权重：',w4.round(3))'''第三棵树，更新样本权重： [0.125 0.125 0.125 0.102 0.102 0.102 0.065 0.065 0.065 0.125]'''# 集成算法# 第一棵树ft(x)y1 = np.array([1]*3 + [-1]*(10-3))# 第二棵树的预测值y2 = np.array([1]*9 + [-1]*(10-9))#预测值# 第三棵树，预测值y3 = np.array([-1]*6 + [1]*(10-6))F = a1*y1 + a2*y2 + a3*y3# 将多个弱分类器，整合，变成了强分类器F(X)F'''array([ 0.32182111, 0.32182111, 0.32182111, -0.52547675, -0.52547675, -0.52547675, 0.97737889, 0.97737889, 0.97737889, -0.32182111])'''result = [-1 if i &lt;0 else 1 for i in F]result'''[1, 1, 1, -1, -1, -1, 1, 1, 1, -1]'''# 分类成功! 多分类1待更新。。。 刘建平 - 集成学习之Adaboost算法原理小结 刘建平 - scikit-learn Adaboost类库使用小结 (二): GBDT(梯度提升树)算法(Gradient Boosting Decision Tree)1: 梯度提升回归树算法原理(1): 残差更新:举个简单的例子: 预测一个同学本次的考试成绩, 根据他之前的考试成绩的平均值来预测本次结果, 在训练算法时, 将预测值(之前分数的平均分) 分数和实际的分数相减, 得到的值就是残差;(在梯度提升回归树中, 残差值越小越好) 之后按照梯度下降的思想不断更新残差: $residual = residual - learning_rate*residual$ residual 是上一轮的残差, learning_rate是残差更新的系数, 也就是学习率,在定义算法时定义的参数 直到循环的次数达到事先预设好的次数就结束, 预设次数是参数n_estimators决定的(默认是100) 示例: 现有一组数据, X代表消费金额和上网时长, 通过X预测任务的年龄. 12345678910111213141516171819202122232425262728293031323334353637import numpy as npfrom sklearn.ensemble import GradientBoostingRegressorimport matplotlib.pyplot as pltfrom sklearn import treeX = np.array([[600,0.8],[800,1.2],[1500,10],[2500,3]])y = np.array([14,16,24,26])# loss = ls 最小二乘法learning_rate = 0.1 # 残差更新系数gbdt = GradientBoostingRegressor(n_estimators=1,loss = 'ls', learning_rate=0.1) # learning_rate 学习率gbdt.fit(X,y_true) #训练y_ = gbdt.predict(X) #预测# 用代码实现残差更新residual = y - y.mean() # 残差(第一棵树); 预测的初始值给训练数据的平均值print(residual)'''array([-6., -4., 4., 6.])'''result = y - residual # 第一棵树的预测值residual = residual - learning_rate*residual # 对残差进行更新(残差值越小越好) - 第二棵树的残差result = y - residual # 第二棵树的预测值'''array([-3., -2., 2., 3.])'''# 以此类推, 残差值会越来越小, 预测的结果也就月接近真实值# 算法模型实现残差更新gbdt[0, 0].predict(X) # 得到残差gbdt.predict(X) # 预测值 (2): 均方误差判断分裂标准:知识扩展: 均方误差: 预测值和真实值的差的平方的平均值 MSE的值越小，说明预测模型描述实验数据具有更好的精确度$$MSE=\\frac{1}{N}\\sum_{i=1}^N(True_i-Predict_i)^2$$均方根误差: 均方误差开方$$RMSE=\\sqrt{\\frac{1}{N}\\sum_{i=1}^N(True_i-Predict_i)^2}$$平均绝对误差: 预测值和真实值的绝对值求和的平方的平均值 平均绝对误差能更好地反映预测值误差的实际情况.$$MAE=\\frac{1}{N}\\sum_{i=1}^N|True_i-Predict_i|$$方差: 数组内每个数和该数组的平均值的差的平方的和的平均值$$\\sigma^2 = \\frac{1}{N}\\sum _{i=1}^N(x_i-\\overline x)^2$$标准差(均方差): 方差开方 标准差能反映一个数据集的离散程度, 标准差越大,数据越离散$$\\sigma = \\sqrt{\\frac{1}{N}\\sum _{i=1}^N(x_i-\\overline x)^2}$$ 梯度提升回归树是使用了决策树的算法, 所以在预测的时候可以将过程可视化出来,方便更直观的观察整个过程;在这个过程中我们一般使用目标值的均方误差来作为分裂的标准: 同样是上面那个例子, 在第一次分裂的时候我们可以根据消费金额和上网时长来分裂, 这里以消费金额为例, 我们有决策树模型: X.iloc[:, 0] = [600, 800,1500,2500] —&gt; y = [14, 16,24,26] ①: [[600], [800,1500,2500]] —&gt; [[14], [16,24,26]] 此时计算目标值均方误差(初次年龄预测值为测试数据的平均值):$$mse_left = (14 - 14)^2\\div1 = 0 \\mse_right = ([16,24,26] - (16+24+26)\\div3)^2 \\div3 = \\frac{56}{3}$$再乘以各子数组在总数组中所占的比例:$$\\begin{aligned}mse&amp;=\\frac{1}{4}mse_left+\\frac{3}{4}mse_right\\&amp;=\\frac{3}{4}\\times \\frac{56}{3}\\&amp;=14\\end{aligned}$$同理可以算出另外两种决策树模型的均方误差: ②: [[600, 800], [1500,2500]] —&gt; [[14,16], [24,26]] 均方误差为: 1 ③: [[600, 800, 1500], [2500]] —&gt; [[14,16,24], [26]] 均方误差为: 14 均方误差越小,说明该模型预测的结果和真实值越接近,所以,不选它还选谁? 以上的推导只是梯度提升回归树的第一棵树的第一次裂变, 我们可以设置相应的参数,规定树的裂变次数, 所以按照以上的原理方式依次进行裂变,即可的到最精确的回归模型 刘建平 - 梯度提升树(GBDT)原理小结 2:梯度提升分类树算法原理(1): 二分类问题:1): 信息熵和交叉熵:信息熵:$$\\sum_{k=1}^N p_klog\\frac{1}{p_k}$$交叉熵: (pk是真实分布比例, qk是非真实分布(预测分布比例))$$\\sum_{k=1}^N p_klog\\frac{1}{q_k}$$ 2): GBDT原理概述GBDT 是先有 GB（梯度提升），再有 DT（决策树），所以我们先从 GB 讲起. boosting 就是通过训练多个弱分类器来组合成一个强分类器，形式如下:$$F_m(x) = F_0 + \\alpha_1 F_1(x) + \\alpha_2 F_2(x)+… + \\alpha_m F_m(x)$$其中，$F_i(x), i=1,2,3,…,m$ 是弱分类器，比如在 AdaBoost提升中是 C4.5决策树； $F_m(x)$是最终得到的强分类器; 而本篇中的GBDT的弱分类器则是CART回归树(在GBDT中不管是回归问题还是分类问题,弱学习器都是决策回归树) 最深梯度下降法(Steepest Gradient Descent): 给定一个起点$x_0$ 更新 $x$ 的位置: ​ $$i = 1,2,…,k$$ ​ $$x_i = x_{i-1} + \\gamma_{i-1}\\times g_{i-1}$$ 其中: $g_{i-1} = - \\frac{\\partial f}{\\partial x}|_ {x=x_{i-1}}$ 表示 $f$ 在 $x_{i-1}$ 处的导数 直到$|g_{i-1}|$足够小, 或者$|x_i-x_{i-1}| $ 足够小 以上迭代过程可以理解为: 整个寻优的过程就是小步快跑的过程，每跑一小步，都往函数当前下降最快的那个方向走一点，直到达到可接受的点 这个迭代过程展开得到寻优的结果: ​ $$x_k = x_0 + \\gamma_1g_1 + \\gamma_2g_2 + … + \\gamma_kg_k $$ 所以我们可以将最深梯度下降法运用到boosting, 不同的是最深梯度下降法求得的是一个最优值, 此时我们是要求得一个最优的函数 3): 二分类损失函数(交叉熵):$$\\psi(y, p) = ylog(\\frac{1}{p})+(1-y)log(\\frac{1}{1-p})\\\\\\psi(y, p) = -ylog(p)-(1-y)log(1-p)\\\\其中:\\\\p=\\frac{1}{1+exp(-F(x))}$$y是真实分布, p是非真实分布; 梯度提升回归森林是由决策回归树组成 , F(x)表示GBDT的学习器, 通过p这个sigmoid函数将其转换为相应的概率(多分类问题通过softmax函数转化概率) 带入p化简:(此处log默认以e为底)$$\\begin{aligned}\\psi(y, F(x)) &amp; = -ylog(p)-(1-y)log_2(1-p)\\\\&amp; = -ylog(\\frac{1}{1+exp(-F(x))})-(1-y)log(1-\\frac{1}{1+exp(-F(x))})\\\\&amp; = ylog(1+exp(-F(x)))-(1-y)log(\\frac{exp(-F(x))}{1+exp(-F(x))})\\\\&amp; = ylog(1+exp(-F(x)))-(1-y)log(exp(-F(x)))+(1-y)log(1+exp(-F(x)))\\\\&amp; = -(1-y)(-F(x))+log(1+exp(-F(x)))\\\\&amp; = F(x)-yF(x)+log(1+exp(-F(x)))\\\\&amp; = -yF(x)+log(exp(F(x)))+log(1+exp(-F(x)))\\\\&amp; = -yF(x)+log(exp(F(x))\\times (1+exp(-F(x))))\\\\&amp; = -yF(x)+log(exp(F(x))+1)\\\\\\end{aligned}$$ 对损失函数在$F_{m-1}(x)$ 处应用二级泰勒展开(方便计算$\\gamma_{mj}$):$$\\begin{aligned}L(\\gamma_{mj}, R_{mj}) &amp;= \\sum_{x_i \\in R_{mj}}\\psi(y, F_{m-1}(x)+\\gamma_{mj})\\\\&amp;\\approx \\sum_{x_i \\in R_{mj}}{\\psi(y, F_{m-1}(x))+\\psi’(y, F_{m-1}(x))\\gamma_{mj}+\\frac{1}{2}\\psi’’(y, F_{m-1}(x))\\gamma_{mj}^2}\\\\&amp;=argmin_{\\gamma_{mj}}\\sum_{x_i \\in R_{mj}}{\\psi(y_i,F_{m-1}(x_i)) + \\psi’(y_i,F_{m-1}(x_i))\\gamma_{mj} + \\frac{1}{2}\\psi’’(y_i,F_{m-1}(x_i))\\gamma_{mj}^2 }\\end{aligned}$$ $$F_m(x) = F_{m-1}(x) + \\gamma_m*learning_rate$$ $\\gamma_{mj}$ 相当于梯度下降中的梯度(这里可以理解为弱学习器的拟合函数), 表示第m轮的第j个叶节点的预测值 $R_{mj}$是第m轮学习的第j个叶节点, $F_{m-1}(x)$是上一轮学习的结果 接着对损失函数的泰勒展开式求导:$$\\begin{aligned}\\frac{\\partial L’(\\gamma_{mj}, R_{mj})}{\\partial\\gamma_{mj}}&amp;=\\sum_{x_i \\in R_{mj}}{\\psi’(y_i,F_{m-1}(x_i)) + \\psi’’(y_i,F_{m-1}(x_i))*\\gamma_{mj}}\\end{aligned}$$ 上面泰勒展开式中有损失函数的一阶导数和二阶导数,所以: 对损失函数求导(一阶导数): $$\\begin{aligned}\\psi’(y, F(x)) &amp;=(-yF(x)+log(exp(F(x))+1))’\\\\&amp;=-y+\\frac{1}{exp(F(x))+1)}\\times (exp(F(x)))’\\\\&amp;注释: (e^x)’ = e^x\\\\&amp;=-y+\\frac{1}{exp(F(x))+1)}\\times (exp(F(x)))\\\\&amp;=-y+\\frac{exp(F(x))}{exp(F(x))+1)}\\\\&amp;注释: 分子分母同时除以exp(F(x))\\\\&amp;=-y+\\frac{1}{1+exp(-F(x))}\\\\&amp;注释: sigmoid函数可以用\\sigma表示\\\\&amp;=-y+\\sigma(F(x))\\end{aligned}$$2. 对损失函数求导(二阶导数): $$\\begin{aligned}(\\psi’(y, F(x)))’ &amp;=(-y+\\frac{1}{1+exp(-F(x))})’\\\\&amp;=[(1+exp(-F(x)))^{-1}]’\\\\&amp;=-[1+exp(-F(x))]^{-2}\\times exp(-F(x))\\times [-F(x)]’\\\\&amp;=-\\frac{1}{[1+exp(-F(x))]^{2}}\\times exp(-F(x))\\times (-1)\\\\&amp;=\\frac{1}{1+exp(-F(x))}\\times \\frac{exp(-F(x))}{1+exp(-F(x))}\\\\&amp;=\\frac{1}{1+exp(-F(x))}\\times \\frac{exp(-F(x))+1-1}{1+exp(-F(x))}\\\\&amp;=\\frac{1}{1+exp(-F(x))}\\times (1-\\frac{1}{1+exp(-F(x))})\\\\&amp;=\\sigma(F(x))\\times (1-\\sigma(F(x)))\\\\\\end{aligned}$$ 此时令: $$\\widetilde{y} = y-\\frac{1}{1+exp(-F(x))}$$ 则损失函数的一阶导数为: $$\\psi’(y,F(x)) = -y + \\frac{1}{1 + exp(-F(x))} = -\\widetilde{y}$$ 损失函数的二阶导数为: $$\\psi’’(y,F(x)) =\\frac{1}{1+exp(-F(x))}\\times (1-\\frac{1}{1+exp(-F(x))})=(y - \\widetilde{y})(1 - y + \\widetilde{y})$$ 令导数为0, 并将损失函数的一阶导数和二阶导数带进去, 求$\\gamma_{mj}$的最优函数:$$0 = \\sum_{x_i \\in R_{mj}}{\\psi’(y_i,F_{m-1}(x_i)) + \\psi’’(y_i,F_{m-1}(x_i)) · \\gamma_{mj}} \\\\0 = \\sum_{x_i \\in R_{mj}}{-\\widetilde{y_i} + (y_i - \\widetilde{y_i})(1 - y_i + \\widetilde{y_i}) · \\gamma_{mj}} \\\\$$ $$\\sum_{x_i \\in R_{mj}}\\widetilde{y_i} = \\sum_{x_i \\in R_{mj}}(y_i - \\widetilde{y_i})(1 - y_i + \\widetilde{y_i}) *\\gamma_{mj}$$ $$\\sum_{x_i \\in R_{mj}}\\widetilde{y_i} = (\\sum_{x_i \\in R_{mj}}(y_i - \\widetilde{y_i})(1 - y_i + \\widetilde{y_i}) )*\\gamma_{mj}$$ 4): 求初始值$$\\begin{aligned}F_0(x) &amp;= argmin_{\\rho}\\sum_{i=1}^N \\psi(y_i, \\rho)\\\\&amp;=argmin_{\\rho}H(\\rho) = -\\sum\\limits_{i=1}^N(y_i\\rho -log(1 + exp(\\rho)))\\end{aligned}$$ 此时$F_0(x)$为$H(\\rho)$的最小值, 当$H(\\rho)$的导数为零时$F_0(x)$取最小值, 也就是$\\rho$取得最小值,即为初始值 对$H(\\rho)$求导$$H’(\\rho) = -\\sum\\limits_{i = 1}^N(y_i - \\frac{1}{1 + exp(-\\rho)})$$令$$H’(\\rho) = 0$$ ,求$\\rho$$$0 = -\\sum\\limits_{i = 1}^N(y_i -\\frac{1}{1 + exp(-\\rho)})\\\\0 = \\sum\\limits_{i = 1}^N(y_i -\\frac{1}{1 + exp(-\\rho)})\\\\\\sum\\limits_{i=1}^Ny_i = \\sum\\limits_{i=1}^N\\frac{1}{1+exp(-\\rho)}\\\\\\sum\\limits_{i=1}^Ny_i = \\frac{N}{1+exp(-\\rho)}\\\\求倒数\\\\\\frac{(1 + exp(-\\rho))}{N} = \\frac{1}{\\sum\\limits_{i=1}^Ny_i}\\\\1 + exp(-\\rho) = \\frac{N}{\\sum\\limits_{i=1}^Ny_i}\\\\1 + exp(-\\rho) = \\frac{\\sum\\limits_{i=1}^N1}{\\sum\\limits_{i=1}^Ny_i}\\\\exp(-\\rho) = \\frac{\\sum\\limits_{i=1}^N1}{\\sum\\limits_{i=1}^Ny_i} - 1\\\\exp(-\\rho) = \\frac{\\sum\\limits_{i=1}^N(1 -y_i)}{\\sum\\limits_{i=1}^Ny_i}\\\\对数运算\\\\-\\rho = log\\frac{\\sum\\limits_{i=1}^N(1 -y_i)}{\\sum\\limits_{i=1}^Ny_i}\\\\\\rho = log\\frac{\\sum\\limits_{i=1}^Ny_i}{\\sum\\limits_{i=1}^N(1 -y_i)}$$ 5): 最强学习器根据:$$F_m(x) = F_0 + \\alpha_1 F_1(x) + \\alpha_2 F_2(x)+… + \\alpha_m F_m(x)$$其中:$$F_n(x) = F_{n-1}(x) + \\gamma_n*learning_rate$$而此时初始值:$$F_0 =\\rho = log\\frac{\\sum\\limits_{i=1}^Ny_i}{\\sum\\limits_{i=1}^N(1 -y_i)}$$$\\gamma$的值为:$$\\gamma_{mj} = \\frac{\\sum_{x_i \\in R_{mj}}\\widetilde{y_i}}{\\sum_{x_i \\in R_{mj}}(y_i - \\widetilde{y_i})(1 - y_i + \\widetilde{y_i})}$$$learning_rate$ 的值为模型参数, 经过足够多的学习次数, 最终能得出一个最优学习器$F_m(x)$ 6): 代码实现梯度提升分类树代码实现和模型调用进行对比 ①: 模型调用(二分类结果)12345678910111213141516171819202122232425262728import numpy as npfrom sklearn.ensemble import GradientBoostingClassifierfrom sklearn import tree# 构造数据X = np.arange(1,11).reshape(-1,1)y = np.array([0,0,0,1,1]*2)# 定义算法# 默认情况下，损失函数就是Log-loss == 交叉熵！clf = GradientBoostingClassifier(n_estimators=100,learning_rate=0.1,max_depth=1)clf.fit(X,y)y_ = clf.predict(X)print('真实的类别：',y)print('算法的预测：',y_)'''真实的类别： [0 0 0 1 1 0 0 0 1 1]算法的预测： [0 0 0 1 1 0 0 0 1 1]'''# 绘制决策树# 第一棵树_ = tree.plot_tree(clf[0,0],filled=True)# 第二棵树_ = tree.plot_tree(clf[1,0],filled=True)# 第三棵树_ = tree.plot_tree(clf[2,0],filled=True) ②: 代码实现(二分类结果)12345678import numpy as npfrom sklearn.ensemble import GradientBoostingClassifierfrom sklearn import tree# 构造数据X = np.arange(1,11).reshape(-1,1)y = np.array([0,0,0,1,1]*2) 计算初始值:$$F_0 =\\rho = log\\frac{\\sum\\limits_{i=1}^Ny_i}{\\sum\\limits_{i=1}^N(1 -y_i)}$$此处$y_i$表示类别, 其值为1(1表示true) 123456# 二分类问题，类别 ：0,1# [0 0 0 1 1 0 0 0 1 1]F0 = np.log(4/6)'''-0.40546510810816444''' 计算$$\\widetilde{y}$$ 导数就是梯度，负梯度$$\\widetilde{y} = y - \\frac{1}{1+exp(-F(x))} = -\\psi’(y,F(x))\\\\\\psi’(y,F(x)) = -y + \\frac{1}{1 + exp(-F(x))}$$ 12345# 函数F(X) 初始值F0的负梯度yderivative0 = y - 1/(1 + np.exp(-F0))'''array([-0.4, -0.4, -0.4, 0.6, 0.6, -0.4, -0.4, -0.4, 0.6, 0.6])''' 拟合第一棵树: 123456789101112131415161718192021222324# 分裂标准 msefor i in range(1,11): if i ==10: mse = ((yderivative0 - yderivative0.mean())**2).mean() else: left_mse = ((yderivative0[:i] - yderivative0[:i].mean())**2).mean() right_mse = ((yderivative0[i:] - yderivative0[i:].mean())**2).mean() mse = left_mse*i/10 + right_mse*(10-i)/10 print('从第%d个进行切分'%(i),np.round(mse,4))# 从第八个样本这里进行分类，最优的选择，和算法第一颗画图的结果一致'''从第1个进行切分 0.2222从第2个进行切分 0.2从第3个进行切分 0.1714从第4个进行切分 0.225从第5个进行切分 0.24从第6个进行切分 0.2333从第7个进行切分 0.2095从第8个进行切分 0.15从第9个进行切分 0.2从第10个进行切分 0.24''' 计算左、右两侧叶子的预测值:$$\\gamma_{mj} = \\frac{\\sum_{x_i \\in R_{mj}}\\widetilde{y_i}}{\\sum_{x_i \\in R_{mj}}(y_i - \\widetilde{y_i})(1 - y_i + \\widetilde{y_i})}$$ 12345678910111213# 左边分支gamma1 = np.round(yderivative0[:8].sum()/((y[:8] - yderivative0[:8])*(1 - y[:8] + yderivative0[:8])).sum(),3)print('左边决策树分支，预测值：',gamma1)'''左边决策树分支，预测值： -0.625'''# 右边分支gamma2 =np.round(yderivative0[8:].sum()/((y[8:] - yderivative0[8:])*(1 - y[8:] + yderivative0[8:])).sum(),3)print('右边决策树分支，预测值：',gamma2)'''右边决策树分支，预测值： 2.5''' 第一棵树拟合完毕, 代码实现的，和算法中的第一颗树（画图显示），完全一样 以此类推实现第二棵树: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 拟合第二颗树# 第一颗预测的结果gamma = np.array([-0.625]*8 + [2.5]*2)'''array([-0.625, -0.625, -0.625, -0.625, -0.625, -0.625, -0.625, -0.625, 2.5 , 2.5 ])'''# F(x) 随着梯度提升树，提升，发生变化learning_rate = 0.1F1 =np.round( F0 + gamma*learning_rate,4) #保留4位小数'''array([-0.468 , -0.468 , -0.468 , -0.468 , -0.468 , -0.468 , -0.468 , -0.468 , -0.1555, -0.1555])'''# 计算F1(x)的负梯度yderivative1 = np.round(y - 1/(1 + np.exp(-F1)),4)'''array([-0.3851, -0.3851, -0.3851, 0.6149, 0.6149, -0.3851, -0.3851, -0.3851, 0.5388, 0.5388])'''# 第二颗树分裂标准 msefor i in range(1,11): if i ==10: mse = ((yderivative1 - yderivative1.mean())**2).mean() else: left_mse = ((yderivative1[:i] - yderivative1[:i].mean())**2).mean() right_mse = ((yderivative1[i:] - yderivative1[i:].mean())**2).mean() mse = left_mse*i/10 + right_mse*(10-i)/10 print('从第%d个进行切分'%(i),np.round(mse,4))# 第二棵树也是从第八个样本这里进行分类，最优的选择，和算法第二颗画图的结果一致# 左边分支gamma1 = np.round(yderivative1[:8].sum()/((y[:8] - yderivative1[:8])*(1 - y[:8] + yderivative1[:8])).sum(),3)print('第二棵树左边决策树分支，预测值：',gamma1)# 右边分支gamma2 =np.round(yderivative1[8:].sum()/((y[8:] - yderivative1[8:])*(1 - y[8:] + yderivative1[8:])).sum(),3)print('第二棵树右边决策树分支，预测值：',gamma2)'''第二棵树左边决策树分支，预测值： -0.571第二棵树右边决策树分支，预测值： 2.168''' 第三棵树: 123456789101112131415161718192021222324252627282930313233# 第二棵树预测值gamma = np.array([-0.571]*8 + [2.168]*2)# F(x) 随着梯度提升树，提升，发生变化learning_rate = 0.1F2 =np.round( F1 + gamma*learning_rate,4) #保留4位小数# 计算F2(x)的负梯度yderivative2 = np.round(y - 1/(1 + np.exp(-F2)),4)# 第三颗树分裂标准 msefor i in range(1,11): if i ==10: mse = ((yderivative2 - yderivative2.mean())**2).mean() else: left_mse = ((yderivative2[:i] - yderivative2[:i].mean())**2).mean() right_mse = ((yderivative2[i:] - yderivative2[i:].mean())**2).mean() mse = left_mse*i/10 + right_mse*(10-i)/10 print('从第%d个进行切分'%(i),np.round(mse,4))# 第三棵树从第三个样本这里进行裂分，最优的选择，和算法第三颗画图的结果一致# 计算第三颗树的预测值# 前三个是一类# 后七个是一类# 左边分支gamma1 = np.round(yderivative2[:3].sum()/((y[:3] - yderivative2[:3])*(1 - y[:3] + yderivative2[:3])).sum(),3)print('第三棵树左边决策树分支，预测值：',gamma1)# 右边分支gamma2 =np.round(yderivative2[3:].sum()/((y[3:] - yderivative2[3:])*(1 - y[3:] + yderivative2[3:])).sum(),3)print('第三棵树右边决策树分支，预测值：',gamma2)'''第三棵树左边决策树分支，预测值： -1.592第三棵树右边决策树分支，预测值： 0.666''' 最后将最后一棵树的结果通过sigmoid函数转换乘概率:$$p = \\frac{1}{1 + exp(-F(x))}$$ 123456789101112131415# 计算第三颗的F3(x)# 第三颗树预测值gamma = np.array([-1.592]*3 + [0.666]*7)# F(x) 随着梯度提升树，提升，发生变化learning_rate = 0.1F3 =np.round( F2 + gamma*learning_rate,4) #保留4位小数proba = 1/(1 + np.exp(-F3))# 类别：0,1，如果这个概率大于等于0.5类别1，小于0.5类别0(proba &gt;= 0.5).astype(np.int8)# 结果'''array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1], dtype=int8)''' 可见第三棵树的分类结果已经达到一定的准确率; 以此类推,只要循环的次数足够多, 就能达到和算法的分类结果相同(代码设置的树是100颗) 至此,完毕 3: 梯度提升树的优缺点优点 1) 可以灵活处理各种类型的数据，包括连续值和离散值。 2) 在相对少的调参时间情况下，预测的准确率也可以比较高。这个是相对SVM来说的。 3）使用一些健壮的损失函数，对异常值的鲁棒性非常强。比如 Huber损失函数和Quantile损失函数。 缺点 1)由于弱学习器之间存在依赖关系，难以并行训练数据。不过可以通过自采样的SGBT来达到部分并行。 4: 梯度提升树参数详解刘建平 - scikit-learn 梯度提升树(GBDT)调参小结 Surface 键盘耐脏又好擦？真的吗？ 六: XGboost在算法的弱学习器模型选择上，对比GBDT只支持决策树，还可以直接很多其他的弱学习器。 在算法的损失函数上，除了本身的损失，还加上了正则化部分。 在算法的优化方式上，GBDT的损失函数只对误差部分做负梯度（一阶泰勒）展开，而XGBoost损失函数对误差部分做二阶泰勒展开，更加准确","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"https://anjhon1994.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"集成算法","slug":"集成算法","permalink":"https://anjhon1994.github.io/tags/%E9%9B%86%E6%88%90%E7%AE%97%E6%B3%95/"},{"name":"Bagging","slug":"Bagging","permalink":"https://anjhon1994.github.io/tags/Bagging/"},{"name":"随机森林","slug":"随机森林","permalink":"https://anjhon1994.github.io/tags/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"},{"name":"Boosting","slug":"Boosting","permalink":"https://anjhon1994.github.io/tags/Boosting/"},{"name":"AdaBoost","slug":"AdaBoost","permalink":"https://anjhon1994.github.io/tags/AdaBoost/"},{"name":"GBDT","slug":"GBDT","permalink":"https://anjhon1994.github.io/tags/GBDT/"}]},{"title":"聚类","slug":"机器学习/聚类","date":"2020-03-31T16:00:00.000Z","updated":"2021-01-17T04:48:10.594Z","comments":true,"path":"2020/04/01/机器学习/聚类/","link":"","permalink":"https://anjhon1994.github.io/2020/04/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%81%9A%E7%B1%BB/","excerpt":"","text":"一: 聚类(一): 概述聚类算法 是机器学习（Mahine Learning）的一种，属于无监督学习（Unsupervised Learning），即数据样本没有数据标签。它的目的是将数据中具有相似特征的数据自动聚为一类。 分类简单来说，就是根据文本的特征或属性，划分到已有的类别中。也就是说，这些类别是已知的，通过对已知分类的数据进行训练和学习，找到这些不同类的特征，再对未分类的数据进行分类。 而聚类的理解更简单，就是你压根不知道数据会分为几类，通过聚类分析将数据或者说用户聚合成几个群体，那就是聚类了。聚类不需要对数据进行训练和学习。 (二): 聚类算法聚类分析的八类方法 划分方法1）K-Means聚类2）K-Medoids聚类3）CLARANS算法4）Canopy算法 层次方法1）BIRCH算法 基于密度的方法1）DBSCAN算法 二: K-Means聚类(一): 原理K-Means算法的思想很简单，对于给定的样本集，按照样本之间的距离大小，将样本集划分为K个簇。让簇内的点尽量紧密的连在一起，而让簇间的距离尽量的大。 举一个简单得例子: 上图a表达了初始的数据集，假设k=2。在图b中，我们随机选择了两个k类所对应的类别质心，即图中的红色质心和蓝色质心，然后分别求样本中所有点到这两个质心的距离，并标记每个样本的类别为该样本距离最小的质心的类别，如图c所示，经过计算样本和红色质心和蓝色质心的距离，我们得到了所有样本点的第一轮迭代后的类别。此时我们对我们当前标记为红色和蓝色的点分别求其新的质心，如图d所示，新的红色质心和蓝色质心的位置已经发生了变动。图e和图f重复了我们在图c和图d的过程，即将所有点的类别标记为距离最近的质心的类别并求新的质心。最终我们得到的两个类别如图f。 (二):K值的选择不像监督学习的分类问题和回归问题，我们的无监督聚类没有样本输出，也就没有比较直接的聚类评估方法。但是我们可以从簇内的稠密程度和簇间的离散程度来评估聚类的效果。 常用的方法有轮廓系数(Silhouette Coefficient), 调整兰德系数(Adjusted Rand index)和CH指标分析(Calinski-Harabasz Index) 在sklearn中轮廓系数对应的方法是: silhouette_score(X,y_) 在sklearn中调整兰德系数对应的方法是: adjusted_rand_score(y,y_) Calinski-Harabasz分数值s的数学计算公式是： $$s(k)=\\frac{tr(Bk)}{tr(Wk)}\\frac{m−k}{k−1}$$ 其中m为训练集样本数，k为类别数。Bk为类别之间的协方差矩阵，Wk为类别内部数据的协方差矩阵。tr为矩阵的迹。 也就是说，类别内部数据的协方差越小越好，类别之间的协方差越大越好，这样的Calinski-Harabasz分数会高。在scikit-learn中， Calinski-Harabasz Index对应的方法是metrics.calinski_harabaz_score. (三): 参数详解用KMeans类的话，一般要注意的仅仅就是k值的选择，即参数n_clusters； KMeans类的主要参数有： 1) n_clusters: 即我们的k值，一般需要多试一些值以获得较好的聚类效果。k值好坏的评估标准在下面会讲。 2）max_iter： 最大的迭代次数，一般如果是凸数据集的话可以不管这个值，如果数据集不是凸的，可能很难收敛，此时可以指定最大的迭代次数让算法可以及时退出循环。 3）n_init：用不同的初始化质心运行算法的次数。由于K-Means是结果受初始值影响的局部最优的迭代算法，因此需要多跑几次以选择一个较好的聚类效果，默认是10，一般不需要改。如果你的k值较大，则可以适当增大这个值。 4）init： 即初始值选择的方式，可以为完全随机选择’random’,优化过的’k-means++’或者自己指定初始化的k个质心。一般建议使用默认的’k-means++’。 5）algorithm：有“auto”, “full” or “elkan”三种选择。”full”就是我们传统的K-Means算法， “elkan”是我们原理篇讲的elkan K-Means算法。默认的”auto”则会根据数据值是否是稀疏的，来决定如何选择”full”和“elkan”。一般数据是稠密的，那么就是 “elkan”，否则就是”full”。一般来说建议直接用默认的”auto” 用scikit-learn学习K-Means聚类 - 刘建平 三: DBSCAN聚类(一): 原理DBSCAN是一种基于密度的聚类算法，这类密度聚类算法一般假定类别可以通过样本分布的紧密程度决定。同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。 通过将紧密相连的样本划为一类，这样就得到了一个聚类类别。通过将所有各组紧密相连的样本划为各个不同的类别，则我们就得到了最终的所有聚类类别结果。 DBSCAN是基于一组邻域来描述样本集的紧密程度的，参数(ϵ, MinPts)用来描述邻域的样本分布紧密程度。其中，ϵ描述了某一样本的邻域距离阈值，MinPts描述了某一样本的距离为ϵϵ的邻域中样本个数的阈值。 直白了说就是刚开始随机某个点, 以ϵ为半径画圆, 只要在该圆的范围内的点都会被归纳到相同的类别中, 但是若权重的点的总数没有达到设置的阈值MinPts,则不能形成聚类 (二): 总结和传统的K-Means算法相比，DBSCAN最大的不同就是不需要输入类别数k，当然它最大的优势是可以发现任意形状的聚类簇，而不是像K-Means，一般仅仅使用于凸的样本集聚类。同时它在聚类的同时还可以找出异常点，这点和BIRCH算法类似。 那么我们什么时候需要用DBSCAN来聚类呢？一般来说，如果数据集是稠密的，并且数据集不是凸的，那么用DBSCAN会比K-Means聚类效果好很多。如果数据集不是稠密的，则不推荐用DBSCAN来聚类。 下面对DBSCAN算法的优缺点做一个总结。 DBSCAN的主要优点有： 1） 可以对任意形状的稠密数据集进行聚类，相对的，K-Means之类的聚类算法一般只适用于凸数据集。 2） 可以在聚类的同时发现异常点，对数据集中的异常点不敏感。 3） 聚类结果没有偏倚，相对的，K-Means之类的聚类算法初始值对聚类结果有很大影响。 DBSCAN的主要缺点有： 1）如果样本集的密度不均匀、聚类间距差相差很大时，聚类质量较差，这时用DBSCAN聚类一般不适合。 2） 如果样本集较大时，聚类收敛时间较长，此时可以对搜索最近邻时建立的KD树或者球树进行规模限制来改进。 3） 调参相对于传统的K-Means之类的聚类算法稍复杂，主要需要对距离阈值ϵϵ，邻域样本数阈值MinPts联合调参，不同的参数组合对最后的聚类效果有较大影响。 DBSCAN密度聚类算法 - 刘建平 (三): 参数详解DBSCAN类的重要参数也分为两类，一类是DBSCAN算法本身的参数，一类是最近邻度量的参数，下面我们对这些参数做一个总结。 1）eps： DBSCAN算法参数，即我们的ϵϵ-邻域的距离阈值，和样本距离超过ϵϵ的样本点不在ϵϵ-邻域内。默认值是0.5.一般需要通过在多组值里面选择一个合适的阈值。eps过大，则更多的点会落在核心对象的ϵϵ-邻域，此时我们的类别数可能会减少， 本来不应该是一类的样本也会被划为一类。反之则类别数可能会增大，本来是一类的样本却被划分开。 2）min_samples： DBSCAN算法参数，即样本点要成为核心对象所需要的ϵϵ-邻域的样本数阈值。默认值是5. 一般需要通过在多组值里面选择一个合适的阈值。通常和eps一起调参。在eps一定的情况下，min_samples过大，则核心对象会过少，此时簇内部分本来是一类的样本可能会被标为噪音点，类别数也会变多。反之min_samples过小的话，则会产生大量的核心对象，可能会导致类别数过少。 用scikit-learn学习DBSCAN聚类 - 刘建平 (四): 实例12345678910111213141516171819202122232425import warningswarnings.filterwarnings('ignore')import numpy as npfrom sklearn import datasetsfrom sklearn.cluster import KMeans,DBSCANimport matplotlib.pyplot as plt# 创建数据# y中是两类：0,1X,y = datasets.make_circles(n_samples=1000,noise=0.05,factor = 0.5)# centers = [(1.5,1.5)] 元组，代表着，中心点的坐标值# y1一类：0 + 2X1,y1 = datasets.make_blobs(n_samples=500,n_features=2,centers=[(1.5,1.5)],cluster_std=0.2)# 将circle和散点进行了数据合并X = np.concatenate([X,X1])y = np.concatenate([y,y1 + 2])plt.scatter(X[:,0],X[:,1],c = y)# DBSCAN聚类dbscan = DBSCAN(eps = 0.2,min_samples=5)dbscan.fit(X)y_ = dbscan.labels_plt.scatter(X[:,0],X[:,1],c = y_) 四: BIRCH聚类BIRCH聚类算法是用层次方法来聚类和规约数据的,. (一): 聚类特征数BIRCH聚类算法的主要过程其实就是在构建一颗CF tree(聚类特征数); 这颗树的每一个节点是由若干个聚类特征(Clustering Feature，简称CF)组成。从下图我们可以看看聚类特征树是什么样子的：每个节点包括叶子节点都有若干个CF，而内部节点的CF有指向孩子节点的指针，所有的叶子节点用一个双向链表链接起来。 CF有一个很好的性质，就是满足线性关系，也就是CF1+CF2=(N1+N2,LS1+LS2,SS1+SS2)CF1+CF2=(N1+N2,LS1+LS2,SS1+SS2)。这个性质从定义也很好理解。如果把这个性质放在CF Tree上，也就是说，在CF Tree中，对于每个父节点中的CF节点，它的(N,LS,SS)三元组的值等于这个CF节点所指向的所有子节点的三元组之和。如下图所示： 从上图中可以看出，根节点的CF1的三元组的值，可以从它指向的6个子节点（CF7 - CF12）的值相加得到。这样我们在更新CF Tree的时候，可以很高效。 对于CF Tree，我们一般有几个重要参数，第一个参数是每个内部节点的最大CF数B，第二个参数是每个叶子节点的最大CF数L，第三个参数是针对叶子节点中某个CF中的样本点来说的，它是叶节点每个CF的最大样本半径阈值T，也就是说，在这个CF中的所有样本点一定要在半径小于T的一个超球体内。对于上图中的CF Tree，限定了B=7， L=5， 也就是说内部节点最多有7个CF，而叶子节点最多有5个CF。 (二): BIRCH聚类原理在最开始的时候，CF Tree是空的，没有任何样本，我们从训练集读入第一个样本点，将它放入一个新的CF三元组A，这个三元组的N=1，将这个新的CF放入根节点 继续读入第二个样本点，我们发现这个样本点和第一个样本点A，在半径为T的超球体范围内，也就是说，他们属于一个CF，我们将第二个点也加入CF A,此时需要更新A的三元组的值。 此时来了第三个节点，结果我们发现这个节点不能融入刚才前面的节点形成的超球体内，也就是说，我们需要一个新的CF三元组B，来容纳这个新的值。此时根节点有两个CF三元组A和B BIRCH聚类和K-Mean聚类的区别就是是否有连通性约束 总结: 从根节点向下寻找和新样本距离最近的叶子节点和叶子节点里最近的CF节点 如果新样本加入后，这个CF节点对应的超球体半径仍然满足小于阈值T，则更新路径上所有的CF三元组，插入结束。否则转入3. 如果当前叶子节点的CF节点个数小于阈值L，则创建一个新的CF节点，放入新样本，将新的CF节点放入这个叶子节点，更新路径上所有的CF三元组，插入结束。否则转入4。 将当前叶子节点划分为两个新叶子节点，选择旧叶子节点中所有CF元组里超球体距离最远的两个CF元组，分布作为两个新叶子节点的第一个CF节点。将其他元组和新样本元组按照距离远近原则放入对应的叶子节点。依次向上检查父节点是否也要分裂，如果需要按和叶子节点分裂方式相同。 (三): 算法小结BIRCH算法可以不用输入类别数K值，这点和K-Means，Mini Batch K-Means不同。如果不输入K值，则最后的CF元组的组数即为最终的K，否则会按照输入的K值对CF元组按距离大小进行合并。 一般来说，BIRCH算法适用于样本量较大的情况，这点和Mini Batch K-Means类似，但是BIRCH适用于类别数比较大的情况，而Mini Batch K-Means一般用于类别数适中或者较少的时候。BIRCH除了聚类还可以额外做一些异常点检测和数据初步按类别规约的预处理。但是如果数据特征的维度非常大，比如大于20，则BIRCH不太适合，此时Mini Batch K-Means的表现较好。 对于调参，BIRCH要比K-Means，Mini Batch K-Means复杂，因为它需要对CF Tree的几个关键的参数进行调参，这几个参数对CF Tree的最终形式影响很大。 最后总结下BIRCH算法的优缺点： BIRCH算法的主要优点有： 1) 节约内存，所有的样本都在磁盘上，CF Tree仅仅存了CF节点和对应的指针。 2) 聚类速度快，只需要一遍扫描训练集就可以建立CF Tree，CF Tree的增删改都很快。 3) 可以识别噪音点，还可以对数据集进行初步分类的预处理 BIRCH算法的主要缺点有： 1) 由于CF Tree对每个节点的CF个数有限制，导致聚类的结果可能和真实的类别分布不同. 2) 对高维特征的数据聚类效果不好。此时可以选择Mini Batch K-Means 3) 如果数据集的分布簇不是类似于超球体，或者说不是凸的，则聚类效果不好。 (四): 参数详解1) threshold:即叶节点每个CF的最大样本半径阈值T，它决定了每个CF里所有样本形成的超球体的半径阈值。一般来说threshold越小，则CF Tree的建立阶段的规模会越大，即BIRCH算法第一阶段所花的时间和内存会越多。但是选择多大以达到聚类效果则需要通过调参决定。默认值是0.5.如果样本的方差较大，则一般需要增大这个默认值。 2) branching_factor：即CF Tree内部节点的最大CF数B，以及叶子节点的最大CF数L。这里scikit-learn对这两个参数进行了统一取值。也就是说，branching_factor决定了CF Tree里所有节点的最大CF数。默认是50。如果样本量非常大，比如大于10万，则一般需要增大这个默认值。选择多大的branching_factor以达到聚类效果则需要通过和threshold一起调参决定 3）n_clusters：即类别数K，在BIRCH算法是可选的，如果类别数非常多，我们也没有先验知识，则一般输入None，此时BIRCH算法第4阶段不会运行。但是如果我们有类别的先验知识，则推荐输入这个可选的类别值。默认是3，即最终聚为3类。 4）compute_labels：布尔值，表示是否标示类别输出，默认是True。一般使用默认值挺好，这样可以看到聚类效果。 掌握Python编程语言,能使用Numpy,Pandas,Matplotlib,sklearn等第三方库进行数据清洗, 数据分析, 数据可视化; 掌握SQL语言,能在Python及MySQL环境下熟练使用SQL语句进行操作; 熟悉tableau,Excel(熟悉使用内置函数, 数据透视表); 熟悉常用的机器学习算法,包括: 线性回归,逻辑回归,KNN,决策树,随机森林,朴素贝叶斯,支持向量机,K-means,等; 熟悉Linux开发环境, 熟悉Git团队协作开发; 熟悉常规的深度神经网络(RNN, CNN, LSTM)原理及主流框架TensorFlow的使用 目前人在成都。有扎实的计算机和统计学基础，近2.5年数据分析实战经验，善于用数据化的思维驱动相关工作。熟练使用Excel和Python语言，熟悉数据可视化和数据挖掘相关方法，擅长Pandas、Seaborn、ScikitLearn等工具，擅长数据分析报告的撰写，较强的自我学习能力和自我驱动能力，善于总结和归纳。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"https://anjhon1994.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"聚类","slug":"聚类","permalink":"https://anjhon1994.github.io/tags/%E8%81%9A%E7%B1%BB/"}]},{"title":"决策树","slug":"机器学习/决策树算法","date":"2020-03-19T16:00:00.000Z","updated":"2021-01-17T04:33:19.470Z","comments":true,"path":"2020/03/20/机器学习/决策树算法/","link":"","permalink":"https://anjhon1994.github.io/2020/03/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/","excerpt":"","text":"一: 概述决策树是附加概率结果的一个树状的决策图，是直观的运用统计概率分析的图法。决策树算法采用树形结构，使用层层推理来实现最终的分类。 决策树的结构: 根节点：包含样本的全集 内部节点：对应特征属性测试 叶节点：代表决策的结果 预测时，在树的内部节点处用某一属性值进行判断，根据判断结果决定进入哪个分支节点，直到到达叶节点处，得到分类结果。 二: 决策树算法决策树算法中有三种基本算法: ID3算法,C4.5算法,CART算法(在sklearn中默认是使用CART算法); (一): ID3算法ID3算法用信息增益来作为特征选择标准 对熵这个概念还不是很熟悉的童鞋可以借鉴一下CyberRep在知乎的回答 信息熵表示的是不确定度。均匀分布时，不确定度最大，此时熵就最大。当选择某个特征对数据集进行分类时，分类后的数据集信息熵会比分类前的小，其差值表示为信息增益。信息增益可以衡量某个特征对分类结果的影响大小。 衡量熵值的两个公式: 1: 信息熵公式:$$H(X) = -\\sum\\limits_{i=1}^n p_ilog_2p_i$$ $$H(X) = \\sum\\limits_{i=1}^n p_ilog_2 \\frac{1}{p_i}$$ 联合熵:$$H(X,Y)=−\\sum_{i=1}^np(x_i,y_i)logp(x_i,y_i)$$条件熵: 它度量了我们的X在知道Y以后剩下的不确定性$$H(X|Y)=−\\sum_{i=1}^np(x_i,y_i)logp(x_i|y_i)=\\sum_{j=1}^np(y_j)H(X|y_j)$$用目标值的信息熵 减去 知道属性比例后的目标值 的信息熵 信息增益:$$H(X) - H(X|Y)$$ ID3算法的不足: 第一: 不能处理连续特征 第二: 用信息增益作为标准容易偏向于取值较多的特征 第三: 缺失值处理的问和过拟合问题 举个栗子: 如下图, 三个属性:日志密度, 好友密度, 头像是否真实, 判断账号是否真实 12345678910111213141516171819202122232425262728293031323334353637383940import numpy as np# 计算最后一栏的熵值(暂时不考虑属性的影响 - 期望信息)# 3个no,7个yes; H1 = -(0.3*np.log2(0.3)+0.7*np.log2(0.7))H1'''0.8812908992306927'''# 计算日志密度对期望信息的熵值'''s -&gt; 个数3 -&gt; 概率0.3 -&gt; 2个no,1个yes m -&gt; 个数4 -&gt; 概率0.4 -&gt; 1个no,3个yes i -&gt; 个数3 -&gt; 概率0.3 -&gt; 3个yes '''H2 = (0.3*(2/3*np.log2(3/2)+1/3*np.log2(3))) + (0.4*(1/4*np.log2(4)+3/4*np.log2(4/3))) + (0.3*np.log2(1))print(H2)print('信息增益:', H1-H2)'''0.5999999999999999信息增益: 0.28129089923069284'''# 计算好友密度对期望信息的熵值'''s -&gt; 个数4 -&gt; 概率0.4 -&gt; 3个no,1个yes m -&gt; 个数4 -&gt; 概率0.4 -&gt; 4个yes i -&gt; 个数2 -&gt; 概率0.2 -&gt; 2个yes '''H3 = (0.4*(3/4*np.log2(4/3)+1/4*np.log2(4))) + (0.4*np.log2(1)) + (0.2*np.log2(1))print(H3)print('信息增益:', H1-H3)'''0.32451124978365314信息增益: 0.5567796494470396''' 通过以上例子可以看出: 好友密度的信息增益比日志密度的信息增益大, 所以好友密度这一属性更适合作为根节点 (二): C4.5算法C4.5算法用信息增益比来作为特征选择标准$$I_R(D,A)=\\frac{I(A,D)}{H_A(D)}$$I(A,D)是信息增益, $H_A(D)$是特征熵$$H_A(D)=−\\sum_{i=1}^n\\frac{|D_i|}{|D|}log2\\frac{|D_i|}{|D|}$$其中n为特征A的类别数， Di为特征A的第i个取值对应的样本个数。|D|为样本个数。 C4.5算法的不足: 模型是用较为复杂的熵来度量 使用了相对较为复杂的多叉树 只能处理分类不能处理回归等 (三): CART算法CART分类树算法使用基尼系数来代替信息增益比，基尼系数代表了模型的不纯度，基尼系数越小，则不纯度越低，特征越好。 具体的，在分类问题中，假设有K个类别，第k个类别的概率为$p_i$, 则基尼系数的表达式为：$$gini = \\sum\\limits_{i = 1}^np_i(1 - p_i)$$ 对于个给定的样本D,假设有K个类别, 第k个类别的数量为$C_k$,则样本D的基尼系数表达式为：$$Gini(D)=1−\\sum_{k=1}^K(\\frac{|C_k|}{|D|})^2$$ 算法 支持模型 树结构 特征选择 连续值处理 缺失值处理 剪枝 ID3 分类 多叉树 信息增益 不支持 不支持 不支持 C4.5 分类 多叉树 信息增益比 支持 支持 支持 CART 分类，回归 二叉树 基尼系数，均方差 支持 支持 支持 三: 建立决策树(一): 特征选择特征选择决定了使用哪些特征来做判断。选择一个合适的特征作为判断节点，可以快速的分类，减少决策树的深度。决策树的目标就是把数据集按对应的类标签进行分类。 在训练数据集中，每个样本的属性可能有很多个，不同属性的作用有大有小。因而特征选择的作用就是筛选出跟分类结果相关性较高的特征，也就是分类能力较强的特征。 (二): 决策树的生成选择好特征后，就从根节点触发，对节点计算所有特征的信息增益，选择信息增益最大的特征作为节点特征，根据该特征的不同取值建立子节点；对每个子节点使用相同的方式生成新的子节点，直到信息增益很小或者没有特征可以选择为止。 (三): 决策树的修剪决策树生成算法递归地产生决策树，直到不能继续下去未为止。这样产生的树往往对训练数据的分类很准确，但对未知的测试数据的分类却没有那么准确，即出现过拟合现象。过拟合的原因在于学习时过多地考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树。解决这个问题的办法是考虑决策树的复杂度，对已生成的决策树进行简化。 四: 决策树分类和回归 参数 DecisionTreeClassifier DecisionTreeRegressor 特征选择标准criterion 可以使用”gini”或者”entropy”，前者代表基尼系数，后者代表信息增益。一般说使用默认的基尼系数”gini”就可以了，即CART算法。除非你更喜欢类似ID3, C4.5的最优特征选择方法。 可以使用”mse”或者”mae”，前者是均方差，后者是和均值之差的绝对值之和。推荐使用默认的”mse”。一般来说”mse”比”mae”更加精确。除非你想比较二个参数的效果的不同之处。 特征划分点选择标准splitter 可以使用”best”或者”random”。前者在特征的所有划分点中找出最优的划分点。后者是随机的在部分划分点中找局部最优的划分点。默认的”best”适合样本量不大的时候，而如果样本数据量非常大，此时决策树构建推荐”random” 划分时考虑的最大特征数max_features 可以使用很多种类型的值，默认是”None”,意味着划分时考虑所有的特征数；如果是”log2”意味着划分时最多考虑log2Nlog2N个特征；如果是”sqrt”或者”auto”意味着划分时最多考虑N−−√N个特征。如果是整数，代表考虑的特征绝对数。如果是浮点数，代表考虑特征百分比，即考虑（百分比xN）取整后的特征数。其中N为样本总特征数。一般来说，如果样本特征数不多，比如小于50，我们用默认的”None”就可以了，如果特征数非常多，我们可以灵活使用刚才描述的其他取值来控制划分时考虑的最大特征数，以控制决策树的生成时间。 决策树最大深max_depth 决策树的最大深度，默认可以不输入，如果不输入的话，决策树在建立子树的时候不会限制子树的深度。一般来说，数据少或者特征少的时候可以不管这个值。如果模型样本量多，特征也多的情况下，推荐限制这个最大深度，具体的取值取决于数据的分布。常用的可以取值10-100之间。 内部节点再划分所需最小样本数min_samples_split 这个值限制了子树继续划分的条件，如果某节点的样本数少于min_samples_split，则不会继续再尝试选择最优特征来进行划分。 默认是2.如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。我之前的一个项目例子，有大概10万样本，建立决策树时，我选择了min_samples_split=10。可以作为参考。 叶子节点最少样本数min_samples_leaf 这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。 默认是1,可以输入最少的样本数的整数，或者最少样本数占样本总数的百分比。如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。之前的10万样本项目使用min_samples_leaf的值为5，仅供参考。 叶子节点最小的样本权重和min_weight_fraction_leaf 这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝。 默认是0，就是不考虑权重问题。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。 最大叶子节点数max_leaf_nodes 通过限制最大叶子节点数，可以防止过拟合，默认是”None”，即不限制最大的叶子节点数。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。如果特征不多，可以不考虑这个值，但是如果特征分成多的话，可以加以限制，具体的值可以通过交叉验证得到。 类别权重class_weight 指定样本各类别的的权重，主要是为了防止训练集某些类别的样本过多，导致训练的决策树过于偏向这些类别。这里可以自己指定各个样本的权重，或者用“balanced”，如果使用“balanced”，则算法会自己计算权重，样本量少的类别所对应的样本权重会高。当然，如果你的样本类别分布没有明显的偏倚，则可以不管这个参数，选择默认的”None” 不适用于回归树 节点划分最小不纯度min_impurity_split 这个值限制了决策树的增长，如果某节点的不纯度(基尼系数，信息增益，均方差，绝对差)小于这个阈值，则该节点不再生成子节点。即为叶子节点 。 数据是否预排序presort 这个值是布尔值，默认是False不排序。一般来说，如果样本量少或者限制了一个深度很小的决策树，设置为true可以让划分点选择更加快，决策树建立的更加快。如果样本量太大的话，反而没有什么好处。问题是样本量少的时候，我速度本来就不慢。所以这个值一般懒得理它就可以了。 五: 决策树应用(一): 葡萄酒分类123456789101112131415161718192021222324252627import numpy as npfrom sklearn import datasets, treefrom sklearn.linear_model import LogisticRegressionfrom sklearn.tree import DecisionTreeClassifierfrom sklearn.model_selection import train_test_splitimport matplotlib.pyplot as pltwine = datasets.load_wine()X = wine['data']y = wine['target']s1 = 0s2 = 0for i in range(300): X_train, X_test, y_train, y_test = train_test_split(X, y) model = DecisionTreeClassifier(max_depth=5) model.fit(X_train, y_train) s1 += model.score(X_train, y_train)/300 s2 += model.score(X_test, y_test)/300print('训练准确度:', s1)print('测试准确度:', s2)_ = tree.plot_tree(model, filled=True)'''训练准确度: 0.9989473684210486测试准确度: 0.9063703703703709''' (二): 决策树回归1234567891011121314151617181920212223import numpy as np from sklearn.tree import DecisionTreeRegressorfrom sklearn import datasets, treefrom sklearn.model_selection import train_test_splitfrom sklearn.linear_model import LinearRegressionimport matplotlib.pyplot as pltX = np.linspace(0,2*np.pi, 40).reshape(-1,1) # 将数据变为二维数据y = np.c_[np.sin(X), np.cos(X)] # 蒋两张数据组合X_test = np.linspace(0,2*np.pi, 187).reshape(-1,1)model = DecisionTreeRegressor(criterion='mse', max_depth=None) # 当max_depth=1, 画出来的图像只有两个点model.fit(X,y) # X有40个点y_ = model.predict(X_test) # X_test是187个点plt.figure(figsize=(3,3)) # 调节尺寸plt.scatter(y[:,0], y[:,1]) # 绘制散点图plt.figure(figsize=(12,12))_ = tree.plot_tree(model, filled=True) # 绘制决策树plt.savefig('./regrece.pdf', dpi=1024) # 保存决策树为pdf 借鉴文章 - 决策树算法原理(下) - 刘建平","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"https://anjhon1994.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"决策树","slug":"决策树","permalink":"https://anjhon1994.github.io/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"}]},{"title":"支持向量机（SVM）","slug":"机器学习/支持向量机","date":"2020-03-11T16:00:00.000Z","updated":"2021-01-17T04:27:49.374Z","comments":true,"path":"2020/03/12/机器学习/支持向量机/","link":"","permalink":"https://anjhon1994.github.io/2020/03/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/","excerpt":"","text":"一: SVM(支持向量机)概述先来一段维基百科的定义: 在机器学习中，支持向量机（英语：support vector machine，常简称为SVM，又名支持向量网络）是在分类与回归分析中分析数据的监督式学习模型与相关的学习算法。给定一组训练实例，每个训练实例被标记为属于两个类别中的一个或另一个，SVM训练算法创建一个将新的实例分配给两个类别之一的模型，使其成为非概率二元线性分类器。SVM模型是将实例表示为空间中的点，这样映射就使得单独类别的实例被尽可能宽的明显的间隔分开。然后，将新的实例映射到同一空间，并基于它们落在间隔的哪一侧来预测所属类别。 除了进行线性分类之外，SVM还可以使用所谓的核技巧有效地进行非线性分类，将其输入隐式映射到高维特征空间中。 二: SVM原理(一): 工作原理1: 硬间隔现在有两种类别的数据需要分类, 如下图: 要想将这两类数据分开, 可以说是轻而易举, 只需要这样: 但是这样分类的方式(线条)有很多, 而支持向量机这个算法是追求完美的, 他想要的效果不仅仅是将数据分开, 还要找到一个最佳的分类’位置’进行黄金分割, 就像这样: 每一个可能把数据集正确分开的方向都有一个最优决策面（有些方向无论如何移动决策面的位置也不可能将两类样本完全分开），而不同方向的最优决策面的分类间隔通常是不同的，那个具有“最大间隔”的决策面就是SVM要寻找的最优解。 直观上看，应该去找位于两类训练样本“正中间”的划分超平面，因为该划分超平面对训练样本局部扰动的“容忍”性最好.例如，由于训练集的局限性或噪声的因素，训练集外的样本可能比训练样本更接近两个类的分隔界，这将使许多划分超平面出现错误，而“正中间”的划分超平面受影响最小.换言之，这个划分超平面所产生的分类结果是最鲁棒的，对未见示例的泛化能力最强. 这是无数条可以分类的直线当中最完美的，因为它恰好在两个类的中间，距离两个类的点都一样远, 同时他还是这两个类别之间间隔最大的线性分类器; 换句话说: 这个分类器对每个类别最近的元素距离最远. 而在高维空间中对于支持向量机来说，数据点若是p维向量，我们用p−1维的超平面来分开这些点。但是可能有许多超平面可以把数据分类。最佳超平面的一个合理选择就是以最大间隔把两个类分开的超平面。因此，SVM选择能够使离超平面最近的数据点的到超平面距离最大的超平面。 2: 软间隔在实际应用中，完全线性可分的样本是很少的，我们会遇到不能够完全线性可分的样本，于是我们就有了软间隔，相比于硬间隔的苛刻条件，我们允许个别样本点出现在间隔带里面，比如： 3: 非线性还有一种非线性情况, 比如下面这个: 这个时候, 我们就需要引入我们的三维空间了, 没错将数据上升一个维度, 就能轻松将数据分开, 如下图: 为了解决更加复杂的问题，支持向量机学习方法有一些由简至繁的模型: 线性可分SVM当训练数据线性可分时，通过硬间隔(hard margin)最大化可以学习得到一个线性分类器，即硬间隔SVM。 线性SVM当训练数据不能线性可分但是可以近似线性可分时，通过软间隔(soft margin)最大化也可以学习到一个线性分类器，即软间隔SVM。 非线性SVM当训练数据线性不可分时，通过使用核技巧(kernel trick)和软间隔最大化，可以学习到一个非线性SVM。 (二): 算法原理SVM学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。 但实际上最优决策面的方向和位置完全取决于选择哪些样本作为支持向量。而在经过漫长的公式推导后，你最终会发现，其实与线性决策面的方向和位置直接相关的参数都会被约减掉，最终结果只取决于样本点的选择结果。 1: 线性可分SVM—硬间隔(1): 目标函数(类别之间的间隔)如图所示: 我们给出样本 $(x_i, y_i)$ , 类别标签为 $ y_i \\in {-1, 1}$ 向量 $\\vec W = [w_1, w_2]^T$ 与直线 $\\vec W^Tx + b = 0$ 是相互垂直的 () 在上图中, 向量 $\\vec W$ 是决策面的法向量, 那么决策面的方程就能表示成: $\\vec W^T x + b = 0$ 正例满足: $ \\vec W^T x + b \\ge 1$ 负例满足: $ \\vec W^T x + b \\le -1$ 1): 方法一, 用点到直线的距离求间隔知道了决策面的表达式后, 我们就可以根据点到直线的距离公式:$$d = \\frac{|Ax+By+C|}{\\sqrt{A^2+B^2}}$$可以求出其中一类的支持向量到决策面的距离了:$$ d = \\frac{|\\vec W^T x + b|}{||\\vec W||}$$这里 $||\\vec W||$ 是向量的模，表示在空间中向量的长度 支持向量所在的直线 $\\vec W^T x + b = 1$ 或 $\\vec W^T x + b = -1$ , 而无论是-1还是1, 绝对值之后都是1 , 所以:$$ d = \\frac{|\\vec W^T x + b|}{||\\vec W||}=\\frac{1}{||\\vec W||}$$这只是其中一类到决策面的距离, 因此, 总间隔为$$ d =\\frac{2}{||\\vec W||}$$ 2): 方法二, 用向量求间隔 如图: 我们要分类的向量到决策边界的距离可以用该向量在决策边界的法向量上面的正交投影来衡量,所以我们如果想要求两个类别之间的间隔, 可以用两个支持边界(决策边界两边的那两条线)上的支持向量在决策边界的法向量上的正交投影相减即可( $x_2$ 在 $w$ 上的投影减去 $x_1$ 在 $w$ 上的投影): 当然上图中的 $x_1, x_2$ 并没有在支持边界上, 我们假设他们都在决策边界上, 这时我们就可以用向量的正交投影的公式:$$||\\vec x_2||= \\frac{\\vec x_2 \\times \\vec W}{||\\vec W||}\\||\\vec x_1||= \\frac{\\vec x_1 \\times \\vec W}{||\\vec W||}\\$$所以间隔为:$$\\begin{aligned}d &amp;= ||\\vec x_2|| - ||\\vec x_1||\\\\&amp;=\\frac{\\vec x_2 \\times \\vec W}{||\\vec W||}-\\frac{\\vec x_1 \\times \\vec W}{||\\vec W||}\\\\&amp;=\\frac{1-b}{||\\vec W||} - \\frac{-1-b}{||\\vec W||}\\\\&amp;=\\frac{2}{||\\vec W||}\\end{aligned}$$ 3): 得出目标函数间隔求出来了, 而我们的SVM要求的是两类之间的最大间隔:$$max(d) = max(\\frac{2}{||\\vec W||})$$等价于:$$min||\\vec W||$$ 等价于:$$min (\\frac{1}{2}||\\vec W||^2)$$之所以要加上平方和1/2的系数，是为了以后进行最优化的过程中对目标函数求导时比较方便，但这绝不影响最优化问题最后的解。 同时也不要忘了有一些约束条件:$$\\vec W^T x_i + b \\ge 1, y_i=1\\\\vec W^T x_i + b \\le -1, y_i=-1\\$$将这个式子精简一下:$$y_i(\\vec W^T x_i + b ) \\ge1, i=1,2,3…,n$$ 至此我们的目标函数就出来了: $$min_{\\vec W, b}\\frac{1}{2}||\\vec W||^2\\s.t.y_i(\\vec W^T x_i + b ) \\ge1, i=1,2,3…,n$$ 这里n是样本点的总个数，缩写s. t. 表示“Subject to”，是“服从某某条件”的意思。这是一个典型的不等式约束条件下的二次型函数优化问题 某些条件下，把原始的约束问题通过拉格朗日函数转化为无约束问题，如果原始问题求解棘手，在满足KKT的条件下用求解对偶问题来代替求解原始问题，使得问题求解更加容易。 (2): 拉格朗日乘子法上一节我们求出了目标函数, 但这是一个带约束的优化问题, 此时我们可以用拉格朗日乘子法构造一个拉格朗日函数, 将原来的有约束的优化问题转换为没有约束的优化问题. 拉格朗日乘子法的基本思想是把约束条件转化为新的目标函数的一部分，从而使有约束优化问题变成我们习惯的无约束优化问题。 拉格朗日乘子法扩展 ①: 当约束条件为等式时: ​ 原函数:$$min_x f(x)\\s.t. h_i(x)=0 , i=1,2,3…,m$$​ 拉格朗日函数:$$L(x, \\alpha)=f(x) + \\sum_{i=1}^m\\alpha_i h_i(x)$$②: 当约束条件为不等式时: ​ 原函数:$$min_x f(x)\\s.t. g_j(x) \\le 0 , j=1,2,3…,n$$​ 拉格朗日函数:$$L(x, \\beta)=f(x) + \\sum_{i=1}^n\\beta_j g_j(x)$$并且不等式约束转换之后需要满足KKT(Karush-Kuhn-Tucker)条件, 即:$$\\begin{cases}乘子非负: \\beta_j \\ge 0, j=1,2,3…,n\\\\约束条件: g_j(x) \\le 0 , j=1,2,3…,n\\\\互补条件: \\beta_j \\times g_j(x) = 0\\end{cases}$$KKT条件是对最优解的约束，而原始问题中的约束条件是对可行解的约束 回到我们得原始问题上来,$$min_{\\vec W, b}\\frac{1}{2}||\\vec W||^2\\s.t.y_i(\\vec W^T x_i + b ) \\ge 1, i=1,2,3…,n$$ 我们用拉格朗日乘子法对我们得原函数进行转换:$$L(\\vec W, b, \\alpha) = \\frac{1}{2}||\\vec W||^2 + \\sum_{i=1}^n\\alpha_i [1 - y_i(\\vec W^T x_i + b ) ] , \\alpha_i \\ge 0\\$$假设找到了最佳参数是的目标函数取得了最小值 $p$。即 $\\frac{1}{2}||\\vec W||^2=p$ 。而根据 $\\alpha_i \\ge 0$ ，$y_i(\\vec W^T x_i + b ) \\ge 1$ 可知 $\\sum\\limits_{i=1}^n\\alpha [1-y_i(\\vec W^T x_i + b )] \\le 0$ ，因此$L(\\vec W, b, \\alpha) \\le p$ ，为了找到最优的参数 $\\alpha$ ，使得 $L(\\vec W, b, \\alpha)$ 接近 $p$，故问题转换为出 ${max}_{\\alpha, \\alpha \\ge0} L(\\vec W, b, \\alpha)$。 但我们最终得目的是求原函数关于 $\\vec W$ 和 $b$ 的最小值, 也就是拉格朗日函数关于 $\\vec W$ 和 $b$ 的最小值, 所以我们将问题转换为:$$min_{\\vec W, b}[max_{\\alpha, \\alpha \\ge0}L(\\vec W, b, \\alpha)]$$ (3): 拉格朗日对偶函数拉格朗日函数的对偶问题为:$$max_{\\alpha, \\alpha \\ge0}[min_{\\vec W, b}L(\\vec W, b, \\alpha)]$$ 对偶问题: 假设有个函数 我们有：$$min max f \\ge maxmin f$$也就是说，最大的里面挑出来的最小的也要比最小的里面挑出来的最大的要大。这关系实际上就是弱对偶关系，而强对偶关系是当等号成立时，即：$$min max f = maxmin f$$如果 是凸优化问题，强对偶性成立。而我们之前求的 KKT 条件是强对偶性的充要条件。 回到我们的问题中, 我们现在的目标是先求出: $\\min\\limits_{\\vec W, b}L(\\vec W, b, \\alpha)$ 我们分别令函数 $L(\\vec W, b, \\alpha)$ 对 $\\vec W, b$ 求偏导，并使其等于0。$$\\frac{\\partial L}{\\partial \\vec W}=\\vec W - \\sum_{i=1}^n\\alpha_i y_ix_i =0\\\\frac{\\partial L}{\\partial b} = -\\sum_{i=1}^n\\alpha_i y_i = 0\\$$得到 :$$\\vec W = \\sum_{i=1}^n\\alpha_i y_ix_i\\\\sum_{i=1}^n\\alpha_i y_i = 0$$将我们得到的结果带入 $\\min\\limits_{\\vec W, b}L(\\vec W, b, \\alpha)$ :$$\\begin{aligned}\\min_{\\vec W, b}L(\\vec W, b, \\alpha) &amp;= \\frac{1}{2}||\\vec W||^2 + \\sum_{i=1}^n\\alpha_i [1 - y_i(\\vec W^T x_i + b ) ] \\\\&amp;=\\frac{1}{2}(\\sum_{i=1}^n\\alpha_i y_ix_i)^T (\\sum_{i=1}^n\\alpha_i y_ix_i) + \\sum_{i=1}^n\\alpha_i - \\sum_{i=1}^n\\alpha_i y_i(\\sum_{j=1}^n\\alpha_i y_i (x_i x_j) + b ) \\\\&amp;=\\frac{1}{2}\\sum_{i=1}^n \\sum_{j=1}^n \\alpha_i \\alpha_j y_i y_j (x_i x_j) + \\sum_{i=1}^n\\alpha_i - \\sum_{i=1}^n \\sum_{j=1}^n \\alpha_i \\alpha_j y_i y_j (x_i x_j) - \\sum_{i=1}^n\\alpha_i y_i b \\\\&amp;=\\sum_{i=1}^n\\alpha_i - \\frac{1}{2} \\sum_{i=1}^n \\sum_{j=1}^n \\alpha_i \\alpha_j y_i y_j (x_i x_j)\\end{aligned}$$ $\\min \\limits_{\\vec W, b}L(\\vec W, b, \\alpha)$ 求出来之后我们就可以求 $max_{\\alpha, \\alpha \\ge 0} min_{\\vec W, b}L(\\vec W, b, \\alpha)$ 了, 也就是:$$\\max_{\\alpha, \\alpha \\ge 0}[\\sum_{i=1}^n\\alpha_i - \\frac{1}{2} \\sum_{i=1}^n \\sum_{j=1}^n \\alpha_i \\alpha_j y_i y_j (x_i x_j)]\\s.t \\sum_{i=1}^n\\alpha_i y_i = 0 , \\alpha_i \\ge 0$$不难发现这是一个二次规划问题，有现成的通用的算法来求解。 (4): 二次规划 -&gt; SMO算法 维基百科定义的二次规划 一个有n个变数与m个限制的二次规划问题可以用以下的形式描述。首先给定： 一个n 维的向量 c 一个n × n 维的对称矩阵Q 一个m × n 维的矩阵A 一个m 维的向量 b 则此二次规划问题的目标即是在限制条件为$$Ax \\le b$$的条件下，找一个n 维的向量 x ，使得$$f(x) = \\frac{1}{2}x^TQx+c^Tx$$为最小。 其中$x^T是 x$的转置。 根据不同的参数特性，可以得到对问题不同的结论 如果Q是半正定矩阵，那么f(x)是一个凸函数。相应的二次规划为凸二次规划问题；此时若约束条件定义的可行域不为空，且目标函数在此可行域有下界，则该问题有全局最小值。 如果Q是正定矩阵，则该问题有唯一的全局最小值。 若Q为非正定矩阵，则目标函数是有多个平稳点和局部极小点的NP难问题 根据优化理论，一个点x成为全局最小值的必要条件是满足KKT。当f(x)是凸函数时，KKT条件也是充分条件。 对于二次规划问题, 我们常用 SMO(Sequential Minimal Optimization) 算法求解。SMO序列最小优化算法，其核心思想非常简单：每次只优化一个参数，其他参数先固定住，仅求当前这个优化参数的极值。 我们刚说了 SMO 算法每次只优化一个参数，但我们的优化目标有约束条件：$\\sum\\limits_{i=1}^n\\alpha_i y_i = 0$ ，没法一次只变动一个参数。所以我们选择了一次选择两个参数。 SMO详解 - SVM中的SMO算法 通过 SMO 求得最优解$\\hat \\alpha$ 假设我们现在求得了 $\\alpha$ 的最优解 $\\hat \\alpha$，则根据式 $\\vec W = \\sum\\limits_{i=1}^n\\alpha_i y_ix_i\\$ 可求得最优 $\\hat W$ ：$$\\hat W = \\sum_{i=1}^n \\hat \\alpha_i y_ix_i\\$$ 我们知道所有 $ \\alpha_i$ 对应的点都是支持向量，我们可以随便找个支持向量，然后带入：$1 - y_s(\\vec W^T x_s + b ) = 0 $ 求出 b 即可:$$1 - y_s(\\hat W^T x_s + \\hat b ) = 0\\\\1 = y_s(\\hat W^T x_s + \\hat b )\\\\y_s = y^2_s(\\hat W^T x_s + \\hat b )\\\\ \\\\由于: y_s^2 = 1(y=正负1)\\\\ \\\\y_s = \\hat W^T x_s + \\hat b \\\\\\hat b = y_s - \\hat W^T x_s$$此处s代表该点是支持向量, 为了更具鲁棒性，我们可以求得支持向量的均值：$$\\hat b = \\frac{1}{S}\\sum_{s \\in S}y_s - \\hat W^T x_s$$ 最终我们的决策函数为:$$\\begin{aligned}f(x) &amp;= \\vec Wx+b\\&amp; =\\sum_{i=1}^n \\hat \\alpha_i y_ix_i x +\\hat b\\end{aligned}$$最最后,加上一个阶跃函数:$$f(x) = sign(\\sum_{i=1}^n \\hat \\alpha_i y_ix_i x +\\hat b)$$ 阶跃函数sing()$$sing(x) =\\begin{cases}-1, x \\lt 0\\\\0, x = 0\\\\1, x \\gt 0\\\\\\end{cases}$$ 2: 线性不可分SVM—软间隔我们允许部分样本点不满足约束条件： $ 1 - y_i(\\vec W^T x_i + b ) \\le 0 $ 为了度量这个间隔软到何种程度，我们为每个样本引入一个松弛变量 $\\xi$ ，令 $\\xi_i \\gt0$ ，且 $ 1 - y_i(\\vec W^T x_i + b ) - \\xi_i \\le 0 $ 。 引入松弛变量后, 我们的目标函数就可以重新写为:$$\\min_{\\vec W, b, \\xi}\\frac{1}{2}||\\vec W||^2 + C\\sum_{i=1}^n\\xi_i\\s.t.y_i(\\vec W^T x_i + b ) \\ge 1- \\xi_i\\\\xi_i \\ge 0, i=1,2,3…,n$$其中 C 是一个大于 0 的常数，可以理解为错误样本的惩罚程度，若 C 为无穷大，$\\xi$ 必然无穷小，如此一来线性 SVM 就又变成了线性可分 SVM；当 C 为有限值的时候，才会允许部分样本不遵循约束条件。 构造拉格朗日函数:$$\\min_{\\vec W, b, \\xi} \\max_{\\lambda, \\mu} L(\\vec W, b, \\xi, \\lambda, \\mu) = \\frac{1}{2}||\\vec W||^2 + C\\sum_{i=1}^n\\xi_i +\\sum_{i=1}^n \\lambda_i [1-\\xi_i-y_i(\\vec W^T x_i + b )] + \\sum_{i-1}^n\\mu_i\\xi_i$$其中 $\\lambda$和 $\\mu$ 是拉格朗日乘子，$\\vec W$、b 和 $ \\xi$ 是主问题参数。 根据强对偶性，对偶问题为：$$\\max_{\\lambda, \\mu} \\min_{\\vec W, b, \\xi} L(\\vec W, b, \\xi, \\lambda, \\mu)$$分别对主问题参数$\\vec W$、b 和 $ \\xi$ 求偏导数，并令偏导数为 0，得出如下关系：$$\\vec W = \\sum_{i=1}^n\\lambda_i y_ix_i\\0 = \\sum_{i=1}^n\\lambda_i y_i \\C = \\lambda_i + \\mu_i$$将这些关系带入拉格朗日函数中，得到：$$\\min_{\\vec W, b, \\xi} L(\\vec W, b, \\xi, \\lambda, \\mu) = \\sum_{j=1}^n \\lambda_i - \\frac{1}{2}\\sum_{i-1}^n \\sum_{j=1}^n \\lambda_i \\lambda_j y_i y_j(x_i x_j)$$所以:$$\\max_{\\lambda, \\mu}[\\sum_{j=1}^n \\lambda_i - \\frac{1}{2}\\sum_{i-1}^n \\sum_{j=1}^n \\lambda_i \\lambda_j y_i y_j(x_i x_j)]\\s.t. \\sum_{i=1}^n\\lambda_i y_i = 0 ,C - \\lambda_i - \\mu_i = 0$$我们可以看到这个和硬间隔的一样，只是多了个约束条件。 然后我们利用 SMO 算法求解得到拉格朗日乘子 $ \\lambda^*$ 。 将最佳乘子带入即得: $$\\hat W = \\sum\\limits_{i=1}^n\\hat\\lambda_i y_ix_i\\\\hat b = \\frac{1}{S}\\sum_{s \\in S}y_s - \\hat W^T x_s$$超平面函数为:$$f(x) = sign(\\sum_{i=1}^n \\hat \\lambda_i y_ix_i x +\\hat b)$$这边要注意一个问题，在间隔内的那部分样本点是不是支持向量 我们可以由求参数 w 的那个式子可看出，只要 $\\lambda_i \\gt 0$ 的点都能够影响我们的超平面，因此都是支持向量。 3: 非线性SVM—核函数如下图所示，核技巧的基本思路分为两步: 使用一个变换将原空间的数据映射到新空间(例如更高维甚至无穷维的空间)； 然后在新空间里用线性方法从训练数据中学习得到模型。 我们用 x 表示原来的样本点，用 $\\phi(x)$表示 x 映射到特征新的特征空间后到新向量。那么分割超平面可以表示为: $f(x) = \\vec W \\phi(x) + b$ 则非线性得SVM的对偶问题就变成:$$\\max_{\\lambda, \\mu}{\\sum_{j=1}^n \\lambda_i - \\frac{1}{2}\\sum_{i-1}^n \\sum_{j=1}^n \\lambda_i \\lambda_j y_i y_j[\\phi(x_i) \\phi(x_j)]}\\s.t. \\sum_{i=1}^n\\lambda_i y_i = 0 ,C - \\lambda_i - \\mu_i = 0$$ 核函数得定义 设 $\\mathcal{X}$ 是输入空间(欧式空间$R^n$的子集或离散集合)，又设 $\\mathcal{H}$ 是特征空间(希尔伯特空间)，如果存在一个 $\\mathcal{X}$ 到 $\\mathcal{H}$ 的映射 $$ \\phi(x): \\mathcal{X} \\to \\mathcal{H} $$ 使得对所有 $x, z \\in \\mathcal{X}$，函数 $K(x,z)$ 满足条件 $$ K(x,z) = \\phi(x) \\phi(z) $$ 则称 $K(x,z)$ 为核函数， $ϕ(x)$ 为映射函数，式中 $ϕ(x)⋅ϕ(z)$ 为 $ϕ(x)$ 和ϕ(z) 的內积。 因为低维空间映射到高维空间后维度可能会很大，如果将全部样本的点乘全部计算好，这样的计算量太大了。 有了核函数之后, 我们可以通过计算原始空间的核函数$K(x_i, x_j)$, 就可以得到特征空间内$\\phi(x_i)$ 和 $\\phi(x_j)$ 的点积, 岂不美哉? 而我们常见的核函数有: (1): 线性核函数$$K(x_i, x_j) = x_i x_j$$(2): 多项式核函数$$K(x_i, x_j) = ((x_i x_j)+1)^d$$(3): 高斯核函数$$K(x_i, x_j) = exp(-\\frac{||x_i - x_j||^2}{\\delta^2})$$核函数详解 选择核函数的方法： 如果特征的数量大到和样本数量差不多，则选用LR或者线性核的SVM； 如果特征的数量小，样本的数量正常，则选用SVM+高斯核函数； 如果特征的数量小，而样本的数量很大，则需要手工添加一些特征从而变成第一种情况。 三: SVM优缺点优点 有严格的数学理论支持，可解释性强，不依靠统计方法，从而简化了通常的分类和回归问题； 由于SVM是一个凸优化问题，所以求得的解一定是全局最优而不是局部最优。 能找出对任务至关重要的关键样本（即：支持向量）； 采用核技巧之后，可以处理非线性分类/回归任务； 最终决策函数只由少数的支持向量所确定，计算的复杂性取决于支持向量的数目，而不是样本空间的维数，这在某种意义上避免了“维数灾难”。 缺点 训练时间长。当采用 SMO 算法时，由于每次都需要挑选一对参数，因此时间复杂度为 $O(N^2)$ 其中 N 为训练样本的数量； 当采用核技巧时，如果需要存储核矩阵，则空间复杂度为 $O(N^2)$ 模型预测时，预测时间与支持向量的个数成正比。当支持向量的数量较大时，预测计算复杂度较高。 四: SVM调参 主要参考:Hsu C W, Chang C C, Lin C J. A practical guide to support vector classification[J]. 2003. 将原始数据转换为SVM算法期待的格\u001c\u001c式； 将数据进行scaling(很重要)； 一般考虑用高斯核RBF(如果特征维度太高，建议直接用线性SVM)； 交叉验证寻找最优的RBF的参数以及参数 CC ; 用上面找到的最优参数在整个训练集上训练； 参考文章: 看了这篇文章你还不懂SVM你就来打我 【机器学习】支持向量机 SVM（非常详细） 零基础学SVM—Support Vector Machine(一) 零基础学SVM-Support Vector Machine(二) 如何理解拉格朗日乘子法？ 简易解说拉格朗日对偶（Lagrange duality） 同时推荐刘建平老师的文章: 支持向量机原理(一) 线性支持向量机 支持向量机原理(二) 线性支持向量机的软间隔最大化模型 支持向量机原理(三)线性不可分支持向量机与核函数 支持向量机原理(四)SMO算法原理 支持向量机原理(五)线性支持回归 scikit-learn 支持向量机算法库使用小结 支持向量机高斯核调参小结","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"https://anjhon1994.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"支持向量机","slug":"支持向量机","permalink":"https://anjhon1994.github.io/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"name":"SVM","slug":"SVM","permalink":"https://anjhon1994.github.io/tags/SVM/"}]},{"title":"Django进阶","slug":"后端/Django进阶用法","date":"2020-01-12T12:48:50.000Z","updated":"2020-01-13T02:05:11.009Z","comments":true,"path":"2020/01/12/后端/Django进阶用法/","link":"","permalink":"https://anjhon1994.github.io/2020/01/12/%E5%90%8E%E7%AB%AF/Django%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95/","excerpt":"Django进阶和API接口","text":"Django进阶和API接口 一丶 工欲善其事必先利其器1. pip全局使用豆瓣镜像设置windows系统中①在c盘—&gt;用户—&gt;anjhon—&gt;文件夹中创建pip文件夹②在pip文件夹中创建pip.ini文件③在pip.ini文件中添加以下代码 12[global]index-url=https://pypi.doubanio.com/simple git中cd ~ (进入用户组目录)进入.pip文件夹(没有就创建)创建pip.conf文件在文件内添加以下代码 12[global]index-url=https://pypi.doubanio.com/simple 2. 调试工具Debug-Tool-Bar安装 安装：1pip install django-debug-toolbar 添加appsettings.py1'debug_toolbar', 添加中间键settings.py1'debug_toolbar.middleware.DebugToolbarMiddleware', 配置前端效果：setting.py12345678DEBUG_TOOLBAR_CONFIG = &#123; # 引入jQuery库 'JQUERY_URL': 'https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js', # 工具栏是否折叠 'SHOW_COLLAPSED': True, # 是否显示工具栏 'SHOW_TOOLBAR_CALLBACK': lambda x: True,&#125; 路由配置urls.py123if settings.DEBUG: import debug_toolbar urlpatterns.insert(0, path('__debug__/', include(debug_toolbar.urls))) 二丶 Django用法进阶1. django自带分页器123456789101112131415161718192021# 导入分页工具from django.core.paginator import Paginator# 调用分页器函数会返回一个对象page_obj = = Paginator(obj_list, per_page) obj_list是需要分页的内容 per_page是每页的内容数量,一般为int类型 # 对象的使用方法page_obj.has_previous ---&gt; 是否存在前一页（布尔值）page_obj.has_next ---&gt; 是否存在下一页（布尔值）page_obj.previous_page_number ---&gt; 前一页的页码（数值）page_obj.next_page_number ---&gt; 下一页的页码（数值）page_obj.number ---&gt; 当前页的页码（数值）page_obj.get_page(page) ---&gt; ???page_obj.page(3) ---&gt; 访问指定页面page2.start_index() ---&gt; 从1开始计数的当前页的第一个对象3page2.end_index() ---&gt; 从1开始计数的当前页最后1个对象paginator.page_range ---&gt; 页码范围（迭代对象）paginator.num_pages ---&gt; 页面总数量（数值） 2. 查询(查询结果是集合类型的对象)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Entry.objects.all() ---&gt; 查询所有记录# 指定查询:onlyqueryset = Teacher.objects.filter(subject__no=sno).only('', '', '')# 排除查询:deferqueryset = Teacher.objects.filter(subject__no=sno).defer('', '')# 空值查询:District.objects.filter(pid__null=True)# 条件查询:Entry.objects.filter(num=3) ---&gt; 查询num=3的数据记录Entry.objects.exclude(num=3) ---&gt; 查询num=3的数据记录# 使用切片的方法可以进行范围取值,相当于SQL语句中的LIMIT和OFFSET子句Entry.objects.all()[:5] ---&gt; 返回前5个对象Entry.objects.all()[5:10] ---&gt; 返回第6个到第10个对象# 关键字查询:1) 精确查询: __exact (默认就是精准查询,可以不写)Entry.objects.get(headline__exact=\"Cat bites dog\")2) 模糊查询__contains：是否包含__startswith: 以指定值开头__endswith：以指定值结尾3) 空查询isnull：是否为null4) 范围查询in：是否包含在范围内5) 比较查询gt、gte、lt、lte：大于、大于等于、小于、小于等于6) 日期查询year、month、day、week_day、hour、minute、second：对日期时间类型的属性进行运算7) 不区分大小写: __iexactEntry.objects.get(name__iexact=\"beatles blog\")# Q对象查询在查询的条件中需要组合条件时(例如两个条件“且”或者“或”)。我们可以使用Q()查询对象from django.db.models import QQ(question__startswith='What')可以在Q()对象的前面使用字符“~”来代表意义“非”可以使用 “&amp;”或者“|”还有括号来对条件进行分组从而组合成更加复杂的查询逻辑Q(question__startswith='Who') | Q(question__startswith='What')例: queryset = Record.objects.filter(Q(car__carno__startswith=carno) | Q(car__owner__contains=carno)).select_related('car').order_by('-offend_time')[(page - 1) * size:page * size] context['records'] = queryset # .select_related('car') 在Q对象中car__carno已经实现连表查询,这时再用.select_related('car')语法连同car一起查询 .prefetch_related('...') ---&gt; 多对多顺带查询 .select_related('...') ---&gt; 一对多顺带查询 避免1+n出现 3. Vue12345678910111213141516171819202122232425262728291. 属性:1) el属性 - 字符串，传选择器(一般写id选择器), 将当前创建的Vue对象和html中的标签进行关联2) data属性 - 通过对象的属性提供数据3) methods属性 - 通过对象属性提供方法4) computed属性 - 属性值必须函数, 函数的返回值就是使用属性的值5) created钩子 - 在实例被创建之后被调用 2. Vue指令1) 标签内容 - &#123;&#123;Vue属性名&#125;&#125;2) 标签属性 - v-bind:标签属性 = 'Vue属性名'3) if语句 - v-if='Vue属性名' (如果Vue属性值是true对应的标签就显示，否则就隐藏)4) 循环结构 - v-for = '变量 in 类型是数组的Vue属性'5) 双向绑定 - v-model='Vue属性名' (一般在表单标签中有效)6) 事件绑定 - v-on:事件名3. 补充1) 可以直接在标签内用 @事件名 的方法绑定事件,并直接调用事件函数 例:&lt;button @click=\"prevPage()\"&gt;上一页&lt;/button&gt;2) 缩写v-bind 缩写 &lt;!-- 完整语法 --&gt; &lt;a v-bind:href=\"url\"&gt;...&lt;/a&gt; &lt;!-- 缩写 --&gt; &lt;a :href=\"url\"&gt;...&lt;/a&gt;v-on 缩写 &lt;!-- 完整语法 --&gt; &lt;a v-on:click=\"doSomething\"&gt;...&lt;/a&gt; &lt;!-- 缩写 --&gt; &lt;a @click=\"doSomething\"&gt;...&lt;/a&gt; 4. 字段映射器bpmapper: 将数据库的查询对象转换成字典1) 在应用文件夹下新建映射器文件 : mappers.py app/mappers.py1234567891011121314151617from bpmappers import RawField, DelegateFieldfrom bpmappers.djangomodel import ModelMapperfrom polls.models import Subject, Teacherclass SubjectMapper(ModelMapper): \"\"\"学科映射器\"\"\" isHot = RawField('is_hot') class Meta: model = Subject exclude = ('is_hot', ) exclude = () ---&gt; 排除某些字段 fields = () ---&gt; 包含某些字段 fields = '__all__' ---&gt; 序列化所有字段 isHot = RawField('is_hot') ---&gt; 将后端的is_hot映射成前端的isHot car = DelegateField(Car) ---&gt; 将car字段委托Car类查询映射 2) 调用映射器 app/views.py12345678from polls.mappers import SubjectMapperdef show_subjects(request): \"\"\"获取所有学科\"\"\" queryset = Subject.objects.all() subjects = [SubjectMapper(subject).as_dict() # 调用映射器函数将查询对象变成有序字典 for subject in queryset] return JsonResponse(subjects, safe=False) JsonResponse默认只能返回字典,若想返回列表需要给一个参数safe=False 1return JsonResponse(subjects, safe=False) 列表生成式语法: (性能比列表追加元素要好) 123records = [RecordMapper(record).as_dict() for record in page_obj.object_list]# 从page_obj.object_list中取元素record, 将record传给RecordMapper().as_dict()转换成字典再添加到records里面 5. fetch请求基本语法: 1234567fetch('http://example.com/movies.json') # 返回一个包含响应结果的promise .then(function(response) &#123; return response.json(); &#125;) # 用.json()方法获取到的包含json数据的对象 .then(function(myJson) &#123; console.log(myJson); &#125;); # 获取到json文件里的真实数据 实例: 1234567891011121314151617181920212223let app = new Vue(&#123; el: '#app', data: &#123; 'searched': false, records: [], current_page: 1, total_page: 0, carno: '' &#125;, methods: &#123; search()&#123; let url = '/search/?carno=' + this.carno + '&amp;page=' + this.current_page fetch(url).then(resp =&gt; resp.json()).then(json =&gt; &#123; this.searched = json.searched; this.records = json.records; this.current_page = json.current_page; this.total_page = json.total_page &#125;) &#125; &#125; # 注:this代表app对象 6. 配置redis数据库作为缓存1. redis配置(添加以下代码)project/settings.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 添加缓存(可以配多组)CACHES = &#123; # 默认缓存 'default': &#123; # 用什么来做缓存 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': [ # 可以一主多从 'redis://49.233.152.190:6379/0', # 主机用来写 'redis://49.233.152.190:6379/0', # 从机用来读(可以有多个) ], # 区别命名 'KEY_PREFIX': 'django19062', 'OPTIONS': &#123; 'CLIENT_CLASS': 'django_redis.client.DefaultClient', # 池化技术(提前连接好,要用时借出去,用完还回来)用空间换时间 'CONNECTION_POOL_KWARGS': &#123; # 最大连接数 'max_connections': 512, &#125;, 'PASSWORD': '119148', &#125; &#125;, # 会话缓存(会话放到缓存的好处: 性能好,不用手动清理,利于水平扩展) 'session': &#123; # 用什么来做缓存 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': [ # 可以一主多从 'redis://49.233.152.190:6379/1', # 主机用来写 # 'redis://49.233.152.190:6379/0', # 从机用来读(可以有多个) ], # 键的前缀 'KEY_PREFIX': 'django19062', 'OPTIONS': &#123; 'CLIENT_CLASS': 'django_redis.client.DefaultClient', # 池化技术(提前连接好,要用时借出去,用完还回来)用空间换时间 'CONNECTION_POOL_KWARGS': &#123; # 最大连接数 'max_connections': 1024, &#125;, 'PASSWORD': '119148', &#125; &#125;,&#125;# 配置使用缓存来支持用户会话SESSION_ENGINE = 'django.contrib.sessions.backends.cache'# 会话数据放在哪一组缓存中SESSION_CACHE_ALIAS = 'session'# 设置会话保存的时长(单位秒)SESSION_CACHE_AGE = 86400 # 86400秒为1天 2. 为视图函数 添加缓存机制app/views.py1234567891011121314151617181920212223242526+ @cache_page(timeout=3600, cache='default') def show_subjects(request): \"\"\"获取所有学科\"\"\" queryset = Subject.objects.all() subjects = [SubjectMapper(subject).as_dict() for subject in queryset] return JsonResponse(subjects, safe=False)+ @cache_page(timeout=300, cache='default') def show_teachers(request): \"\"\"获取指定学科的老师\"\"\" try: sno = request.GET['sno'] subject = Subject.objects.get(no=sno) queryset = Teacher.objects\\ .filter(subject__no=sno).defer('subject') teachers = [TeacherMapper(teacher).as_dict() for teacher in queryset] data = &#123; 'subject': SubjectSimpleMapper(subject).as_dict(), 'teachers': teachers &#125; return JsonResponse(data) except (KeyError, ValueError, Subject.DoesNotExist): pass 如你所见,添加缓存机制只需调用一个装饰器函数即可;在调用时需要传参,timeout为超时时间,在固定时间后缓存自动清除;cache选择缓存组; 3. 测试开启django服务,访问前端页面,然后观察控制台 12345678# 第一次请求时在控制台中会使用select语句在mysql中查询数据(0.289) SELECT `tb_subject`.`no`, `tb_subject`.`name`, `tb_subject`.`intro`, `tb_subject`.`is_hot` FROM `tb_subject` WHERE `tb_subject`.`no` = 1; args=(1,)(0.358) SELECT `tb_teacher`.`no`, `tb_teacher`.`name`, `tb_teacher`.`sex`, `tb_teacher`.`birth`, `tb_teacher`.`photo`, `tb_teacher`.`intro`, `tb_teacher`.`good_count`, `tb_teacher`.`bad_count` FROM `tb_teacher` WHERE `tb_teacher`.`sno` = 1; args=(1,)# 再次刷新页面时直接从缓存中获取数据[08/Jan/2020 22:02:14] \"GET /teachers/?sno=1 HTTP/1.1\" 200 5605[08/Jan/2020 22:02:14] \"GET /media/images/yuting.png HTTP/1.1\" 304 0[08/Jan/2020 22:02:14] \"GET /media/images/luohao.png HTTP/1.1\" 304 0 实时数据缓存到redis在需要实时显示并且并发量较大时(例如简单的投票),若直接从sql数据库中取值则会大大增加数据库的压力,同时有一条请求在操作数据库的时候就会锁定该数据,完成后下一个请求才能操作.此时将投票信息添加到缓存,再在缓存内添加定时任务,定时推送缓存的数据到数据库保存,这是一种牺牲暂时一致性,获取最终一致性和提高性能的方法 三丶 API - 应用程序编程接口自己定义的函数也是一种API接口网络API - 通过HTT请求一个URL获得数据 RESTful API 1234567REpresentational State Transfer ---&gt; 表述性状态转移REST架构两大特点: 无状态和幂等性HTTP协议请求行 GET / POST / DELETE / PUT / PATCH新建 ---&gt; POST-不需要幂等性查看 ---&gt; GET更新 ---&gt; PUT/PATCH删除 ---&gt; DELETE 1. 准备工作:123456781) 安装djangorestframeworkpip install djangorestframeworkpip install drf-extensions2) 在INSTALLED_APPS注册rest_frameworkINSTALLED_APPS = [ 'rest_framework',] 2. API接口1) FBV - 基于函数的视图1234567891011121314151617# urls.py 控制器path('agent/', get_agent),# serializers.py 映射器from rest_framework import serializersfrom common.models import Agentclass AgentSimpleSerializer(serializers.ModelSerializer): class Meta: model = Agent exclude = ('estates', ) # view视图函数:@api_view(('GET', )) # 指定请求,其他请求没效果def get_agent(request): queryset = Agent.objects.all().defer('estates') serializer = AgentSimpleSerializer(queryset, many=True) return Response(serializer.data) 2) CBV - 基于类的视图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# urls.py 控制器 path('estate/', EstatesView.as_view()), path('estate/&lt;int:pk&gt;/', EstatesView.as_view()) # pk参数是一种约定,不能修改 # serializers.py 映射器from rest_framework import serializersfrom common.models import Estateclass EstateSerializer(serializers.ModelSerializer): class Meta: model = Estate exclude = ('agents', 'district') # exclude = () ---&gt; 排除某些字段 # fields = () ---&gt; 包含某些字段 # fields = '__all__' ---&gt; 序列化所有字段 # isHot = RawField('is_hot') ---&gt; 将后端的is_hot映射成前端的isHot # car = DelegateField(Car) ---&gt; 将car字段委托Car类查询映射 # view.py :class EstatesView(ListAPIView, RetrieveAPIView): queryset = Estate.objects.all().defer('district', 'agents') serializer_class = EstateSerializer # 将请求单个数据和请求多个数据分开 def get(self, request, *args, **kwargs): if 'pk' in kwargs: cls = RetrieveAPIView # 单 else: cls = ListAPIView # 多 return cls.get(self, request, *args, **kwargs) # 父类的选择 CreateAPIView ---&gt; 新增 ListAPIView ---&gt; 查询所有 RetrieveAPIView ---&gt; 查询单个 DestroyAPIView ---&gt; 删除 UpdateAPIView ---&gt; 修改 ListCreateAPIView RetrieveUpdateAPIView RetrieveDestroyAPIView RetrieveUpdateDestroyAPIView 🚩 全套接口视图集📌 view.py : from rest_framework.viewsets import ModelViewSetclass HouseTypeViewSet(ModelViewSet): queryset = HouseType.objects.all() serializer_class = HouseTypeSerializer 📌 urls.py : urlpatterns = [ ...]# 路由器router = SimpleRouter() # 简单路由router.register('housetypes', HouseTypeViewSet) # 注册urlpatterns += router.urls # 添加 接口测试:1: 三方库: requests 1234567import jsonimport requestsresp = requests.get('http://localhost:8000/api/estates/')estates = json.loads(resp.text)for index, estate in enumerate(estates): print(index, estate) 2: Postman和Postwomam软件 3. DRF 分页123PageNumberPagination ---&gt; 按页码分页LimitoffsetPagination ---&gt; 跳过N条,查第N+1条CursorPagination 1) 自定义分页 setting.py12345678910中间键后面添加以下代码(全部实现分页)# DRF配置文件REST_FRAMEWORK = &#123; # 按页码分页 'DEFAULT_PAGINATION_CLASS':'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 5,&#125;# 若单个视图类不想分页可以加以下代码: pagination_class = None 2) 游标分页 app/views.py1234567# 定义游标分页类class EstatePagination(CursorPagination): page_size_query_param = 'size' # 自定义单页显示记录数 max_page_size = 20 # 单页最多记录数 ordering = 'estateid' # 按楼盘id分页# 在视图类里面调用pagination_class = EstatePagination 4. DRF缓存依赖项drf-extensions==0.5.0 为DRF提供缓存扩展 1) django里的装饰器@method_decorator可以将装饰函数的装饰器变成可以装饰类方法的装饰器 1234567@method_decorator(decorator=cache_page(500), name='list')@method_decorator(decorator=cache_page(120), name='retrieve')class HouseTypeViewSet(ModelViewSet): queryset = HouseType.objects.all() serializer_class = HouseTypeSerializer # 拒绝分页 pagination_class = None 2) 导入混入类做缓存 setting.py1234567# 缓存混入类REST_FRAMEWORK_EXTENSIONS = &#123; 'DEFAULT_CACHE_RESPONSE_TIMEOUT': 120, 'DEFAULT_USE_CACHE': 'default', 'DEFAULT_OBJECT_CACHE_KEY_FUNC': 'rest_framework_extensions.utils.default_object_cache_key_func', 'DEFAULT_LIST_CACHE_KEY_FUNC': 'rest_framework_extensions.utils.default_list_cache_key_func',&#125; app/views.py123456# 导入混入类:from rest_framework_extensions.cache.mixins import CacheResponseMixin# 让视图类继承混入类:class EstatesView(CacheResponseMixin): # 带Mixin的类是混入类,混入类必须写在前面 5. 接口数据的筛选和排序1234567891011121314151617181920212223242526272829303132333435363738# 安装django filterpip install django-filter# 配置文件添加应用'django_filters',# 导入DjangoFilterBackendfrom django_filters.rest_framework import DjangoFilterBackend# DjangoFilterBackend帮忙筛数据filter_backends = (DjangoFilterBackend, OrderingFilter)--------------- 直接查询 ------------------# 设置筛选条件filter_fields = ('district', )# 设置排序字段ordering_fields = ('hot', 'estateid')--------- 自定义一个类来指定查询条件-----------# ①: 自定义类:class EstateFilterSet(django_filters.FilterSet): minhot = django_filters.NumberFilter(field_name='hot', lookup_expr='gte') maxhot = django_filters.NumberFilter(field_name='hot', lookup_expr='lte') keyword = django_filters.CharFilter(method='filter_by_keyword') @staticmethod def filter_by_keyword(queryset, key, value): queryset = queryset.filter(Q(name__contains=value) | Q(intro__contains=value)) return queryset # ②: 导入定义好的类from common.utils import EstateFilterSet# ③: 在视图类里面使用(注,使用时要放到filter_backends后面)filter_backends = (DjangoFilterBackend, OrderingFilter)filterset_class = EstateFilterSet 6. 接口限流: 限制接口的访问频率原理: 在缓存(Redis)内记录IP地址,并记录访问次数,当请求超过阈值则限制访问 settings.py123456789REST_FRAMEWORK = &#123; # 限流配置 'DEFAULT_THROTTLE_CLASSES': ( 'rest_framework.throttling.AnonRateThrottle', ), 'DEFAULT_THROTTLE_RATES': &#123; 'anon': '5/min', &#125;,&#125; 若不想限流,可以在视图类里面加入以下代码: 1throttle_classes = ()","categories":[{"name":"Django","slug":"Django","permalink":"https://anjhon1994.github.io/categories/Django/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://anjhon1994.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"后端","slug":"后端","permalink":"https://anjhon1994.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Django","slug":"Django","permalink":"https://anjhon1994.github.io/tags/Django/"}]},{"title":"Django入门之选课系统","slug":"后端/Django入门之选课系统","date":"2020-01-05T12:48:50.000Z","updated":"2020-07-04T15:37:13.765Z","comments":true,"path":"2020/01/05/后端/Django入门之选课系统/","link":"","permalink":"https://anjhon1994.github.io/2020/01/05/%E5%90%8E%E7%AB%AF/Django%E5%85%A5%E9%97%A8%E4%B9%8B%E9%80%89%E8%AF%BE%E7%B3%BB%E7%BB%9F/","excerpt":"Django是高水准的Python编程语言驱动的一个开源框架","text":"Django是高水准的Python编程语言驱动的一个开源框架 一丶Django简述Django 最初由2003年到2005年间由负责创建和维护报纸网站的网络团队开发。它是一个高级的 Python 网络框架，可以快速开发安全和可维护的网站。 Django框架基本工作流程在传统的数据驱动网站中，Web应用程序会等待来自Web浏览器（或其他客户端）的 HTTP 请求。当接收到请求时，应用程序根据 URL 和可能的 POST 数据或 GET 数据中的信息确定需要的内容。根据需要，可以从数据库读取或写入信息，或执行满足请求所需的其他任务。然后，该应用程序将返回对Web浏览器的响应，通常通过将检索到的数据插入 HTML模板中的占位符来动态创建用于浏览器显示的 HTML 页面。 MVC架构模式架构规范: 数据和显示要分离(模型和视图解耦合)同一个模型可以渲染成不同的视图,同一个视图可以加载不同的模型 123M ---&gt; model ---&gt; 模型 ---&gt; 数据V ---&gt; View ---&gt; 视图 ---&gt; 数据显示C ---&gt; Contyoller ---&gt; 控制器 ---&gt; 连接数据和显示的中间商 Django (MTV架构模式)网络应用程序通常将处理每个步骤的代码分组到单独的文件中;如图所示: 📌 URL映射器用于根据请求URL将HTTP请求重定向到相应的视图。URL映射器还可以匹配出现在URL中的字符串或数字的特定模式，并将其作为数据传递给视图功能。📌 View: 视图 是一个请求处理函数，它接收HTTP请求并返回HTTP响应。视图通过模型访问满足请求所需的数据，并将响应的格式委托给 模板。📌 Models: 模型 是定义应用程序数据结构的Python对象，并提供在数据库中管理（添加，修改，删除）和查询记录的机制。📌 Templates: 模板 是定义文件（例如HTML页面）的结构或布局的文本文件，用于表示实际内容的占位符。一个视图可以使用HTML模板，从数据填充它动态地创建一个HTML页面模型。可以使用模板来定义任何类型的文件的结构; 它不一定是HTML！ 二丶Django简单页面生成1. 创建一个Django项目创建Django项目的方式很多,这里简单介绍三种 1234567891011121314151617 django-admin - django包管理员工具1. 在命令提示符内(我用了Git)输入 ~ django-admin startproject polls # 创建一个新项目2. 使用PyCharm打开项目并创建虚拟环境 ~ cd polls # 进入项目文件夹 ~ python3 -m venv venv # 新建虚拟环境 ~ \"venv/Scripts/activate\" # 激活虚拟环境3. 安装项目依赖项: 打开Pycharm底部的Terminal,输入 ~ pip install django mysqlclient django-redis pillow requests 使用pip安装三方库时，可以通过如django==1.11.27的方式来指定三方库的版本。4. 运行django项目 ~ python manage.py runserver ~ python manage.py runserver 127.0.0.1:80 # 指定端口为805. 添加项目运行快捷方式 Add Configuration ---&gt; + ---&gt; Python ---&gt; Script Path (manage.py) --&gt; Parameters (runserver) 12345671. 用PyCharm创建一个普通的Python项目2. 安装Django所需的依赖项 ~ pip install django==2.1.14 -i https://pypi.doubanio.com/simple3. 把Python项目变成Django项目 ~ django-admin startproject polls .4. 运行项目 ~ python manage.py runserver 123456789存在远端仓库时需要克隆项目到本地1. 克隆 使用PyCharm新建页面的\"get from version control\" ~ git clone git@gitee.com:anjhon/polls.git # 地址需要自行更换2. 创建虚拟环境(项目中一般不会将虚拟环境纳入版本控制) ~ Linux/macOS: source venv/bin/activate ~ Windows: \"venv/Scripts/activate\"3. 重建依赖项 ~ pip install -r requirements.txt # requirements文件为依赖项清单 创建好新项目之后就能看到飞升的小火箭了 2. 简单的文件配置设置语言时区polls/setting.py 1234- LANGUAGE_CODE = 'en-us'+ LANGUAGE_CODE = 'zh-hans'- TIME_ZONE = 'UTC'+ TIME_ZONE = 'Asia/Chongqing' 设置tamplates文件夹路径polls/setting.py 12345678TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates',- 'DIRS': [],+ 'DIRS': [os.path.join(BASE_DIR, 'templates')], 'APP_DIRS': True, ...] 3. 创建Django应用在控制台输入: 12345方法一~ python manage.py startapp app方法二~ django-admin startapp app在新建好的应用文件夹下创建templates文件夹(用来存放前端页面) 创建好应用后,应用文件夹视图如下: 123456789-- app |--migrations | |--__init__.py # 一个空文件，告诉Python解释器这个目录应该被视为一个Python的包。 |--__init__.py |--admin.py # 可以用来注册模型，用于在Django的管理界面管理模型。 |--apps.py # 当前应用的配置文件。 |--models.py # 存放应用的数据模型，即实体类及其之间的关系（MVC/MTV中的M）。 |--tests.py # 包含测试应用各项功能的测试类和测试函数。 |--views.py # 处理请求并返回响应的函数（MVC中的C，MTV中的V）。 最后别忘了配置一下新建的应用 polls/setting.py123456789INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',+ 'polls',] 4. 要怎样自定义一个页面呢?第一步: 配置url控制器 polls/urls.py12345678from django.contrib import adminfrom django.urls import pathfrom app.views import index # 这里导入了视图里的函数indexurlpatterns = [ path('admin/', admin.site.urls),+ path('', index) # 这里调用了视图里的函数index] 第二部: 写视图函数 app/views.py1234567891011from random import samplefrom django.http import HttpRequestfrom django.shortcuts import renderdef index(request: HttpRequest): # 定义一个index函数 musics = ['嚣张', '让世间美好与你环环相扣', '无问', '膨胀', '野孩子', '海阔天空', '爱情买卖', '快乐男孩', ] context = &#123; 'musics': sample(musics, 3), 'greeting': 'Hello, Django' &#125; return render(request, \"index.html\", context) # 返回了一个html页面 第三步: 编写前端模板页 templates/index.html1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;&#123;&#123; greeting &#125;&#125;&lt;/h2&gt; &lt;hr/&gt;&lt;!-- django模板页,可以使用django模板语法和模板指令生成动态内容 --&gt; &lt;ul&gt; &#123;% for music in musics %&#125; &lt;li&gt;&#123;&#123; music &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 好了,一个简单的网页产生了! 三丶Django制作简单的选课系统邓爷爷说: 实践才是检验真理的唯一标准 在第二节我们实现了简单网页,但是只是用到了视图和模板,并没有涉及到数据; 要知道,在真正的项目中,这是不可能存在的,所以本节我们将通过实操一个小型的项目来带大家快速熟悉Django框架 1. 环境准备①: 安装Python操作MySQL的依赖库 1~ pip install pymysql ②: 设置数据库连接参数 polls/setting.py1234567891011121314DATABASES = &#123; 'default': &#123;- 'ENGINE': 'django.db.backends.sqlite3',+ 'ENGINE': 'django.db.backends.mysql',- 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),+ 'NAME': 'anjhon',+ 'HOST': '0.0.0.0', # 这里地址需要自行更改,可以连接本地数据库,参数为:localhost+ 'PORT': 3306,+ 'USER': 'anjhon',+ 'PASSWORD': '123456',+ 'CHARSET': 'utf8',+ 'TIME_ZONE': 'Asia/Chongqing', &#125;&#125; 2. 创建数据模型创建数据模型app/models.py12345678910111213141516171819202122232425262728293031323334from django.db import modelsclass Subject(models.Model): \"\"\"学科模型类\"\"\" nums = models.AutoField(primary_key=True, verbose_name='编号') # 自增,主键 name = models.CharField(max_length=20, verbose_name='名称') # 20长度的字符串 intro = models.CharField(max_length=1000, verbose_name='介绍') # 1000长度的字符串 is_hot = models.BooleanField(default=False, verbose_name='是否热门') def __str__(self): return self.name class Meta: db_table = 'tb_subject' verbose_name = '学科' verbose_name_plural = '学科'class Teacher(models.Model): \"\"\"老师模型\"\"\" nums = models.AutoField(primary_key=True, verbose_name='教师编号') name = models.CharField(max_length=20, verbose_name='教师姓名') sex = models.BooleanField(default=True, verbose_name='性别') birth = models.DateField(verbose_name='教师生日') photo = models.ImageField(upload_to='images', default='', max_length=512, verbose_name='头像') intro = models.CharField(default='', max_length=1000, verbose_name='教师介绍') good_count = models.PositiveIntegerField(default=0, verbose_name='好评数') bad_count = models.IntegerField(default=0, verbose_name='差评数') subject = models.ForeignKey(to=Subject, on_delete=models.PROTECT, db_column='snums', verbose_name='所属学科') # 该教师学科的名字 class Meta: # 元信息,元数据(描述数据的数据) db_table = 'tb_teacher' verbose_name = '教师' verbose_name_plural = '教师' 参数小结: IntegerField 对应数据库中的integer类型， CharField 对应数据库的varchar类型， DecimalField 对应数据库的decimal类型， ForeignKey 用来建立多对一外键关联。 primary_key 用于设置主键， max_length 用来设置字段的最大长度， db_column 用来设置数据库中与字段对应的列， verbose_name 则设置了Django后台管理系统中该字段显示的名称。 将模型变成数据库内的表格Pycharm内的Terminal1234# 生成迁移文件~ python manage.py makemigrations polls# 执行迁移~ python manage.py migrate 到这一步,我们的数据库里就已经生成好了学科和老师的数据表格,这时我们需要进入到Django自带的后台管理系统,管理数据; 扩展:数据表建好以后,反向建模型到models.py文件: 1python manage.py inspectdb &gt; common/models.py 远端数据库设置12345678910111213141516171819202122232425262728create database djangocase default charset utf8 collate utf8_bin; ---&gt; 创建数据库grant all privileges on djangocase.* to 'anjhon'@'%'; ---&gt; 给用户权限(venv) C:\\djangocase&gt; python manage.py migrate ---&gt; 执行迁移use djangocase; ---&gt; 切换数据库show tables; ---&gt; 显示表格+----------------------------+| Tables_in_djangocase |+----------------------------+| auth_group || auth_group_permissions || auth_permission || auth_user || auth_user_groups || auth_user_user_permissions || django_admin_log || django_content_type || django_migrations || django_session || jet_bookmark || jet_pinnedapplication |+----------------------------+12 rows in set (0.00 sec)(venv) C:\\polls&gt; python manage.py createsuperuser ---&gt; 创建超级管理员 3. 后台管理①: 创建超级管理员账号 Pycharm内的Terminal123456~ python manage.py createsuperuserUsername : anjhonEmail address: anjhon@163.comPassword: # 密码不显示Password (again): Superuser created successfully. ②: 注册模型 polls/admin.py123456789101112131415from django.contrib import adminfrom polls.models import Subject, Teacherclass SubjectAdmin(admin.ModelAdmin): list_display = ('nums', 'name', 'intro', 'is_hot') # 默认显示学科对象,该语句可以显示学科编号,名称,介绍. list_display_links = ('name', 'nums', ) search_fields = ('name', ) # 可以按名字搜索 ordering = ('nums', ) # 根据nums排升序class TeacherAdmin(admin.ModelAdmin): list_display = ('nums', 'name', 'sex', 'birth', 'intro', 'good_count', 'bad_count', 'subject') search_fields = ('name', ) ordering = ('nums',) ③: 登录管理员后台 Pycharm内的Terminal1234# 开启服务器~ python manage.py runserver# 访问http://127.0.0.1:8000/admin 这里输入刚刚的超级管理员的密码就能登录了;不过由于界面实在不忍直视,所以我决定给他换个jet主题! 安装jet Pycharm内的Terminal1~ pip install django-jet -i https://pypi.doubanio.com/simple 添加应用 polls/settings.py12345678910INSTALLED_APPS = [+ 'jet', 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'polls',] 注: jet要加到最前面,不然Django会先加载自带的主题,这样就没什么效果了 执行迁移： Pycharm内的Terminal1~ python manage.py migrate jet 配置URL polls/urls.py1234urlpatterns = [ path('admin/', admin.site.urls),+ path('jet/', include('jet.urls', 'jet')),] 大功告成! 进入后台之后就可以添加老师和学科的数据了;至此,数据准备完成! 4. 网页成型①: 同样的,先配置url polls/urls.py123456789101112131415161718from django.conf import settingsfrom django.conf.urls.static import staticfrom django.contrib import adminfrom django.urls import path, includefrom polls.views import index, show_teachers, praise_or_criticize, \\ login, get_captcha, logouturlpatterns = [ path('jet/', include('jet.urls', 'jet')), path('admin/', admin.site.urls), path('', index),+ path('teachers/', show_teachers), # 教师信息页面+ path('praise/', praise_or_criticize), # 好评+ path('criticize/', praise_or_criticize), # 差评+ path('login/', login), # 登录+ path('logout/', logout), # 注销+ path('captcha/', get_captcha), # 验证码] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) ②: 写视图函数 app/views.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110from base64 import b64decodefrom django.http import JsonResponse, HttpResponsefrom django.shortcuts import render, redirectfrom polls.captcha import Captchafrom polls.models import Subject, Teacher, Userfrom polls.utils import random_text, to_md5_hex, check_username, check_passworddef index(request): \"\"\"首页（获取所有学科）\"\"\" queryset = Subject.objects.all() context = &#123; 'subjects': queryset &#125; return render(request, 'subjects.html', context)def show_teachers(request): \"\"\"显示指定学科的老师\"\"\" try: sno = request.GET['sno'] subject = Subject.objects.get(no=sno) queryset = Teacher.objects.filter(subject__no=sno) context = &#123; 'subject': subject, 'teachers': queryset &#125; return render(request, 'teachers.html', context) except (KeyError, ValueError, Subject.DoesNotExist): return redirect('/')def praise_or_criticize(request): \"\"\"好评或差评\"\"\" if request.session.get('userid') is None: data = &#123;'code': 10002, 'message': '请先登录'&#125; else: tno = request.GET.get('tno', '0') try: teacher = Teacher.objects.get(no=tno) if request.path.startswith('/praise'): teacher.good_count += 1 else: teacher.bad_count += 1 teacher.save() data = &#123;'code': 10000, 'message': '操作成功'&#125; except (ValueError, Teacher.DoesNotExist): data = &#123;'code': 10001, 'message': '操作失败'&#125; return JsonResponse(data)def login(request): \"\"\"登录\"\"\" backurl = request.GET.get('backurl', '') hint = '' if request.method == 'POST': # 获取用户输入的验证码 code_from_user = request.POST.get('captcha', '0').lower() # 获取用户输入的验证码 code_from_serv = request.session.get('code', '1').lower() # 若用户验证码和服务器验证码相同,则进入登录流程 if code_from_user == code_from_serv: # 获取用户输入的用户名 username = request.POST.get('username', '') # 获取用户输入的密码 password = request.POST.get('password', '') # 检查用户名和密码是否复合规范 if check_username(username) and check_password(password): # 生成密码摘要 password = to_md5_hex(password) # 从数据库获取用户信息对象保存到user中 user = User.objects.filter(username=username, password=password).first() if user: # 若匹配成功,将用户的信息保存到session对象中,方便cookie连接 # 登录成功后为了记住这个登录成功的用户 # 我们可以在服务器端保存和用户相关的信息 # 我们可以将这些信息保存在Django框架提供的session对象中 request.session['userid'] = user.no request.session['username'] = user.username backurl = request.POST.get('backurl') if backurl: backurl = b64decode(backurl).decode() else: backurl = '/' return redirect(backurl) else: hint = '用户登录信息错误!' else: hint = '请输入登录信息!' else: hint = '请输入正确的验证码!' context = &#123; 'hint': hint, 'backurl': backurl &#125; return render(request, 'login.html', context)def logout(request): # 清空session对象中的数据 request.session.flush() # 重定向到主页面 return redirect('/')def get_captcha(request): \"\"\"获取验证码图片\"\"\" code = random_text() image_data = Captcha.instance().generate(code) request.session['code'] = code return HttpResponse(image_data, content_type='image/png') ③: 网页模板首页学科页 templates/subjects.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style&gt; body &#123; width: 920px; margin: 0 auto; &#125; .subject &#123; margin: 20px 20px; &#125; .sname &#123; font: bold 28px Arial; &#125; a &#123; color: blue; text-decoration: none; &#125; .nav &#123; float: right; margin-top: 20px; &#125; .nav+h2 &#123; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"nav\"&gt; &#123;% if request.session.userid %&#125; &#123;&#123; request.session.username &#125;&#125; &lt;a href=\"/logout/\"&gt;注销&lt;/a&gt; &#123;% else %&#125; &lt;a href=\"/login/\"&gt;登录&lt;/a&gt;&amp;nbsp; &#123;% endif %&#125; &lt;a href=\"\"&gt;注册&lt;/a&gt; &lt;/div&gt; &lt;h2&gt;所有学科&lt;/h2&gt; &lt;hr&gt; &#123;% for subject in subjects %&#125; &lt;div class=\"subject\"&gt; &lt;p class=\"sname\"&gt; &lt;a href=\"/teachers/?sno=&#123;&#123; subject.no &#125;&#125;\"&gt;&#123;&#123; subject.name &#125;&#125;&lt;/a&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &#123;% if subject.is_hot %&#125; &lt;img src='/static/images/hot-icon-small.png'&gt; &#123;% endif %&#125; &lt;/p&gt; &lt;p&gt;&#123;&#123; subject.intro &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125;&lt;/body&gt;&lt;/html&gt; 教师信息页 templates/teachers.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;老师信息&lt;/title&gt; &lt;style&gt; body &#123; width: 920px; margin: 0 auto; &#125; .teacher &#123; clear: both; &#125; .photo &#123; margin-top: 20px; width: 140px; height: 140px; border-radius: 70px 70px 70px 70px; overflow: hidden; float: left; &#125; .content &#123; margin-left: 60px; width: 580px; float: left; &#125; .keyinfo &#123; font: bold 18px Arial; &#125; .back &#123; float: right; margin-top: 20px; &#125; .back&gt;a &#123; text-decoration: none; color: blue; &#125; .back+h2 &#123; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"back\"&gt; &lt;a href=\"/\"&gt;返回首页&lt;/a&gt; &lt;/div&gt; &lt;h2&gt;&#123;&#123; subject.name &#125;&#125;学科老师信息&lt;/h2&gt; &lt;hr&gt; &#123;% for teacher in teachers %&#125; &lt;div class=\"teacher\"&gt; &lt;div class=\"photo\"&gt; &lt;img src=\"&#123;&#123; teacher.photo.url &#125;&#125;\" width=\"140\"&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; &lt;p class=\"keyinfo\"&gt; &#123;&#123; teacher.name &#125;&#125;&amp;nbsp;&amp;nbsp; &#123;&#123; teacher.sex | yesno:\"男, 女\" &#125;&#125;&amp;nbsp;&amp;nbsp; &#123;&#123; teacher.birth &#125;&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; teacher.intro &#125;&#125; &lt;/p&gt; &lt;p class=\"comment\"&gt; &lt;a href=\"/praise/?tno=&#123;&#123; teacher.no &#125;&#125;\"&gt;好评&lt;/a&gt;（&lt;span&gt;&#123;&#123; teacher.good_count &#125;&#125;&lt;/span&gt;）&amp;nbsp;&amp;nbsp; &lt;a href=\"/criticize/?tno=&#123;&#123; teacher.no &#125;&#125;\"&gt;差评&lt;/a&gt;（&lt;span&gt;&#123;&#123; teacher.bad_count &#125;&#125;&lt;/span&gt;） &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; // $()函数中的箭头函数是页面加载完成之后要执行的回调函数 $(() =&gt; &#123; let flag = true // 通过$(选择器)获取页面元素绑定点击事件 // on方法的第一个参数是事件名 第二个参数是事件回调函数 // 事件回调函数的参数evt是代表事件的对象 $('.comment&gt;a').on('click', (evt) =&gt; &#123; // 阻止事件默认行为（避免直接刷新页面） evt.preventDefault() if (flag) &#123; // 实现函数节流 flag = false setTimeout(() =&gt; &#123; flag = true &#125;, 2000) // 通过事件对象获取事件源并由$函数转成jQuery对象 let anchor = $(evt.target) // 通过jQuery对象的getJSON方法发起Ajax请求 // 第一个参数是请求的URL // 第二个参数是请求完成之后要执行的回调函数 $.getJSON(anchor.attr('href'), (json) =&gt; &#123; if (json.code == 10000) &#123; // 投票成功 // 获取与a标签相邻的span标签 let span = anchor.next() // 将span标签的值加1再写回span标签 span.text(parseInt(span.text()) + 1) &#125; else &#123; alert(json.message) if (json.code == 10002) &#123; location.href = '/login/?backurl=' + btoa('/teachers/?sno=&#123;&#123; subject.no &#125;&#125;') &#125; &#125; &#125;) &#125; else &#123; alert('操作太频繁') &#125; &#125;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 登录页 templates/login.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户登录&lt;/title&gt; &lt;style&gt; #container &#123; width: 920px; margin: 0 auto; &#125; .input, form+a &#123; margin: 30px 10px; width: 400px; height: 32px; &#125; .input&gt;input &#123; border: none; outline: none; border-bottom: 1px dotted darkgray; width: 180px; &#125; .input:last-child&gt;input &#123; border: none; background-color: red; color: white; width: 80px; height: 25px; &#125; .input&gt;label &#123; display: inline-block; width: 80px; text-align: right; &#125; .input:last-child &#123; text-align: center; border: none; margin-left: -20px; &#125; .input&gt;img &#123; vertical-align: middle; &#125; a &#123; text-decoration: none; color: blue; &#125; .hint &#123; font-size: 12px; color: red; height: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"container\"&gt; &lt;h2&gt;用户登录&lt;/h2&gt; &lt;hr&gt; &lt;p class=\"hint\"&gt;&#123;&#123; hint &#125;&#125;&lt;/p&gt; &lt;form action=\"/login/?backurl=&#123;&#123; backurl &#125;&#125;\" method=\"post\"&gt; &#123;% csrf_token %&#125; &lt;div class=\"input\"&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input type=\"text\" name=\"username\"&gt; &lt;/div&gt; &lt;div class=\"input\"&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input type=\"password\" name=\"password\"&gt; &lt;/div&gt; &lt;div class=\"input\"&gt; &lt;label&gt;验证码：&lt;/label&gt; &lt;input type=\"text\" name=\"captcha\"&gt; &lt;img id=\"code\" src=\"/captcha/\" height=\"33\"&gt; &lt;/div&gt; &lt;div class=\"input\"&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;input type=\"reset\" value=\"重置\"&gt; &lt;/div&gt; &lt;/form&gt; &lt;a href=\"/\"&gt;返回首页&lt;/a&gt; &lt;/div&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(() =&gt; &#123; $('#code').on('click', (evt) =&gt; &#123; $(evt.target).attr('src', '/captcha/?' + Math.random()) &#125;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 页面布局完成! ④: 补充在项目目录下新建文件夹static, 专门用来存放静态资源,在static下创建css, js, image文件夹,分别用来存放样式表, js文件, 图片资源为了让html文件能够找到保存静态资源的文件夹，还需要修改Django项目的配置文件settings.py polls/settings.py12+ STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static'), ] STATIC_URL = '/static/' 最后在使用时需要在html文件中较前的位置加入代码 引用本地静态文件1234567891011&lt;!DOCTYPE html&gt;+&#123;% load staticfiles %&#125;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 5. 再补充一点cookie和session的关系HTTP协议是无连接无状态协议 —&gt;两次请求之间不会保存用户的任何数据;再次请求服务器的时候服务器无法得知请求是来自哪个用户的请求;一般情况下服务器应用都需要记住用户来为用户提供更好的服务;如果希望服务器记住用户可以使用以下三种辅助方式: URL重写http://www.baidu.com/?uid=xxxxxx 隐藏域(隐式表单域) —&gt; 埋点123&lt;form&gt; &lt;input type=\"hidden\"name=\"uid\"value=\"xxxxxx\"&gt;&lt;/form&gt; 浏览器本地存储 ~ cookie —&gt; 浏览器中的零食文件,可以保存键值对;cookie中的数据在发起HTTP请求时会自动加载到请求头中 ~ window.localStorage / window.sessionStorage request.session —&gt; 存储登录成功的用户信息,session是服务器内的一个对象cookie -—-&gt; 用户浏览器临时文件 -—-&gt; cookie中保存了session的ID 编码小知识通常如果一样东西需要编码，说明这样东西并不适合传输。原因多种多样，如Size过大，包含隐私数据，对于Url来说，之所以要进行编码，是因为Url中有些字符会引起歧义。 BASE64编码用64个文字符号表示任意二进制数据原理：将原来的三字节每6个比特一组变成四个字节用A-Z、a-z、0-9、+和/一共64个字符来代表一个字节 123456789base64编码:python内from base64 import b64encode, b64decodeb64encode('...'.encode()) ---&gt; base64编码b64decode(b'...') ---&gt; base64解码JavaScript内btoa('url') ---&gt; 编码atob('...') ---&gt; 解码 百分号编码(Url编码)使用%百分号加上两位的字符(十六进制0~F)。URL编码默认使用的字符集是US-ASCII。例如 a 在US-ASCII码中对应的字节是0x61，那么URL编码之后得到的就 是%61，我们在地址栏上输入;又如@符号在ASCII字符集中对应的字节为0x40，经过URL编码之后得到的是%40。 123from urllib.parse import quotequote('经理人数据统计表.xls') 编码unquote('...') 解码 常用知识点1234567891011121314151617python manage.py runserver ---&gt; 运行django服务器python manage.py createsuperuser ---&gt; 创建超级管理员账号python manage.py makemigrations polls ---&gt; 迁移文件python manage.py migrate ---&gt; 执行迁移Teacher.objects.filter(nums=tnums).first() ---&gt; 获取nums和tnums相等的教师的所有信息request.path ---&gt; 得到请求路径request.method ---&gt; 得到请求方法request.POST.get('username', '') ---&gt; 获取post请求提供的username对应的值,若没有username对应的值则获取空串return JsonResponse(data) ---&gt; 直接返回json格式的数据render(request, ) ---&gt; 渲染页面,必定有request参数redirect() ---&gt; 页面重定向pip install -r requirements.txt ---&gt; 根据依赖项文件安装依赖pip freeze &gt; requirements.txt ---&gt; 重写依赖项清单 6. 最后小结项目流程django-admin startproject 项目名称 —&gt; 创建项目git init —&gt; 将项目文件夹初始化成git仓库vim .gitignore —&gt; 创建.gitignore文件,将不进行版本控制的文件名放进去,gitignore.io —&gt; 版本忽略文件生成网站vim requirements.txt —&gt; 创建项目依赖项文件 12345678加入项目需要的依赖项Django==2.2.9django-jet==1.0.8django-redis==4.11.0mysqlclient==1.4.6pytz==2019.3redis==3.3.11sqlparse==0.3.0 版本控制git add . git status git commit -m &apos;项目初始版本&apos; git status git log git tag v0.1 git remote add origin git@gitee.com:anjhon1994/djangocase.git # 地址关联 git remote remove origin # 取消关联 rm -rf .git # 取消仓库初始化 git push -u origin master # 推送 git remote -v # 查看远端仓库的地址 🌞相关文档连接: 点击下载本文完整代码 MDN-Django介绍 大佬详细教程","categories":[{"name":"Django","slug":"Django","permalink":"https://anjhon1994.github.io/categories/Django/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://anjhon1994.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"后端","slug":"后端","permalink":"https://anjhon1994.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Django","slug":"Django","permalink":"https://anjhon1994.github.io/tags/Django/"}]},{"title":"浅浅浅谈数据库","slug":"浅浅浅谈数据库","date":"2019-12-27T16:00:00.000Z","updated":"2020-01-13T06:01:32.051Z","comments":true,"path":"2019/12/28/浅浅浅谈数据库/","link":"","permalink":"https://anjhon1994.github.io/2019/12/28/%E6%B5%85%E6%B5%85%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"数据库一周小结","text":"数据库一周小结 数据库主要分为两大类,分别是关系型数据库(SQL)和非关系型数据库(NOSQL);在关系型数据库中Oracle和MySQL是最具有代表性的两个,在非关系型数据库中MongoDB和Redis也是榜上有名. 而本周的学习中,主要对MySQL和Redis进行了深入的学习. MySQLMySQL主要使用SQL语言进行增删查改操作;SQL是一种结构化查询语言,SQL语言又分为DDL(数据定义语言), DML(数据操作语言), DCL(数据控制语言) DDL数据库操作1.创建数据库 1CREATE DATABASE IF NOT EXISTS DEFAULT CHARSET utf8; --若dbname不存在,则按编码方式为utf8来新建数据库 2.删除数据库 1DROP DATABASE IF EXISTS dbname; -- 若数据库dbname存在就删除该数据库 3.切换/使用数据库 1USE dbname; -- 切换后执行的操作均只对当前数据库有效 数据表操作1.创建数据表 12345678910111213141516171819CREATE TABLE IF NOT EXISTS tablname(filed1 type constraint1, filed2 type constraint2, ...); -- 创建以field1,filed2..为表头的数据表-- 在SQL中常见的type: int, float, varchar/text, bit, date (varchar后通常需要限制字符串的长度)-- 常见的constraint: not null, unique, default, primary key, foreign key, auto_increment--注:外键约束的类型有一对一,一对多,多对多三种, 外键添加的方式各不相同-- 一对一: 可以添加到任意一方;-- 一对多和多对一: 添加到多的一方;-- 多对多: 两张表没有办法直接建立多对多的对应关系,需要第三张表辅助-- 示例:CREATE TABLE IF NOT EXISTS tb_student(stuid INT PRIMARY KEY auto_increment,stuname VARCHAR(20) NOT NULL,stubirth DATE,stugender bit DEFAULT 1,stutel VARCHAR(11) UNIQUEPRIMARY KEY (stuid) 主键约束还可以单独设置); 2.删除表 1DROP TABLE IF EXISTS tablname; 3.修改表 ①:添加字段 1ALTER TABLE tablname ADD COLUMN field type constraint; ②:删除字段 1ALTER TABLE tablname DROP COLUMN field; ③:修改字段名 1ALTER TABLE tablname CHANGE field new_filed new_type; ④:添加约束 1ALTER TABLE tablname ADD CONSTRAINT consname constraint(filed); ⑤:删除约束 12ALTER TABLE tablname DROP INDEX constraint;ALTER TABLE tablname DROP FOREIGN KEY constraint; DML1.INSERT(增) 1INSERT INTO tablname(field1, field2, ...) VALUES(value1, value2, ...),(value11, value22, ...), (value111, value222, ...), ...; 2.DELETE(删) 1234567891011121314151617DELETE FROM tablename WHERE 条件语句;-- 补充:sq1条件语句的写法(筛选)(条件语句在写的时候可以通过加()改变运算顺序)-- 比较运算:=(等于),&lt;&gt;(不等于),&gt;,&lt;,&gt;=,&lt;=DELETE FROM tb_student WHERE stuname='真刚';-- 逻辑运算:and(逻辑与),or(逻辑或),not(逻辑非);DELETE FROM tb_student WHERE stuid&gt;=35 AND stugender&lt;&gt;1;-- 集合包含:inDELETE FROM tb_student WHERE stuname in ('逍遥子', '韩信', '断水');-- 范围:between...andDELETE FROM tb_student WHERE stubirth BETWEEN '1976-8-21' AND '1976-8-31';-- 判断是否为空:is null,is not nullDELETE FROM tb_student WHERE (stubirth IS NULL) AND (stutel IS NULL);-- 筛选:like(% -&gt; 任意个任意字符; _ -&gt; 表示单个任意字符)DELETE FROM tb_student WHERE stuname LIKE '盖_ ';DELETE FROM tb_student WHERE stutel LIKE '%2_'; 3.UPDATE(改) 1UPDATE tablname SET field1=value1, field1=value2, ... WHERE 条件语句; 4.SELECT(查) 123456789101112131415161718192021222324252627282930313233343536373839404142434445SELECT * FROM tablname; --查询表内所有内容SELECT field1, field2, field3, ... FROM tablname; --获取表中所有记录指定字段的数据SELECT field1 AS 'new_filed1', field2, field3 AS 'new_field3', ... FROM tablname; --列重名SELECT IF(field1, value1, value2) FROM tablname; --如果if中对应的字段的值是1,最后结果是value1,否则是value2(mysql特有写法)SELECT CASE field WHEN 1 THEN new_value1 ELSE new_value2 END FROM tablname;SELECT CONCAT(field1, field2, ...) FROM tablname;SELECT * FROM tablname ORDER BY field;SELECT * FROM tablname ORDER BY field DESC; -- 倒序SELECT DISTINCT field FROM tablname; -- 去重SELECT * FROM tablname LIMIT N; -- 限制(获取前N条数据)-- 跳过前N条数据获取M条数据(从第N+1条数据开始,获取M条数据)SELECT * FROM tablname LIMIT M OFFSET N;SELECT * FROM tablname LIMIT N, M; -- 聚合-- MAX(), MIN(), SUM(), AVG(), COUNT() -&gt; MySQL专用SELECT MAX(score) AS '最高分' FROM tb_record;SELECT MIN(score) AS '最低分' FROM tb_record;SELECT SUM(score) AS '总分' FROM tb_record; -&gt; -- 求和所有分数的和,如果某一个记录的分数是空,那么这条记录不存与运算SELECT AVG(score) AS '平均分' FROM tb_record; SELECT COUNT(score) AS '个数' FROM tb_record; -- 分组SELECT 聚合操作 FROM tablname GROUP BY (field); -- 分组后要加条件,则用having代替where-- 子查询-- ①:将一个查询的结果作为另外一个查询的条件-- ②:将一个查询的结果作为另外一个查询的对象(注: 若将查询结果作为查询对象,则必须在使用时用as重命名)-- 连接查询--①:内连接SELECT * FROM tablname1, tablname2, ... WHERE 连接条件 查询条件;SELECT * FROM tablname1 INNER JOIN tablname2 ON 连接条件1 INNER JOIN tablname3 ON 连接条件2;(注意:如果有中间表,中间表放在最前面)--注意:如果既有连接条件又有查询条件,查询条件必须放在连接条件的后面--②:外连接--在MySQL中只支持左外连接(LEFT JOIN)和右外连接(right join)左连接: SELECT * FROM 表1 LEFT JOIN 表2 : 先将表1中的记录全部取出来,按连接条件依次连接表2中的记录,表1中的记录找不到满足条件,则表2记录那么连接的内容就是空右连接: SELECT * FROM 表1 RIGHT JOIN 表2 : 先将表2中的记录全部取出来,按连接条件依次连接表1中的记录,表2中的记录找不到满足条件,则表1记录那么连接的内容就是空 DCL用户管理1.创建用户 12345CREATE USER 'username'@'登陆地址' identified by 'password';-- 注:登录地址有三种写法:-- ip地址-- localhost(本机)-- %(任意位置) 2.删除用户 1DROP USER 'username'; 授权管理1.授权 1GRANT 权限类型 ON dataname.tablname TO 'username'@'登陆地址'; 2.召回权限 1REVOKE 权限类型 ON dataname.tablname FROM username; 事务若完成一个任务需要多个操作,但只要有一个失败则任务不完成,数据回到任务开始前的状态;只有所有操作都成功了,数据库才更新;此时用事务语法 12345BEGIN; -- 开启事务环境 UPDATE tb_student SET stubirth='1993-1-1' WHERE stusex=0;DELETE FROM tb_student WHERE stuname LIKE '杨%'COMMIT; -- 提交事务环境中的操作结果ROLLBACK; 视图1CREATE VIEW 视图名 AS sql查询语句; 索引12345--①:添加索引CREATE INDEX 索引名 ON 表名(字段); -- 给指定字段添加索引CREATE UNIQUE INDEX 索引名 ON 表名(字段); -- 给指定字段添加唯一索引--②:删除索引ALTER TABLE tablname DROP INDEX 索引名; RedisRedis命令ttl key ——&gt; 查看key的存活时间set key value ex N ——&gt; 设置key的存活时间为N秒set key value px N ——&gt; 设置key的存活时间为N毫秒shutdown ——&gt; 关闭redis服务器shutdown save ——&gt; 保存并关闭redis服务器save ——&gt; 保存bgsave ——&gt; 后台保存dbsize ——&gt; 查看数据库大小keys * ——&gt; 获取所有的keykeys ta* ——&gt; 获取ta开头的key redis默认开启了16个数据库select 0-15 ——&gt; 切换数据库flushdb ——&gt; 清空当前数据库flushall ——&gt; 清空所有数据库 type keyp ——&gt; 判断key的类型 Redis的数据类型1.字符串 - string123456789101112set key valueget keystrlen keyappend key value ------&gt; 追加mset key1 value1 key2 value2 ... ------&gt; 同时设置多组值mget key1 key2 ...incr key ------&gt; 当key的值为数字时,数值加一incrby key N ------&gt; 为key的值加Ndecr key ------&gt; 减一decrby key N ------&gt; 减Ngetrange key m n ------&gt; 从m取到nsetrange key N value ------&gt; 从n开始用value覆盖key的value值 2.哈希 - hash12345678hset key field value 设置键和值hmset key field1 value1 field2 value2 同时设置多个键和值hget key field 查看指定的键对应的值hmget key fieldl field2 同时查看多个键和值hgetall key 获取所有的值和键hkeys key 获取所有的键hvals key 获取所有的值hexists key filed 判断是否存在对应的值 3.列表 - list12345678lpush list value1 value2 ... 插入到最左边rpush list value1 value2 ... 插入到最右边lpop list 取最左边rpop list 取最右边lrange list start end 查看列表片段lindex list index 查看指定下标对应的元素llen list 列表长度lrem list count value 删除指定个数的元素 4.集合 - set123456789sadd set value1 value2 ... 添加元素srem set value 移除元素spop set 获取随机元素smembers set 查看所有元素sismember set value 查看元素是否在集合内scard set 查看元素个数sinter set1 set2 交集sunion set1 set2 并集sdiff set1 set2 差集 5.有序集合 - zset(元素自带一个值,可以修改)123456zadd zset score1 mem1 score2 mem2 ... 添加zrem zset mem 移除zrange zset start end 按score升序查看zrevrange zset start end 按score降序查看zscore zset mem 查看score值zincrby zset value mem 改变score的值 6.地理位置(LBS应用-Location-Based Service - 基于位置的服务)1234geoadd zset longitude1 latitude1 member1 longitude2 latitude2 member2 ... 添加经纬度信息geopos zset member1 member2 ... 获取指定的位置的经纬度geodist zset member1 member2 [unit] 计算两点间的距离,默认单位是米,[unit]是单位,可以修改为m,km,mi英里,ft英尺georadius zset longitude1 latitude1 radius m/km/mi/ft 获取以点zset为圆心,radius为半径的圆的范围内的所有的坐标点;后面加withdist,可同时获取距离,加withcoord,可同时获取点的经纬度 Python中使用数据库连接MySQL数据库123456789101112131415161718192021222324252627282930313233343536\"\"\"连接对象 = pymysql.connect(host, port, user, password) - 和指定的数据库进行连接并返回一个连接对象参数说明: host - MySQL主机地址: localhost表示当前设备上的MySQL,服务器的公网IP port - MySQL服务端口,3306 user - MySQL用户 password - 用户对应的密码(如果创建用户的时候没有设置密码,这个参数可以不用赋值) database - 建立连接后默认操作的数据库 charset - 设置连接的数据库文件的编码方式 autocommit - 是否自动提交(布尔值) with 连接对象.cursor(查询返回值类型(默认值是none)) as 游标对象: 数据库操作上下文 说明: 查询返回值类型 - None: 查询结果以元组的形式返回; pymysql.cursors.dictcursor: 查询结果以字典的形式返回; 数据库操作上下文 - 游标对象(数据库操作)只有在数据库操作上下文才有效\"\"\"con = pymysql.connect( host='localhost', port=3306, user='root', password='123456', database='school', charset='utf8', autocommit='True')with con.cursor() as cursor: # 数据库操作上下文 # 3.执行sql语句: 游标对象.execute(sql语句) cursor.execute('create database if not exists pyschool;')# 关闭连接con.close() 连接Redis服务器12345678redis.Redis(host='', password='', prot='')host : redis所在服务器公网地址;password : 登录口令;port : redis的服务端口连接时会返回一个连接对象:redis_cli = redis.Redis(host='', password='', prot='')使用redis完成相应的操作 扩展: 123456789pip freeze &gt; requirement.txt 将虚拟环境依赖项写入到文件pip install -r requirement.txt 按照文件安装依赖项序列化: 把一个对象变成字符串(str)或字节串(bytes)反序列化: 把字符串或者字节串还原成对象json.dumps() 序列化(字符串转换成字节串)json.loads() 反序列化(字节串转换成字符串)pickle.dumps() 序列化(字符串转换成字节串)pickle.loads() 反序列化(字节串转换成字符串) 将Redis作为用户请求和MySQL数据库之间的缓存介质123456789101112131415161718192021222324252627282930313233343536373839404142434445import pymysqlimport redisimport pickleimport timedef load_depts_from_db(): conn = pymysql.connect( host='localhost', port=3306, user='root', password='119148', charset='utf8', autocommit=True, database='hrs' ) depts = () try: with conn.cursor() as cursor: cursor.execute('select dno, dname, dloc from tb_dept') depts = cursor.fetchall() except pymysql.MySQLError as err: print(err) finally: conn.close() return deptsdef main(): redis_cli = redis.Redis(host='49.233.152.190', port=6379, password='119148') start = time.time() data = redis_cli.get('depts') if data: depts = pickle.loads(data) else: depts = load_depts_from_db() redis_cli.set('depts', pickle.dumps(depts)) end = time.time() print(depts) print(f'执行时间: &#123;end - start&#125;秒')if __name__ == '__main__': main()","categories":[{"name":"数据库","slug":"数据库","permalink":"https://anjhon1994.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://anjhon1994.github.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://anjhon1994.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","permalink":"https://anjhon1994.github.io/tags/Redis/"}]},{"title":"Redis及其应用","slug":"后端/radis","date":"2019-12-26T16:00:00.000Z","updated":"2020-01-13T05:58:39.119Z","comments":true,"path":"2019/12/27/后端/radis/","link":"","permalink":"https://anjhon1994.github.io/2019/12/27/%E5%90%8E%E7%AB%AF/radis/","excerpt":"非关系型数据库RedisRedis是为了实现高速缓存服务,减小MySQL数据库的压力","text":"非关系型数据库RedisRedis是为了实现高速缓存服务,减小MySQL数据库的压力 Linux服务起停CentOS systemctl start 服务名 -&gt; 启动 systemctl stop 服务名 -&gt; 停止 systemctl restart 服务名 -&gt; 重启 systemctl status 服务名 -&gt; 查看状态 systemctl enable 服务名 -&gt; 开机自启 systemctl disable 服务名 -&gt; 禁止自启 Ubuntu service 服务名 start -&gt; 启动 进程查杀ps -ef | grep “” -&gt; 搜索全部包含字符串的内容ps -ef | grep “” | grep -v “grep” -&gt; 搜索全部包含字符串的内容并且过滤掉包含grep的内容ps -ef | grep -E正则表达式 -&gt; 搜索全部包含符合正则表达式的内容xargs -&gt; 将列变成行ps -ef | grep “redis-server” | grep -v “grep” | awk ‘{print $2}’ | xargs kill -&gt; 精准查杀进程 pkill 进程名 -&gt; 根据名字杀掉进程killall 进程名 -&gt; 根据名字杀掉进程 redis命令ttl key ——&gt; 查看key的存活时间set key value ex N ——&gt; 设置key的存活时间为N秒set key value px N ——&gt; 设置key的存活时间为N毫秒shutdown ——&gt; 关闭redis服务器shutdown save ——&gt; 保存并关闭redis服务器save ——&gt; 保存bgsave ——&gt; 后台保存dbsize ——&gt; 查看数据库大小keys * ——&gt; 获取所有的keykeys ta* ——&gt; 获取ta开头的key redis默认开启了16个数据库select 0-15 ——&gt; 切换数据库flushdb ——&gt; 清空当前数据库flushall ——&gt; 清空所有数据库 type keyp ——&gt; 判断key的类型 redis的数据类型1.字符串 - string123456789101112set key valueget keystrlen keyappend key value ------&gt; 追加mset key1 value1 key2 value2 ... ------&gt; 同时设置多组值mget key1 key2 ...incr key ------&gt; 当key的值为数字时,数值加一incrby key N ------&gt; 为key的值加Ndecr key ------&gt; 减一decrby key N ------&gt; 减Ngetrange key m n ------&gt; 从m取到nsetrange key N value ------&gt; 从n开始用value覆盖key的value值 2.哈希 - hash12345678hset key field value 设置键和值hmset key field1 value1 field2 value2 同时设置多个键和值hget key field 查看指定的键对应的值hmget key fieldl field2 同时查看多个键和值hgetall key 获取所有的值和键hkeys key 获取所有的键hvals key 获取所有的值hexists key filed 判断是否存在对应的值 3.列表 - list12345678lpush list value1 value2 ... 插入到最左边rpush list value1 value2 ... 插入到最右边lpop list 取最左边rpop list 取最右边lrange list start end 查看列表片段lindex list index 查看指定下标对应的元素llen list 列表长度lrem list count value 删除指定个数的元素 4.集合 - set123456789sadd set value1 value2 ... 添加元素srem set value 移除元素spop set 获取随机元素smembers set 查看所有元素sismember set value 查看元素是否在集合内scard set 查看元素个数sinter set1 set2 交集sunion set1 set2 并集sdiff set1 set2 差集 5.有序集合 - zset(元素自带一个值,可以修改)123456zadd zset score1 mem1 score2 mem2 ... 添加zrem zset mem 移除zrange zset start end 按score升序查看zrevrange zset start end 按score降序查看zscore zset mem 查看score值zincrby zset value mem 改变score的值 6.地理位置(LBS应用-Location-Based Service - 基于位置的服务)1234geoadd zset longitude1 latitude1 member1 longitude2 latitude2 member2 ... 添加经纬度信息geopos zset member1 member2 ... 获取指定的位置的经纬度geodist zset member1 member2 [unit] 计算两点间的距离,默认单位是米,[unit]是单位,可以修改为m,km,mi英里,ft英尺georadius zset longitude1 latitude1 radius m/km/mi/ft 获取以点zset为圆心,radius为半径的圆的范围内的所有的坐标点;后面加withdist,可同时获取距离,加withcoord,可同时获取点的经纬度 加密技术对称加密 : 加密和解密使用相同的密钥 - AES非对称加密 : 加密和解密使用不同的密钥(公钥和私钥) - 适合互连网 - RSA 免密操作 12345678910ssh-keygen -t rsa -b 2048 -c anjhon@163.com - 生成公钥和私钥t 指定算法; b 指定强度; c 指定邮箱进入到.ssh文件,id_rsa - 私钥id_rsa.pub - 公钥将公钥复制到网站的公钥设置若有known-hosts文件,且网站链接不上,直接删除known-hosts文件 Python中的redis连接redis服务器: 12345678redis.Redis(host='', password='', prot='') host : redis所在服务器公网地址; password : 登录口令; port : redis的服务端口 连接时会返回一个连接对象:redis_cli = redis.Redis(host='', password='', prot='')使用redis完成相应的操作 python中使用redis的数据类型: 123456789101112131415161718192021222324252627282930313233343536373839import redis # 导入redis模块redis_cli = redis.Redis(host='10.10.10.10', password='123456', port='6379') # 连接redis服务器# print(redis_cli)if redis_cli.ping(): # hash的使用 redis_cli.hmset('stu1', &#123; 'stuname': 'xiaoming', 'stuid': '001', 'stusex': '1', 'stuaddr': '肖家河' &#125;) print(redis_cli.hget('stu1', 'stuname')) # 有序集合的使用 redis_cli.zadd('zset1', &#123; 'an': 100, 'yong': 200, 'duan': 300 &#125;) items = redis_cli.zrevrange('zset1', 0, -1) print(list(map(bytes.decode, items))) print(redis_cli.zscore('zset1', 'an')) # 列表的使用 redis_cli.rpush('list1', 1, 2, 3, 4, 5) list1 = redis_cli.lrange('list1', 0, -1) print(list(map(int, list1))) # 字符串的使用 redis_cli.set('username', 'an') print(redis_cli.ttl('username')) print(redis_cli.get('username').decode('utf-8')) redis_cli.set('user_age', '25') redis_cli.set('user_tel', '133')else: print('连接失败') 扩展: 123456789pip freeze &gt; requirement.txt 将虚拟环境依赖项写入到文件pip install -r requirement.txt 按照文件安装依赖项序列化: 把一个对象变成字符串(str)或字节串(bytes)反序列化: 把字符串或者字节串还原成对象json.dumps() 序列化(字符串转换成字节串)json.loads() 反序列化(字节串转换成字符串)pickle.dumps() 序列化(字符串转换成字节串)pickle.loads() 反序列化(字节串转换成字符串) 数据上传redis服务器并从redis获取数据 12345678910111213141516171819202122232425262728import redisimport pickleclass Student: def __init__(self, name, age, sex, addr): self.name = name self.age = age self.sex = sex self.addr = addr def __repr__(self): # 魔法方法(将数据显示出来) return '%s, %d, %s, %s' % (self.name, self.age, self.sex, self.addr)stu1 = Student('小明', 20, '男', '昆明')stu2 = Student('小黄', 30, '女', '上海')list1 = [stu1, stu2] # 将学生对象添加到列表中redis_cli = redis.Redis(host='10.10.10.10', password='123456', port='6379') # 连接redis服务器if redis_cli.ping(): # redis_cli.set('student_all', pickle.dumps(list1)) - 将本地的数据添加到redis redis_stu = pickle.loads(redis_cli.get('student_all')) # 获取redis内的数据并进行反序列化 print(redis_stu)else: print('连接失败') 将redis作为用户请求和数据库之间的缓存介质 123456789101112131415161718192021222324252627282930313233343536373839404142434445import pymysqlimport redisimport pickleimport timedef load_depts_from_db(): conn = pymysql.connect( # 连接本地的MySQL服务器 host='localhost', port=3306, user='root', password='123456', charset='utf8', autocommit=True, database='hrs' ) depts = () try: # 异常捕获 with conn.cursor() as cursor: cursor.execute('select dno, dname, dloc from tb_dept') # 获取数据 depts = cursor.fetchall() except pymysql.MySQLError as err: print(err) finally: conn.close() return deptsdef main(): redis_cli = redis.Redis(host='10.10.10.10', password='123456', port='6379') start = time.time() data = redis_cli.get('depts') # 获取redis的depts对应的数据 if data: depts = pickle.loads(data) # 若获取到数据,将数据反序列化并保存下来 else: depts = load_depts_from_db() # 若没有数据,从数据库获取数据,并将数据保存到redis中,以便下次使用时优先从redis中获取,以减轻服务器的压力并且提高数据获取效率 redis_cli.set('depts', pickle.dumps(depts)) end = time.time() print(depts) print(f'执行时间: &#123;end - start&#125;秒')if __name__ == '__main__': main()","categories":[{"name":"数据库","slug":"数据库","permalink":"https://anjhon1994.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"数据库","permalink":"https://anjhon1994.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"redis","slug":"redis","permalink":"https://anjhon1994.github.io/tags/redis/"}]},{"title":"MySQL基础","slug":"SQL基础","date":"2019-12-24T16:00:00.000Z","updated":"2020-01-13T02:38:35.568Z","comments":true,"path":"2019/12/25/SQL基础/","link":"","permalink":"https://anjhon1994.github.io/2019/12/25/SQL%E5%9F%BA%E7%A1%80/","excerpt":"关系型数据库之MySQL","text":"关系型数据库之MySQL SQL基础SQL又叫结构化查询语言,分为三大类,分别是:DDL(数据定义语言),DML(数据操作语言),DCL(数据控制语言)DDL:create(创建数据库和表)、drop(删除数据库和表)、alter(修改表)DML:insert(增)、delete(删)、update(改)、select(查)DCL:grant(授权)、revoke(召回授权) sql的注释是在注释前加–sql中sql的关键字不区分大小写sq语句结束后需要加分号 DDL(数据定义)数据库操作1.创建数据库CREATE DATABASE 数据库名称; —&gt; 创建指定数据库，如果这个数据库已经存在，会报错CREATE DATABASE IF NOT EXISTS 数据库名称; —&gt; 当指定数据库不存在的时候创建对应的数据库CREATE DATABASE IF NOT EXISTS 数据库名称 DEFAULT CHARSET utf8; —&gt; 创建数据库的时候指定数据文件编码方式CREATE DATABASE school; 2.删除数据库DROP DATABASE 数据库名称;DROP DATABASE IF EXISTS 数据库名;DROP DATABASE school;DROP DATABASE IF EXISTS school; 3.切换/使用数据库USE 数据库; -&gt; 切换/使用指定数据库；切换后所有数据库相关操作都是针对这个数据库USE school; 数据表操作1.创建表（数据库文件是通过表来存数据）CREATE TABLE IF NOT EXISTS 表名(字段名1 类型1 约束1, 字段名2 类型2 约束2, …);说明:①:表名:程序员自己命名,见名知义,一般需要加前缀t_/tb_示表②:字段名:程序员自己命名,见名知义;注意:字段中一定要有一个字段来作为主键(可以表示唯一一条记录);主键要求不为空,并且是唯一的,而且数据类型是整型③:类型名:必须是当前数据库支持的数据类型,mysql中常用的数据类型:int(整型),float(浮点型),varchar(字符串)/text(字符串),bit(布尔),date/datet ime(日期和时间)④:约束:not null(非空约束)、unique(唯一约束)、default(默认值约束)、primary key(主键约束)、foreign key(外键约束)、auto_increment(自动增长) 注意:约束可以没有,也可以有多个 123456789CREATE TABLE IF NOT EXISTS tb_student(stuid INT PRIMARY KEY auto_increment,stuname VARCHAR(20) NOT NULL,stubirth DATE,stugender bit DEFAULT 1,stutel VARCHAR(11) UNIQUEPRIMARY KEY (stuid) 主键约束还可以单独设置); 2.删除表DROP TABLE IF EXISTS 表名;DROP TABLE IF EXISTS tb_student; 3.修改表3.1 添加字段ALTER TABLE 表名 ADD COLUMN 字段名 类型 约束;ALTER TABLE tb_student ADD COLUMN stuaddr VARCHAR(200); 3.2 删除字段ALTER TABLE 表明 DROP COLUMN 字段名;ALTER TABLE tb_student DROP COLUMN stuaddr; 3.3 修改字段名ALTER TABLE 表名 CHANGE 原字段 新字段 新类型;ALTER TABLE tb_student CHANGE tel stutel VARCHAR(11); 3.4 添加约束3.4.1 创建表或添加字段的时候直接在字段后面添加约束3.4.2 通过修改表的样式添加约束ALTER TABLE 表名 ADD CONSTRAINT 约束索引名 约束名(字段); -&gt; 给指定字段添加指定约束ALTER TABLE 表1 ADD CONSTRAINT 约束索引名 FOREIGN KEY(字段1) REFERENCES 表2(字段2); -&gt; 给表1中的字段1添加外键约束,并且字段1的值依赖表2中的字段2 3.5 删除约束ALTER TABLE 表名 DROP INDEX 约束索引名; -&gt; 删除指定约束ALTER TABLE 表名 DROP FOREIGN KEY 外键索引; -&gt; 删除外键约束 0ML(数据操作)1.INSERT(增)方法①:INSERT INTO 表名 VALUES(值1, 值2, 值3,…) -&gt; 按表中字段的顺序依次给每个字段赋值,最终形成一条新的记录说明: 日期(DATE) -&gt; 1)日期字符串:如: ‘2019-12-23’ 2)DATE((NOW())-当前日期; YEAR(NOW())-当前年; MONTH(NOW())-当前月; INSERT INTO tb_student VALUES(1, ‘天明’, ‘2000-10-2’, 1, ‘12345678901’); 方法②:INSERT INTO 表名(字段名1,字段名2,…) VALUES(值1,值2,…); -&gt; 按指定顺序给指定字段赋值,最终形成一条新的记录 INSERT INTO tb_student(stuname, stubirth, stugender, stutel) VALUES(‘少羽’, ‘2000-8-21’, 1, ‘12345678902’); 方法③:INSERT INTO 表名(字段名1,字段名2,…) VALUES(值1,值..…),(值11,值22,..),(值111,值2222,…),…; -&gt; 同时插入多条记录 1234567891011121314151617181920INSERT INTO tb_student(stuname, stubirth, stugender, stutel) VALUES('月儿', '2000-11-21', 0, '12345678903'),('卫庄', '1989-8-21', 1, '12345678904'),('盖聂', '1990-8-21', 1, '12345678905'),('胜七', '1977-8-21', 1, '12345678906'),('惊鲵', '1971-8-21', 0, '12345678907'),('掩日', '1972-8-21', 1, '12345678908'),('黑白玄鉴', '1970-8-21', 1, '12345678909'),('真刚', '1973-8-25', 1, '12345678910'),('断水', '1974-8-21', 1, '12345678911'),('赵高', '1976-8-31', 1, '12345678912'),('韩非', '1976-8-31', 1, '12345678913'),('韩信', '1976-8-31', 1, '12345678914'),('章邯', '1976-8-31', 1, '12345678915'),('鬼谷子', '1976-8-31', 1, '12345678916'),('东皇太一', '1976-8-31', 1, '12345678917'),('晓梦', '1976-8-31', 0, '12345678918'),('逍遥子', '1976-8-31', 1, '12345678919'),('赤炼', '1976-8-31', 1, '12345678920'),('高渐离', '1976-8-31', 1, '12345678921'); 2.DELETE(删)方法①:DELETE FROM 表名; -&gt; 删除当前表中所有的记录(清空表)DELETE FROM tb_student; 方法②:DELETE FROM 表名 WHERE 条件; -&gt; 删除所有满足条件的记录 补充:sq1条件语句的写法(筛选)(条件语句在写的时候可以通过加()改变运算顺序) 比较运算:=(等于),&lt;&gt;(不等于),&gt;,&lt;,&gt;=,&lt;=DELETE FROM tb_student WHERE stuname=’真刚’; 逻辑运算:and(逻辑与),or(逻辑或),not(逻辑非);DELETE FROM tb_student WHERE stuid&gt;=35 AND stugender&lt;&gt;1; 集合包含:inDELETE FROM tb_student WHERE stuname in (‘逍遥子’, ‘韩信’, ‘断水’); 范围:between…andDELETE FROM tb_student WHERE stubirth BETWEEN ‘1976-8-21’ AND ‘1976-8-31’; 判断是否为空:is null,is not nullDELETE FROM tb_student WHERE (stubirth IS NULL) AND (stutel IS NULL); 筛选:like(% -&gt; 任意个任意字符; _ -&gt; 表示单个任意字符)DELETE FROM tb_student WHERE stuname LIKE ‘盖_ ‘;DELETE FROM tb_student WHERE stutel LIKE ‘%2_’; 3.UPDATE(改)ALTER TABLE tb_student ADD COLUMN stuaddr VARCHAR(200); UPDATE 表名 SET 字段1=新值1,字段2=新值2,…; -&gt; 将指定表中所有记录中指定的字段修改成指定的值 UPDATE tb_student SET stuaddr=’成都’; UPDATE 表名 SET 字段1=新值1,字段2=新值2,… WHERE 条件; -&gt; 将满足条件的记录的指定字段设置为指定的值 UPDATE tb_student SET stuaddr=’昆明’ WHERE stugender=0; 4.SELECT(查)SELECT * FROM 表名; -&gt; 获取指定表中所有的记录中所有字段的数据 SELECT * FROM tb_student; 映射SELECT 字段1,字段2,字段3,… FROM 表名; -&gt; 获取表中所有记录指定字段的数据SELECT stuname, stugender, stuaddr FROM tb_student; 列重名SELECT 字段名1 AS ‘新字段名1’, 字段名2,字段名3 AS ‘新字段名3’, … FROM 表名;SELECT stuname AS ‘姓名’, stugender AS ‘性别’, stuaddr AS ‘地址’ from tb_student 结果重新赋值(主要针对布尔)SELECT IF(字段名, 值1, 值2) FROM 表名; -&gt; 一如果if中对应的字段的值是1,最后结果是值1,否则是值2(mysql特有写法) SELECT stuname AS ‘姓名’, IF(stugender, ‘男’, ‘女’) AS ‘性别’, stuaddr AS ‘地址’ from tb_student SELECT CASE 字段 WHEN 1或0 THEN 新值1 ELSE 新值2 END FROM 表名; SELECT stuname AS ‘姓名’, CASE stugender WHEN 1 THEN ‘男’ ELSE ‘女’ END AS ‘性别’, stuaddr AS ‘地址’ from tb_student 列合并(查询的时候将多个字段合并成一个数据返回结果)SELECT CONCAT(字段1,字段2,…) FROM 表名;SELECT CONCAT(stuname, stuid) as ‘姓名学号’ FROM tb_student; 筛选上面所有的查询语法的后面都可以加’where条件’对记录进行筛选SELECT * FROM 表名 WHERE 条件;SELECT stuname, stutel FROM tb_student WHERE stugender=0;SELECT * FROM tb_student WHERE stuname LIKE ‘月_’ 排序SELECT * FROM 表名 ORDER BY 字段; -&gt; 将查询结果按指定字段的值从小到大排序 SELECT * FROM tb_student ORDER BY stuid; SELECT * FROM 表名 ORDER BY 字段 ASC; -&gt; 将查询结果按指定字段的值从小到大排序SELECT * FROM 表名 ORDER BY 字段 DESC; -&gt; 将查询结果按指定字段的值从大到小排序 SELECT * FROM tb_student ORDER BY stuid DESC; SELECT * FROM 表名 ORDER BY 字段1 DESC, 字段2 DESC; -&gt; 将查询结果按指定字段的值从大到小排序 SELECT * FROM tb_student ORDER BY stugender DESC, stubirth; -&gt; 先按stugender从大到小排序;stugender相同再按stubirth从小到大排序 5.外键约束让两个表之间产生联系 添加外键约束的规范:一对一: 可以添加到任意一方;一对多和多对一: 添加到多的一方;多对多: 两张表没有办法直接建立多对多的对应关系,需要第三张表辅助 6.查询中的高级查询去重SELECT DISTINCT 字段名 FROM 表名; -&gt; 去除重复的项SELECT DISTINCT redate FROM tb_record; 限制和分页限制: SELECT * FROM 表名 LIMIT N; -&gt; 获取前N条数据SELECT * FROM tb_record LIMIT 5;偏移:①:SELECT * FROM 表名 LIMIT M OFFSET N; -&gt; 跳过前N条数据获取M条数据(从第N+1条数据开始,获取M条数据)②:SELECT * FROM 表名 LIMIT N, M; -&gt; 跳过前N条数据获取M条数据(从第N+1条数据开始,获取M条数据) 聚合max(), min(), sum(), avg(), count() -&gt; MySQL专用 12345SELECT MAX(score) AS '最高分' FROM tb_record;SELECT MIN(score) AS '最低分' FROM tb_record;SELECT SUM(score) AS '总分' FROM tb_record; -&gt; -- 求和所有分数的和,如果某一个记录的分数是空,那么这条记录不存与运算SELECT AVG(score) AS '平均分' FROM tb_record; SELECT COUNT(score) AS '个数' FROM tb_record; 分组SELECT 聚合操作 FROM 表名 GROUP BY (字段); -&gt; 按指定字段的值对表进行分组,然后对每个分组进行聚合操作注意:①分组后,除了分组字段以外,其他字段只能聚合操作②分组后要加条件,则用having代替where 123456-- 获取每个学生所有学科的平局分SELECT sid, AVG(score) FROM tb_record GROUP BY (sid);-- 获取每个学科的平局分SELECT cid, AVG(score) FROM tb_record GROUP BY (cid);-- 获取每个学生选的课程的数量SELECT sid, COUNT(cid) FROM tb_record GROUP BY (sid); 子查询①:将一个查询的结果作为另外一个查询的条件 12345678-- 例: 获取成绩是最高分的学生的idSELECT sid, score FROM tb_record WHERE score=(SELECT MAX(score) FROM tb_record);-- 例: 获取分数最高的三个学生SELECT sid FROM tb_record WHERE score IN (SELECT DISTINCT(score) FROM tb_record ORDER BY (score)DESC LIMIT 3);-- 例: 获取选了两门以上的课程的学生idSELECT sid FROM tb_record GROUP BY (sid) HAVING COUNT(cid)&gt;2;-- 例: 获取选了两门以上的课程的学生姓名SELECT stuname FROM tb_student WHERE stuid IN (SELECT sid FROM tb_record GROUP BY (sid) HAVING COUNT(cid)&gt;2); ②:将一个查询的结果作为另外一个查询的对象注: 若将查询结果作为查询对象,则必须在使用时用as重命名 12345SELECT * FROM tb_student LIMIT 4,5;SELECT stuname FROM (SELECT * FROM tb_student LIMIT 4,5) AS t1;SELECT stuname AS sname, stuaddr AS saddr FROM tb_student WHERE stusex=0;SELECT sname, saddr FROM (SELECT stuname AS sname, stuaddr AS saddr FROM tb_student WHERE stusex=0) AS t2 WHERE saddr LIKE '%成都'; 连接查询内连接①: SELECT * FROM 表名1, 表名2, … WHERE 连接条件 查询条件; 123-- 查询部门中薪水最高的人姓名、工资和所在部门名称SELECT dno, MAX(sal) FROM tb_emp GROUP BY(dno);SELECT ename, sal, dname FROM tb_emp, tb_dept, (SELECT dno AS dno2, MAX(sal) AS max_sal FROM tb_emp GROUP BY(dno)) AS t2 WHERE tb_emp.dno=tb_dept.dno AND tb_emp.dno=t2.dno2 AND sal=max_sal; ②: SELECT * FROM t1 INNER JOIN t2 ON 连接条件1 INNER JOIN t3 ON 连接条件2;(注意:如果有中间表,中间表放在最前面)注意:如果既有连接条件又有查询条件,查询条件必须放在连接条件的后面 12-- 查询部门中薪水最高的人姓名、工资和所在部门名称SELECT ename, sal, dname FROM tb_emp INNER JOIN tb_dept ON tb_emp.dno=tb_dept.dno INNER JOIN (SELECT dno AS dno2, MAX(sal) AS max_sal FROM tb_emp GROUP BY(dno)) AS t2 ON tb_emp.dno=t2.dno2 WHERE sal=max_sal; 外连接在MySQL中只支持左外连接(LEFT JOIN)和右外连接(right join) ①: 左连接: SELECT * FROM 表1 LEFT JOIN 表2 : 先将表1中的记录全部取出来,按连接条件依次连接表2中的记录,表1中的记录找不到满足条件,则表2记录那么连接的内容就是空 ②: 右连接: SELECT * FROM 表1 RIGHT JOIN 表2 : 先将表2中的记录全部取出来,按连接条件依次连接表1中的记录,表2中的记录找不到满足条件,则表1记录那么连接的内容就是空 DCL(数据控制)DCL主要提供授权和授权召回以及视图, 索引等相关功能 用户管理(一般只有root账号有此权限)创建用户CREATE USER ‘用户名‘@’登陆地址’; -&gt; 创建指定用户,用户登陆时不用输入密码CREATE USER ‘用户名‘@’登陆地址’ identified by ‘密码’; -&gt; 创建指定用户,用户登陆时需要输入密码说明:登录地址 -&gt; ip地址 localhost(本机) %(任意位置) 删除用户DROP USER ‘用户名’; 授权管理授权GRANT 权限类型 ON 数据库.表 TO ‘用户名‘@’登陆地址’; 说明:权限类型: insert, delete, update, select, create, drop, all privilege(所有权限); 召回权限REVOKE 权限类型 ON 数据库.表 FROM 用户名; 事务若完成一个任务需要多个操作,但只要有一个失败则任务不完成,数据回到任务开始前的状态;只有所有操作都成功了,数据库才更新;此时用事务语法 12345BEGIN; -- 开启事务环境 UPDATE tb_student SET stubirth='1993-1-1' WHERE stusex=0;DELETE FROM tb_student WHERE stuname LIKE '杨%'COMMIT; -- 提交事务环境中的操作结果ROLLBACK; 视图创建视图:CREATE VIEW 视图名 AS sql查询语句; 123-- 获取学生学科的成绩CREATE VIEW vw_stu_score ASSELECT stuid, stuname, couid, couname, score FROM tb_student, tb_record, tb_course WHERE tb_student.stuid=tb_record.sid AND tb_course.couid=tb_record.cid; 使用视图:(视图查询操作和表的查询操作基本一致,一般不增删改) 应用:方便查询,给权限不够的用户查看表内的部分信息. 索引索引就像书的目录,记录了数据的位置, 可以提高查询速度;给使用频率高的字段添加索引,(主键自带唯一索引) 添加索引:①: CREATE INDEX 索引名 ON 表名(字段); -&gt; 给指定字段添加索引 123EXPLAIN SELECT * FROM tb_student WHERE stuname='岳不群';CREATE INDEX idx_stuname ON tb_student(stuname);CREATE INDEX idx_stuaddr ON tb_student(stuaddr); ②: CREATE UNIQUE INDEX 索引名 ON 表名(字段); -&gt; 给指定字段添加唯一索引注意:模糊查询的时候如果以%和_开头则索引无效 删除索引:ALTER TABLE 表名 DROP INDEX 索引名; -&gt; 删除指定索引 12ALTER TABLE tb_student DROP INDEX idx_stuname;ALTER TABLE tb_student DROP INDEX idx_stuaddr;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://anjhon1994.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://anjhon1994.github.io/tags/MySQL/"},{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"数据库","permalink":"https://anjhon1994.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"vim基础使用教程","slug":"后端/vim编辑器的使用","date":"2019-12-22T16:00:00.000Z","updated":"2020-01-08T15:26:11.392Z","comments":true,"path":"2019/12/23/后端/vim编辑器的使用/","link":"","permalink":"https://anjhon1994.github.io/2019/12/23/%E5%90%8E%E7%AB%AF/vim%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"vim日常使用","text":"vim日常使用 1.vim的三种模式 命令模式：未尾既没有插入的字样也没有冒号（在编辑模式和末行模式下按esc键可以进入命令模式） 编辑模式：末尾会显示’一插入一/-insert-，并且在编辑模式下可以对文件进行输入操作（可以编辑）（在命令模式下按i就可以进入编辑模式） 未行模式：未尾显示冒号，并且冒号后边可以输入内容（在命令模式下输入冒号就可以进入未行模式） 2.vim的配置通过编辑 etc/vimrc 文件配置 3.基本操作1)保存和退出所有的保存和退出都是在末行模式下进行的W ——&gt;只保存(相当于ctr+s)q ——&gt;直接退出(只有当前文件的内容全部保存才能直接退出,如果不保存强制退出,需要在q加!)Wq ——&gt;先保存再退出注意:强制执行在指令后加! 2)光标操作所有光标操作对应的指令都是在命令模式下执行的^ ——&gt;直接将光标移动到行首$ ——&gt;直接将光标移动到行尾G ——&gt;移动到文件未尾gg ——&gt;移动到文件开头行号G ——&gt;移动到指定行号的位到 3)文本操作以下指令前面如果没有冒号表示在命令模式下执行，有冒号的在未行模式下执行 dd ——&gt;删除当前光标所在的行数字dd ——&gt;数字如果是N，从光标所在的位置开始删N行:%d ——&gt;末行模式下输入%d，删除所有 u ——&gt;撤销ctr+ r ——&gt;反撤销 yy ——&gt;复制光标所在的行数字yy ——&gt;数字如果是N,从光标所在的位置开始复制N行:%y ——&gt;未行模式下输入%y,复制所有p-粘贴p ——&gt;粘贴P ——&gt;粘贴到上一行 4)查找和替换: /正则表达式——&gt;查找当前文件中符合正则表达式的内容(结果可以用n和N来切换) 123456vim中正则表达式的要求:1)python正则中所有的语法都有效2)单独使用有特殊功能的符号，在使用的时候需要加\\才有效r'\\d+' -&gt; /\\d\\+r'\\d&#123;3&#125;' -&gt; /\\d\\&#123;3&#125;r'and|or' -&gt; /and\\|or :1,$s/被替换的对象对应的正则/替换内容/参数——&gt;将文件中正则匹配到的内容替换成指定内容 参数:g——&gt;全局匹配(会替换所有符合要求的字符串,默认情况下一行只替换一个)i——&gt;匹配的时候忽略大小写c——&gt;替换的时候给出提示e——&gt;忽略错误(忽略正则的错) 4高级操作1)比较文件vim -d 文件路径1 文件路径2 2)同时打开多个文件vim 文件路径 文件路径 … 1.切换窗口内容在末行模式下输入:ls——&gt;可以查看当前打开的所有的文件和文件对象的标号在末行模式下输入:b标号——&gt;可以将当前窗口中的内容切换到指定标号对应的文件的内容 2.窗口的拆分在未行模式下输入:sp/vs——&gt;可以将当前窗口垂直方向/水平方向进行拆分;拆分后可以在命令模式下按ctr+w来切换窗口","categories":[{"name":"Linux","slug":"Linux","permalink":"https://anjhon1994.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://anjhon1994.github.io/tags/Linux/"},{"name":"vim","slug":"vim","permalink":"https://anjhon1994.github.io/tags/vim/"}]},{"title":"shell编程","slug":"后端/shell编程","date":"2019-12-22T16:00:00.000Z","updated":"2020-12-28T15:05:12.198Z","comments":true,"path":"2019/12/23/后端/shell编程/","link":"","permalink":"https://anjhon1994.github.io/2019/12/23/%E5%90%8E%E7%AB%AF/shell%E7%BC%96%E7%A8%8B/","excerpt":"Shell脚本，是一种为shell编写的脚本程序。","text":"Shell脚本，是一种为shell编写的脚本程序。 shell编程Shell脚本，是一种为shell编写的脚本程序。 Shell编程跟JavaScript、Python编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 Linux的Shell种类有很多，我们主要用的是Bourne Shell(/usr.bin/sh或/bin/sh) 1.创建shell文件原则上shell程序可以写在任何文件中，但是一般会在shell文件后加后缀.sh表示当前文件是一个shell文件shell需要可执行权限，所以创建好的shell文件需要添加x权限 2.基础语法1）注释123456# 单行注释:&lt;&lt;EOF多行注释1多行注释2多行注释3EOF 2）输出和输入echo指令就相当于python中的print函数(默认会换行) 12echo 输出内容 echo -n 输出内容 # 输出的时候不换行 printf指令（输出不能换行） 1printf 输出内容 输入指令:read 变量名 – 输入内容，并且将输入的结果保存在变量中 3）变量a. 声明变量的语法: 变量名=值说明: a. 变量名和=, =和值之间不能有空格​ b. 变量名的要求和python变量名要求一样 123name='小明'age=18stu_name=小红 b. 使用变量:​ $变量​ ${变量} 123age=18echo $ageage2=$&#123;age&#125; c. 只读变量使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 123gender='男'readonly gendergender='女' # test.sh: line 17: gender: readonly variable d. 删除变量使用 unset 命令可以删除变量 12name='yuting'unset name 4）获取linux指令结果在shell脚本中可以直接写linux指令，在执行shell脚本的时候这些指令可以直接获取 1234567ls # ls指令ls -lh # ls指令，并且设置参数touch a.txt # 创建a.txt文件# 获取指令结果: 变量=$(指令) / 变量=`指令`lsresult=$(ls) #将ls指令的结果保存到变量lsresult中currnet_path=`pwd` 3.shell字符串shell中的字符串可以用单引号也可以使用双引号甚至可以不用引号。但是单引号中不能出现单引号字符，加\\也不行 12345678str1='abc'str2=\"abc\"str3=abcstr4='abc\\n123' #支持转义字符,但是不支持编码字符str5=\"abc\\n123\"age=18str6=\"年龄是$age\" #双引号里面可以出现变量,单引号不行 1）字符串拼接123456789str1=\"hello\"#单引号拼接str2=''$&#123;str1&#125;',world!'str3=''$str1',world!'#双引号拼接str4=\"$&#123;str1&#125;,world!\"str5=\"\"$str1\",world!\" 2）获取字符串长度12str1=\"abcd\"echo $&#123;#str1&#125; # 输出4 3）字符串提取12345# 字符串:下标:个数 --从字符串中指定下标开始获取指定个数字符,返回一个新的字符串# 字符串:下标:1 -- 获取字符串中指定下标对应的字符# 字符串:下标 -- 从指定下标开始获取到字符串最后string='hello world'echo $&#123;string:1:4&#125; # ello 4.shell数组在 Shell 中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为： 123456789101112# 数组名=(元素1 元素2 元素3 ...)names=(小明 小红 大黄 Tom)names2=('小明''小红''大黄''Tom')names3[0]=小明names3[1]=小红names3[2]=大黄names3[3]=Tom 1）获取数组元素：${数组[下标]}1echo $&#123;names[1]&#125; # 小红 2）获取数组的长度123456nums=(100 200 300 400)# 获取数组长度length=$&#123;#nums[@]&#125;length=$&#123;#nums[*]&#125;# 获取数组指定下标对应的元素的长度length2=$&#123;#num[n]&#125; 5.运算符shell中支持的运算符有: 算术运算符、关系运算符、布尔运算符、字符串运算符 1）算术运算符：+，-，*，/，%123456789101112131415161718192021222324252627282930# 如果想要在shell完成数值运算，运算的语法: `expr 运算表达式`; 并且运算符两边必须加空格re1=10+20echo $&#123;re1&#125; # 10+20# 1.加法运算re2=`expr 10 + 20` echo $&#123;re2&#125; # 30# 2.减法运算re3=`expr 10 - 20`echo $&#123;re3&#125; # -10# 3.乘法运算re4=`expr 10 \\* 20` # 注意:使用*作为乘法运算符的时候需要前面加\\echo $&#123;re4&#125; # 200# 4.除法运算# 小数除法运算: `echo \"scale=小数点位数;数值1 / 数值2\"|bc`# 整数除法运算: `expr 数值1 / 数值2`re5=`echo \"scale=2;7 / 3\"|bc`echo $re5re6=`expr 5 / 2`echo $re6# 5.求余数re7=`expr 10 % 3`re8=`echo \"10.2 + 5.1\"|bc`echo $re8 2） 关系运算符(比较运算符)，比较的是数字大小1234567891011121314151617# -eq --- 等于,相当于 ==# -ne --- 不等于,相当于!=# -gt --- 大于# -lt --- 小于# -ge --- 大于等于# -le --- 小于等于# 使用语法: [ 值1 关系运算符 值2 ]a=100b=10# 关系运算符要配合if语句或者循环语句使用if [ $a -gt $b ]then echo a大于belse echo a不大于bfi 3）布尔运算符(逻辑运算符)12345678910111213# ! -- 逻辑非运算# -o -- 逻辑或运算# -a -- 逻辑与运算age=18score=95# 参加比赛的条件：分数大于90分并且年龄大于等于18岁if [ $age -ge 18 -a $score -gt 90 ]then echo 可以参见比赛else echo 不能参加比赛fi 4）字符串运算符1234567891011121314151617181920212223# [ 字符串1 = 字符串2 ] -- 判断两个字符串是否相等# [ 字符串1 != 字符串2 ] -- 不相等# [ -z 字符串] -- 判断字符串长度是否为0# [ -n \"字符串\" ] -- 判断字符串长度是否不为0# [ $ 字符串 ] -- 判断字符串是否是空串a=\"abc\"b=\"123\"if [ $a = $b ]then echo a和b相等else echo a和b不相等fia=\"\"if [ -n \"$&#123;a&#125;\" ]then echo a的长度不为0else echo a的长度为0fi 6. if语句12345678910111213141516171819202122232425262728语法1：if 条件语句then 满足条件执行的代码fi语法2:if 条件语句then 满足条件执行的代码else 不满足条件执行的代码fi语法3：if 条件语句1then 代码块1elif 条件语句2then 代码块2elif 条件语句3then 代码块3else 代码块Nfi 7. for循环123456789101112131415161718192021222324语法:for 变量 in 序列do 循环体done# 遍历字符串for char in \"hello word\"do echo 循环体char: $&#123;char&#125;done# 遍历数组arr1=(10 20 \"abc\")for x in $&#123;arr1[@]&#125;do echo 循环体2x: $&#123;x&#125;done# 遍历多个值for x in 10 20 \"你好\" 123do echo 循环体3：$&#123;x&#125;done 8. while循环1234567891011121314151617181920212223242526272829303132333435语法:while 条件语句do 循环体done# 遍历字符串str1=\"helloWorld!\"index=0len=$&#123;#str1&#125;while [ $index -lt $len ]do echo $&#123;str1:$&#123;index&#125;:1&#125; index=`expr $&#123;index&#125; + 1`done# 计算1+2+3+...+100num=1sum=0while [ $&#123;num&#125; -le 100 ]do sum=`expr $&#123;sum&#125; + $&#123;num&#125;` num=`expr $&#123;num&#125; + 1`doneecho 1+2+3+...+100 = $&#123;sum&#125;# 死循环while truedo read -p \"请输入一个数字:\" num if [ $&#123;num&#125; == 100 ] then break fidone 9.函数1）函数的声明和调用123456789101112131415161718192021222324252627282930313233343536# 1.函数的声明声明的语法：函数名()&#123; 函数体&#125;调用函数语法: 函数名#声明函数func1()&#123; echo 你好函数1&#125;#调用函数func1# 2.有参数的函数# 声明的时候不需要形参, 直接在函数体中通过'$&#123;N&#125;'来获取第N个实参# 调用的时候: 函数名 实参1 实参2 实参3 ...func2()&#123; echo 函数2被调用 echo 第一个参数: $&#123;1&#125; echo 第二个参数: $&#123;2&#125; echo 第三个参数: $&#123;3&#125; &#125;func2 10 20 \"abc\"# 3.函数的返回值# return 数字 - 数字的范围是0~255func3()&#123; echo 函数3被调用 return 256 #a=`expr 100 + 200`&#125;func3echo $&#123;?&#125;","categories":[{"name":"Git & Shell","slug":"Git-Shell","permalink":"https://anjhon1994.github.io/categories/Git-Shell/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"shell","slug":"shell","permalink":"https://anjhon1994.github.io/tags/shell/"},{"name":"脚本","slug":"脚本","permalink":"https://anjhon1994.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"编程语言","slug":"编程语言","permalink":"https://anjhon1994.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"Linux常用指令","slug":"后端/Linux常用指令","date":"2019-12-21T16:00:00.000Z","updated":"2019-12-22T09:34:52.993Z","comments":true,"path":"2019/12/22/后端/Linux常用指令/","link":"","permalink":"https://anjhon1994.github.io/2019/12/22/%E5%90%8E%E7%AB%AF/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","excerpt":"Linux常用指令集","text":"Linux常用指令集 1. cd指令 - 进入文件夹cd ——&gt;文件夹路径（路径可以是绝对地址也可以是相对地址）-进入到指定路径对应的文件夹cd .. ——&gt;返回上层目录cd / ——&gt;进入系统根目录cd ~ ——&gt;进入电脑根目录 2. ls指令 - 显示当前目录中的内容ls ——&gt;直接显示当前文件夹中的内容的名字（隐藏文件和文件夹` 看不到）ls -l ——&gt;直接显示当前文件夹中的内容的名字（隐藏文件和文件夹看不到）ls -lh ——&gt;显示当前文件夹中的内容和内容的基本信息（隐藏文件和文件夹看不到）ls -a ——&gt;显示当前文件夹中所有的内容（包括隐藏文件）ls -R ——&gt;递归显示当前目录以及当前目录下所有的子目录中的内容ls -r ——&gt;内容倒序显示ls -S/-t ——&gt;显示文件夹中的内容，并且内容按大小/时间从大到小排序ls -Sr ——&gt;按文件大小从小到大排序ls -Srlh ——&gt;按文件大小从小到大排序，并且显示内容的基本信息 3. pwd指令pwd ——&gt;查看当前目录的绝对路径 4.文件操作1)touch指令 新建文件touch 文件路径文件名——&gt;在指定位置创建指定文件 123touch a.txt-在当前目录下新建一个文件a.txttouch ../a.txt ------&gt;在当前目录的上层目录新建一个文件a.txttouch /home/a/a.txt ------&gt;在根目录下home目录中的a目录里面创建一个文件a.txtl 2)cat指令 查看文件内容(读文件)cat 文件路径文件名 ——&gt;读取指定路径对应的文件的内容 3)vim指令vim 文件路径文件名 ——&gt;使用vim打开文件 5.文件操作mkdir 新文件夹路径文件夹名 ——&gt;在指定位置创建文件夹,若没有会报错mkdir -p 新文件夹路径文件夹名 ——&gt;在指定路径创建指定文件夹,若没有就创建mkdir -p a/{b,c,…}/{d,e,f,g,…} ——&gt;在当前位置创建a,在a内创建多个文件夹,在多个文件夹内再创建多个相同的文件夹 6.删除文件和文件夹1)rm指令 删除文件和文件夹rm 文件路径文件名 ——&gt;删除指定文件（删除的时候会循环是否确定删除，y-同意，n-不同意）rm -f 文件路径文件名 ——&gt;删除指定文件（删除的时候不询问）rm -r 文件夹路径文件夹名 ——&gt;删除指定文件夹 2)rmdir指令 删除空文件夹rmdir 文件夹路径——&gt;删除空文件夹 7拷贝和移动1)拷贝cp 文件路径1 文件路径2——&gt;将文件1中的内容复制粘贴到文件2（如果文件2不存，会自动创建；如果存在会询问是否覆盖）cp 文件路径 文件夹路径——&gt;将指定文件复制粘贴到指定文件夹中cp -r 文件夹路径1 文件夹路径2——&gt;将文件夹1复制粘贴到文件夹2中 2)移动mv 文件路径1 文件路径2 ——&gt;将文件1移动到文件2所在的位置mv 文件名1 文件名2 ** ——&gt;将文件1重命名为文件2(若两个文件同时存在同一文件夹中,则重命名后文件2会被删除,文件1会被重命名)**mv 文件路径 文件夹路径 ——&gt;将文件直接移动到指定文件夹中*mv 文件夹路径1 文件夹路径2 * ——&gt;将文件夹1移动到文件夹2中 8获取指令的历史记录history ——&gt;显示当前系统已经执行过的所有指令 如果想要显示历史记录的时候显示指令执行的时间需要修改~/.bashrc文件：export HISTTIMEFORMAT=”[%y-%m-%d_%T%M%S]”修改完成后需要通过指令：source ~/.bashrc去执行这个配置文件，最后历史记录的时间才会生效 9创建链接1)创建软链接ln -s 源文件路径 入口文件位置 ——&gt; 给源文件在指定位置创建一个软链接(软连接本质就是用来保存源文件绝对地址的一个文件) 注:源文件路径必须是绝对路径,如果删除或者移动源文件，软连接会直接无效 2)创建硬链接ln 源文件路径 硬连接文件地址 —–&gt;给源文件在指定位置创建一个硬链接硬链接的本质就是源文件内容的另外一个引用(相当于文件的另一个文件名)，所以删除或者移动源文件硬链接仍然有效，只是删除硬链接会变成普通文件 10进程相关指令1)ps指令ps ——&gt;查看当前进程状态ps -aux ——&gt;查看当前进程所有状态ps grep 进程名/id ——&gt;根据进程名/进程ID查看指定进程 2)top指令top ——&gt;实时查看当前所有的进程信息和系统信息top -p PID1,PID2,… ——&gt;实时监测指定的进程 3)free指令free ——&gt;显示当前系统的内存信息，显示的时候以kb为单位free -单位 ——&gt;显示当前系统的内存信息，以指定单位来显示 1free -m - 显示当前系统的内存信息，以Mb为单位 4)kill指令kill 进程ID ——&gt;杀掉指定ID对应的进程kill -1/-9/-15进程ID ——&gt;以指定的方式杀掉进程(-1表示不间断重启；-9表示强制杀死进程；-15表示正常结束进程)pkill 进程名 ——&gt;杀死指定进程名对应的进程（中间可以加-1/-9/-15）killall 进程名 ——&gt;杀死和进程名相关的所有进程 5)uptime指令uptime ——&gt;查看系统的基本信息(启动时间等) 11用户管理一个Linux操作系统可以有多个用户（user），也可以有多个用户组（group）；users ——&gt;查看当前用户groups ——&gt;查看当前分组groupadd 分组名 ——&gt;创建分组(管理员才能创建;可以通过查看/etc/group文件来查看当前系统所有的分组)useradd 用户名 ——&gt;创建指定用户(1.用户创建成功后系统会自动在/home目录下创建一个和用户名同名的文件夹;2.会自动创建和用户名同名的分组,并且将当前用户添加到这个分组中)useradd -G 分组1,分组2… 用户名 ——&gt;创建指定用户,并且将用户添加到指定分组usermod -G 分组1,分组2 用户名——&gt;修改用户分组password 用户名 ——&gt;修改用户密码(需要root权限)su 用户名 ——&gt;切换账号(root登录的时候切换不需要密码)exit ——&gt;退出当前账号 sudo -在命令前sudo是以管理员身份执行指令注意：不是所有的用户都可以通过sudo来以管理员身份执行指令，如果想要能够使用sudo必须添加配置 ①. ubuntu：将需要有管理员身份的账号添加到sudo分组中 ②. redhat和contos：在/etc/sudoers配置文件中添加代码： 123#Allow root to run any commands anywhereroot ALL=（ALL）ALL#（默认有的）xiaoming ALL=（ALL）ALL#（自己添加的，xiaoming是用户名） 12文件权限默认情况下文件和文件夹的权限:文件所有者有读写权限,同组用户和其他用户都是只读权限. 文件类型 所有者权限 同组用户权限 其他用户权限 d（目录） rwx r– — -（文件） rwx r– — l（连接） rwx r– — chmod 权限值 文件路径 ——&gt;将指定文件的权限修改成指定值chmod [a,u,g,o]/[+-]/[r,w,x] 文件地址 ——&gt;给指定文件对应指定用户添加或者删除指定权限(a-所有用户,u-文件所有者,g-同组用户,o-其他用户;+表示添加权限,表示删除权限;r-表示读权限,w表示写权限,x表示执行权限) 12chmod a-x 文件地址 #删除所有用户的执行权限chmod u+w 文件地址 #给文件所有者添加写的权限 13日志管理1)查看文件cat 文件 ——&gt;直接查看文件所有内容(查看文件内容的时候可以加参数-n，让内容在显示的时候显示行号) head -N 文件地址文件名 ——&gt;显示指定文件前N行内容tail -N 文件地址文件名 ——&gt;显示指定文件后N行内容 less 文件 ——&gt;按页显示文件内容(通过快捷键控制内容显示过程;文件内容不会打印到shel/终端里)less -N 文件 ——&gt;按页显示文件内容,每次翻页的时候翻N行more 文件 ——&gt;按页显示文件内容(通过快捷键控制内容显示过程;文件内容会打印到shell/终端里)more -N 文件 ——&gt;按页显示文件内容,每次翻页的时候翻N行 12345678快捷键:按j向下一行按k向上一行按f向下翻一页按b向上翻一页按g到全文开头按G到全文结尾按Q退出 2)文件处理凡是有的打印结果的指令,我们都可以通过相关指令对应结果进行处理如果需要对某一个指令的结果使用另外的指令进行二次处理的时候，就需要用到管道 | sort-排序sort ——&gt;从小到大排序(将一行内容作为一个字符串,按字符串大小对应内容进行排序,默认不区分大小写) 12345678910cat a.txt | sort ------&gt;对a.txt的文件内容从小到大排序显示参数:-r ------&gt; 逆序-nk 1 ------&gt;数值大小排序-nk 2 ------&gt;字符大小排序(默认)cat a.txt|sort -nk 1 ------&gt;对a.txt的文件内容按数字大小从小到大排序cat a.txt|sort -rnk 1 ------&gt;对a.txt的文件内容按数字大小从大到小排序cat a.txt|sort -nk 2 ------&gt;对a.txt的文件内容按字符大小从小到大排序(默)cat a.txt|sort -rnk 2 ------&gt;对a.txt的文件内容按字符大小从大到小排序 uniq-去重uniq ——&gt;只能将紧挨着的相同行去掉重复的(如果需要去掉所有重复的行,先排序将相同的行放到一起) 123cat a.txt | unkq ------&gt;去掉a.txt文件内容中相邻重复的行cat a.txt | sortluniq ------&gt;去掉a.txt文件内容中所有重复的行-c ------&gt;重复欠数 awk-获取列awk ‘{print $N}’ ——&gt;获取内容中第N列的数据 12historylawk '&#123;print $2&#125;'------&gt;获取历史记录第2列的内容historylawk'&#123;print $2,$3&#125;'------&gt;获取历史记录第2列和第3列的内容 练习:history | awk ‘{print $4}’|sort|uniq -c|sort -rnk 1|head -5显示最常用的指令和使用次数 3)输出重定向执行有打印结果的指令 &gt; 文件地址 ——&gt;将指定指令执行的结果保存到指定文件中(先清除原文件内容再添加)执行有打印结果的指令 &gt;&gt; 文件地址 ——&gt;将指定指令执行的结果保存到指定文件中(直接将结果追加到原文件中) history &gt; a.txt ——&gt;将当前历史记录直接保存到a.txt文件中 将最常用的3个指令及其使用次数保存到a.txt文件中history l awk’{print $4}’lsort luniq-c I sort-rnk 1 I head-n3&gt;a.txt 4)统计wc -c/-w/-l 文件地址 ——&gt;统计指定文件中字符/单词/行的数量 5)查找 查找文件内容 grep ①: grep 内容 文件地址文件名 ——&gt;在指定文件中查找指定内容(返回文件中所有包含指定内容的行) 12345678910grep you a.txt ------&gt;获取a.txt中包含you的所有的行grep的参数:-n ------&gt;显示结果的时候显示行号-i ------&gt;查找内容的时候忽略大小写-E ------&gt;按正则表达式进行匹配 使用方法: grep -E '正则表达式' 文件注意:Linux操作系统中正则表达式不支持:\\d,\\D,\\w,\\w,\\s,\\S,\\b,\\B;其他语法都支持-v ------&gt;忽略字段 grep you a.txt-v------&gt;获取a.txt中不包含you的所有的行 ②: 执行有打印结果的指令 | *grep 内容 * ——&gt;在指令执行结果中查找指定内容 ③: grep -r 内容 文件夹地址 ——&gt;在指定文件夹中所有的文件内容中查找指定内容 查找文件名 find ①: find 文件夹路径 -name 文件名 ——&gt;在指定文件夹下按文件名找指定文件 123456找指定文件名find dirl -name 'test1.py' #在文件夹dir1找名字是test1.py的文件find dirl -name '*.txt' #在文件夹dir1找后缀是txt的所有文件find dirl -name ' test*. txt'find dirl -name ' test*'find dirl -name '*c. txt' ②: find 文件夹路径 -size +/-文件大小 ——&gt;在指定文件夹下找文件大小满足条件的所有的文件 12345find dirl -size +4k------&gt;查找在文件夹dir1中所有大于4k的文件find dirl -size -4k------&gt;查找在文件夹dir1中所有小于4k的文件find dirl -size +5k -size -10k ------&gt;查找在文件夹dir1中所有大于5k并且小于10k的文件(文件大小如果是小数,算的时候向上取整)find dirl -size +4k -name '*.txt'------&gt;查找在文件夹dir1中所有大于4k的txt文件 查指令 which 指令名 ——&gt;精确查找当前指令对应的文件的路径whereis 指令名 ——&gt;查找和指定指令相关的所有的文件的路径man 指令名 ——&gt;获取指定指定的使用手册指令名 –help ——&gt;获取指定指令的帮助文档 14网络管理ifconfig ——&gt;查看网卡状态netstat -natp ——&gt;查看网络连接状态netstat -natp | grep 端口号 ——&gt;查看指定端口的网络连接状态 ping ip地址 ——&gt;给指定地址的服务器发送数据(主要用来检测当前网络通不通)ping -i 时间(秒) IP地址 ——&gt;每隔指定时间ping一次（时间可以是小数）ping -c 次数 IP地址 ——&gt;ping指定次数(不限制次数的时候会不断的ping) wget 地址——&gt;下载 15压缩和归档压缩可以让文件变小,一般在需要传输前都会先对文件进行压缩.注意,压缩指令只针对文件有效,并且一次只能压缩一个文件.归档可以将一个文件夹变成一个文件(tar文件) 1)归档和解归档tar -cvf 归档后文件存放的地址(归档后的文件名) 需要归档的文件 ——&gt;将文件进行归档操作(既可以对文件进行归档也可以对文件夹归档)tar -xvf 归档文件地址 ——&gt;将指定的归档文件解归档 2)压缩和解压缩gzip 文件地址 *——&gt;压缩指定文件(压缩后会生成一个gz文件,并且会删除原文件)*gzip -c 需要压缩的文件地址文件名 &gt; 压缩文件地址 ——&gt;将指定文件压缩到指定位置,并且保留原文件gzip -d 压缩文件地址 ——&gt;解压指定文件(解压完成后会删除原压缩文件)gzip -l 压缩文件地址 ——&gt;列出压缩文件中的内容 xz 文件地址 ——&gt;压缩指定文件(压缩文件后缀是xz)xz -d 压缩文件地址 ——&gt;解压指定文件 gunzip 压缩文件地址 ——&gt;解压指定文件(解压完成后会删除原压缩文件) 16包管理工具(软件安装)包管理工具: yum yum search: 搜索软件包,例如yum search nginx. yun list installed:列出已经安装的软件包,例如yum list installed I grep z1ib. yum instal1:安装软件包,例如yum insta11 nginx. yum remove:删除软件包,例如yum remove nginx. yum update:更新软件包,例如yum update可以更新所有软件包,而yum update tar只会更新tar. yum check-update:检查有哪些可以更新的软件包. yum info:显示软件包的相关信息,例如yum info nginx. 源代码构建安装软件: wget 安装包的路径 -下载安装包 gunzip/tar 压缩包 - 解压、解归档 (设置安装路径) cd 安装包目录 执行: make &amp;&amp; make install -编译安装包程序 给可执行文件添加软连接到usr/bin目录下 -添加快捷方式 1234567891011121314151617#源代码构建python3.x[root ~]# yum install gcc (安装编译环境)[root ~]# wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz (下载安装包)[root ~]# gunzip Python-3.6.5.tgz (解压)[root ~]# tar -xvf Python-3.6.5.tar (解归档)[root ~]# cd Python-3.6.5 (进入安装包)[root ~]# ./configure --prefix=/usr/local/python36 --enable-optimizations (设置安装路径)[root ~]# yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel (安装相关依赖库)[root ~]# make &amp;&amp; make install (编译执行安装文件)...[root ~]# ln -s /usr/local/python36/bin/python3.6 /usr/bin/python3 (给python指令文件创建快捷方式python3)[root ~]# python3 --versionPython 3.6.5[root ~]# python3 -m pip install -U pip (安装pip)[root ~]# ln -s /usr/local/python36/bin/pip /usr/bin/pip3 (给pip指令创建快捷方式pip3)[root ~]# pip3 --version","categories":[{"name":"Linux","slug":"Linux","permalink":"https://anjhon1994.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://anjhon1994.github.io/tags/Linux/"},{"name":"指令","slug":"指令","permalink":"https://anjhon1994.github.io/tags/%E6%8C%87%E4%BB%A4/"}]},{"title":"git常用指令","slug":"后端/git常用指令","date":"2019-12-21T16:00:00.000Z","updated":"2020-12-28T15:04:21.938Z","comments":true,"path":"2019/12/22/后端/git常用指令/","link":"","permalink":"https://anjhon1994.github.io/2019/12/22/%E5%90%8E%E7%AB%AF/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","excerpt":"git的基本常用指令集","text":"git的基本常用指令集 1.基本指令git init ——&gt;新建git仓库git add 文件/文件夹 ——&gt; 将文件添加到缓存区中git add -A ——&gt; 添加所有内容到缓存区中 git status ——&gt; 查看git状态git commit -m ‘提交信息’ ——&gt; 将缓存区中的内容全部提交到git本地仓库中git log ——&gt; 查看提交日志 git reset – hard HEAD ——&gt; 让工作目录中的内容和仓库中的内容保持一致git reset –hard HEAD^ ——&gt; 回到上一个版本git reset – hard 版本号 ——&gt; 回到指定的版本 git checkout 文件名 ——&gt; 从暂存区中恢复工作目录中的内容(让工作区中的指定文件，回到上次提交的时候的状态) git clone ——&gt; 将服务器上的项目(仓库)克隆 (使用https地址需要输入密码，使用ssh地址需要添加公钥) git remote add origin 地址 ——&gt; 关联远程仓库(只需要关联一次) git push [-u] origin master ——&gt; 提交(-u在第一次提交分支的时候才用) git push ——&gt; 将本地仓库的内容提交到远程仓库master分支上 git push origin 分支名 ——&gt; 将本地仓库的内容提交到远程仓库对应的分支上, 如果分支不存在会自动创建 git pull ——&gt; 将远程仓库中的内容更新到本地仓库和工作区中 2.分之管理创建仓库会默认给我们创建一个master分之,这个分之一般作为提交和发布分之;开发一般会自己创建一个develop分之，用来开发和测试;多人协作的时候还可能根据不同的人或者(不同的功能)创建不同的分之，用来独立开发 常见分之： master(主要是合并develop), develop(主要合并下面的其他分支), 功能/人员分之(开发) git branch [-a] ——&gt;查看分之git branch 分之名——&gt;创建分之git checkout 分支名——&gt; 切换分之git checkout -b 分之名 ——&gt;切换并创建新的分之git diff 分之1 分之2——&gt;查看两个分之之间的差异git merge 分之名——&gt;让当前分之和指定分之进行合并 注意: 切换分之、push、pull，这些操作前要保证工作区是clean怎么避免冲突： 不要发生多个分之对同一个文件在同一个版本下进行修改(和同伴确认和商量)","categories":[{"name":"Git & Shell","slug":"Git-Shell","permalink":"https://anjhon1994.github.io/categories/Git-Shell/"}],"tags":[{"name":"git","slug":"git","permalink":"https://anjhon1994.github.io/tags/git/"},{"name":"技术文档","slug":"技术文档","permalink":"https://anjhon1994.github.io/tags/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"},{"name":"指令","slug":"指令","permalink":"https://anjhon1994.github.io/tags/%E6%8C%87%E4%BB%A4/"}]},{"title":"Linux定时任务","slug":"后端/Linux定时任务","date":"2019-12-20T12:10:50.000Z","updated":"2020-01-13T02:36:42.761Z","comments":true,"path":"2019/12/20/后端/Linux定时任务/","link":"","permalink":"https://anjhon1994.github.io/2019/12/20/%E5%90%8E%E7%AB%AF/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","excerpt":"通过制定 crontab -e 编辑和开启定时任务","text":"通过制定 crontab -e 编辑和开启定时任务 1234567891011121314151617181920212223242526# 创建一个完整的定时任务，需要确定时间和任务# 1.时间 .---------------- minute (0 - 59) # 分 | .------------- hour (0 - 23) # 时 | | .---------- day of month (1 - 31) # 日 | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # 月 | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat | | | | | * * * * * user-name command to be executed * * * * * - 每分钟执行一次任务(每隔一分钟) */1 * * * * - 每分钟执行一次任务(每隔一分钟) */2 * * * * - 每2分钟执行一次任务(每隔2分钟) * */1 * * * - 每隔1小时 * * */1 * * - 每隔1天 * * * */2 * - 每隔两个月 * * * * fri - 每周五执行任务 30 * * * * - 时间点到30分的时候做 0 * * * * - 时间点到整点的时候执行任务 30 2 * * * - 时间到 02:30 的时候执行任务 0 12 28 * * - 每月28号12:00执行任务# 2.任务写Linux指令, 指令如果有结果，结果看不到","categories":[{"name":"Linux","slug":"Linux","permalink":"https://anjhon1994.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://anjhon1994.github.io/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"https://anjhon1994.github.io/tags/shell/"},{"name":"脚本","slug":"脚本","permalink":"https://anjhon1994.github.io/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"朴素贝叶斯","slug":"机器学习/朴素贝叶斯","date":"2019-08-09T16:00:00.000Z","updated":"2021-01-17T03:53:47.024Z","comments":true,"path":"2019/08/10/机器学习/朴素贝叶斯/","link":"","permalink":"https://anjhon1994.github.io/2019/08/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/","excerpt":"","text":"一: 贝叶斯定理贝叶斯定理（英语：Bayes’ theorem）是几率论中的一个定理，描述在已知一些条件下，某事件的发生几率。通常，事件A在事件B已发生的条件下发生的几率，与事件B在事件A已发生的条件下发生的几率是不一样的。然而，这两者是有确定的关系的，贝叶斯定理就是这种关系的陈述。贝叶斯公式的一个用途，即透过已知的三个几率而推出第四个几率。 贝叶斯公式:$$P(A|B) = \\frac{P(A)P(B|A)}{P(B)}$$ $P(A|B)$ 的意思是在事件$B$发生的条件下发生事件$A$的概率 接下来我们通过两个例子来更好的理解贝叶斯公式 例1:现分别有 甲,乙 两个容器，在容器 甲 里分别有 7 个红球和 3 个白球，在容器 乙 里有 1 个红球和 9 个白球，现已知从这两个容器里任意抽出了一个球，且是红球，问这个红球是来自容器 甲 的概率是多少? 方便理解: 若乙中0个红球,10个白球,则红球来自A的概率为100% 思路: 选中甲容器的概率: P(A) = 1/2 选中红球的概率: P(B) = 8/20 甲中红球的概率: P(B|A) = 7/10 选中的红球是甲中的概率: $P(A|B) = \\frac{P(A)P(B|A)}{P(B)}= \\frac{(1/2)*(7/10)}{8/20}= \\frac{7}{8}$ 例2:一座别墅在过去的 20 年里一共发生过 2 次被盗，别墅的主人有一条狗，狗平均每周晚上叫 3 次，在盗贼入侵时狗叫的概率被估计为 0.9，问题是：在狗叫的时候发生入侵的概率是多少？ 狗叫的概率: P(A) = 3/7 被盗的概率: P(B) = 2 / (20*365) 被盗时狗叫的概率: P(A|B) = 0.9 狗叫时被盗的概率: $P(B|A) = \\frac{P(B)P(A|B)}{P(A)} = \\frac{(2/(20\\times365))\\times 0.9}{3/7}$ 将贝叶斯公式 $P(A|B) = \\frac{P(A)P(B|A)}{P(B)}$ 用到我们的数据分析中则可以理解为,B是特征, A是对应的类别; 二: Sklearn中的朴素贝叶斯 当特征数量为一时, 表现出来的就是我们的贝叶斯公式; (一): 理解朴素贝叶斯屌丝逆袭实例: 大学的时候，某男生经常去007自习室上晚自习，发现他喜欢的那个女生也常去那个自习室，心中窃喜，于是每天买点好吃点在那个自习室蹲点等她来，可是人家女生不一定每天都来，眼看天气渐渐炎热，自习室又不开空调，如果那个女生没有去自习室，该男生也就不去，每次男生鼓足勇气说：“嘿，你明天还来不？”,“啊，不知道，看情况”。然后该男生每天就把她去自习室与否以及一些其他情况做一下记录，用Y表示该女生是否去自习室，即Y={去，不去}，X是跟去自习室有关联的一系列条件，比如当天上了哪门主课，蹲点统计了一段时间后，该男生打算今天不再蹲点，而是先预测一下她会不会去，现在已经知道了今天上了常微分方法这么主课，于是计算$P(Y=去|常微分方程)$与$P(Y=不去|常微分方程)$，看哪个概率大，如果$P(Y=去|常微分方程) &gt;P(Y=不去|常微分方程)$，那这个男生不管多热都屁颠屁颠去自习室了，否则不就去自习室受罪了。P(Y=去|常微分方程)的计算可以转为计算以前她去的情况下，那天主课是常微分的概率P(常微分方程|Y=去)，注意公式右边的分母对每个类别（去/不去）都是一样的，所以计算的时候忽略掉分母，这样虽然得到的概率值已经不再是0~1之间，但是通过比较大小还是能选择类别。后来他发现还有一些其他条件可以挖，比如当天星期几、当天的天气，以及上一次与她在自修室的气氛，统计了一段时间后，该男子一计算，发现不好算了，因为总结历史的公式：$$P(X=x|Y=C_k) = P(X^{(1)}=x^{(1)}, X^{(2)}=x^{(2)}, …, X^{(n)}=x^{(n)} | Y=C_k)$$这里n=4，x(1)表示主课，x(2)表示天气，x(3)表示星期几，x(4)表示气氛，Y仍然是{去，不去}，现在主课有8门，天气有晴、雨、阴三种、气氛有A+,A,B+,B，C五种，那么总共需要估计的参数有8×3×7×5×2=1680个，每天只能收集到一条数据，那么等凑齐1680条数据，大学都毕业了，男生大呼不妙 当特征数量为多个时, 多个条件之间互相影响, 增加了数据复杂度, 最终决定对应的类别; 于是做了一个独立性假设，假设这些影响她去自习室的原因是独立互不相关的:$$\\begin{aligned}P(X=x|Y=C_k) &amp;= P(X^{(1)}=x^{(1)}, X^{(2)}=x^{(2)}, …, X^{(n)}=x^{(n)} | Y=C_k)\\\\&amp; = P(X^{(1)}=x^{(1)} | Y=C_k) \\times P(X^{(2)}=x^{(2)} | Y=C_k) \\times …\\times P(X^{(n)}=x^{(n)} | Y=C_k)\\\\&amp;=\\prod_{i=1}^n P(X^{(i)}=x^{(i)} | Y=C_k)\\\\\\end{aligned}$$有了这个独立假设后，需要估计的参数就变为，(8+3+7+5)×2 = 46个了，而且每天收集的一条数据，可以提供4个参数，这样该男生就预测越来越准了 通过上面这个屌丝逆袭的例子我们可以简单的总结一下: sklearn中的朴素贝叶斯其实就是将贝叶斯中的各属性看成是独立的,不相互影响的 那么朴素贝叶斯又是怎么判断类别的呢? 别急, 继续往下看. (二): 朴素贝叶斯的工作原理又是一个例子: 如果一对男女朋友，男生向女生求婚，男生的四个特点分别是不帅，性格不好，身高矮，不上进，请你判断一下女生是嫁还是不嫁？ 首先,我们用贝叶斯公式将这个时间的概率表示出来:$$P(嫁 | 不帅、性格不好、身高矮、不上进)=\\frac{P(不帅、性格不好、身高矮、不上进|嫁) \\times P(嫁)}{P(不帅、性格不好、身高矮、不上进)}$$将贝叶斯转换成朴素贝叶斯$$\\begin{aligned}P(嫁 | 不帅、性格不好、身高矮、不上进)&amp;=\\frac{P(不帅、性格不好、身高矮、不上进|嫁) \\times P(嫁)}{P(不帅、性格不好、身高矮、不上进)}\\\\&amp; \\\\&amp;= \\frac{P(不帅|嫁) \\times P(性格不好|嫁) \\times P(身高矮|嫁) \\times P(不上进|嫁) \\times P(嫁)}{P(不帅) \\times P(性格不好) \\times P(身高矮) \\times P(不上进)}\\\\\\end{aligned}$$ 此时,我们就可以轻易的看出: $P(不帅|嫁)$ 的概率为: 1/2 $P(嫁)$ 的概率为: 1/2 依次类推, 可以计算出其他的独立事件的概率, 即可算出嫁或则不嫁的概率分别时多少, 然后比较相同条件下嫁和不嫁的概率的大小来决定是否出嫁 注意: 朴素贝叶斯的结果可能会大于一, 至于嫁与不嫁只需要比较计算出来的结果即可,结果之和不等于1 (三): 朴素贝叶斯的算法模型这里主要介绍三种, 分别是: 高斯分布, 伯努利分布, 多项式分布 高斯分布又称正态分布: 曲线高峰位于正中央，即均数所在的位置; 曲线由均数所在处开始，分别向左右两侧逐渐均匀下降 正态曲线呈钟型，两头低，中间高，左右对称因其曲线呈钟形，因此人们又经常称之为钟形曲线。 伯努利分布 在概率论和统计学中，二项分布（英语：Binomial distribution）是n个独立的是/非试验中成功的次数的离散概率分布，其中每次试验的成功概率为p。这样的单次成功/失败试验又称为伯努利试验。实际上，当n = 1时，二项分布就是伯努利分布。二项分布是显著性差异的二项试验的基础。 多项式分布 在概率论中，多项式分布是二项式分布的推广。例如，它模拟了n次轧制的k面模具每侧计数的概率。对于n个独立试验，每个试验都能准确地为k个类别中的一个成功，并且每个类别具有给定的固定成功概率，多项式分布给出了各个类别成功次数的任何特定组合的概率。 当k为2且n为1时，多项式分布为伯努利分布。当k为2且n大于1时，它是二项分布。当k大于2且n为1时，它是分类分布。 三: 朴素贝叶斯对垃圾邮件进行分类 导包获取数据 12345678910111213import warningswarnings.filterwarnings('ignore')import numpy as npimport pandas as pdfrom sklearn.naive_bayes import GaussianNB,BernoulliNB,BaseDiscreteNB,MultinomialNBfrom sklearn.model_selection import train_test_splitsms = pd.read_csv('./SMSSpamCollection.csv', sep='\\t', header=None)sms.rename(&#123;0:'label', 1:'message'&#125;, axis = 1, inplace=True) # 该表头display(sms.shape, sms.head())X = sms[['message']] # 机器学习要求数据是二维的,若只有一个中括号则数据类型的Seriosy = sms[['label']] 对邮件文本内容(字符串)进行量化 12345678910111213141516171819202122# feature_extraction特征提取# CountVectorizer统计词频# 中文词频统计包: 结巴分词(pip install jieba)from sklearn.feature_extraction.text import CountVectorizercv = CountVectorizer()X_ = cv.fit_transform(sms['message']) # 稀松矩阵# 返回sparse matrix稀松矩阵,节省内存# 5572x8713表示5572条短信中提取到8713个词# cv.vocabulary_ 查看单词在稀松矩阵中的例数# (0, 3571) 1 表示第一行(第一封邮件)第3571列代表的词有一个# (0, 8084) 1 表示第一行(第一封邮件)第8084列代表的词有一个# 以此类推 sparse.save_npz('./sms.npz', X_) # 稀松矩阵只有100KB大小X = X_.toarray() # 常规矩阵np.savez('./sms2.npz', X) # 常规矩阵有388MB大小# sparse.csc_matrix() 方法可以将常规矩阵转换成稀松矩阵# toarray() 方法可以将稀松矩阵转回正常矩阵 分数据 12345# 常规数据X_train,X_test, y_train,y_test = train_test_split(X,y,test_size=0.2,random_state=1187)# 稀松矩阵的数据X_train_,X_test_, y_train,y_test = train_test_split(X_,y,test_size=0.2,random_state=1187) 用不同的模型进行分类 123456789%%time# 高斯分布gNB = GaussianNB() # 数据必须是正常矩阵gNB.fit(X_train, y_train)gNB.score(X_test, y_test)'''Wall time: 1.51 s0.8914798206278027''' 123456789%%time# 伯努利分布bNB = BernoulliNB() # 数据支持稀松举证(提高运行效率)bNB.fit(X_train_, y_train)bNB.score(X_test_, y_test)'''Wall time: 20 ms0.9730941704035875''' 123456789%%time# 多项式分布mNB = MultinomialNB() # 数据支持稀松举证(提高运行效率)mNB.fit(X_train_, y_train)mNB.score(X_test_, y_test)'''Wall time: 20.9 ms0.979372197309417''' 四: 应用朴素贝叶斯在文本分类和情感分析中应用最为广泛 文本分类（Text Categorization）是指计算机将一片文档归于预先给定的某一类或几类的过程。文本分类的特征提取过程是分词。目前比较好的中文分词器有中科院的ictclas，庖丁，IK等等。经过分词后，每个词就是一个特征。分词中可以自己配置停用词库，扩展词库等。特征选择有诸如TF-IDF，CHI等特征选择算法，就不在此赘述。 朴素贝叶斯计算先验概率P（C）和条件概率P（X|C）的方法有两种：多项式模型和伯努利模型。两者在计算的时候有两点差别：多项式会统计词频，而伯努利认为单词出现就记为1，没出现记为0，可以看到一个是基于词频，一个是基于文档频率；伯努利在分类时，将词库中的没有出现在待分类文本的词作为反方考虑。/","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"https://anjhon1994.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"朴素贝叶斯","slug":"朴素贝叶斯","permalink":"https://anjhon1994.github.io/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"}]},{"title":"逻辑斯蒂回归(Logistic)","slug":"机器学习/逻辑斯蒂回归","date":"2019-03-14T16:00:00.000Z","updated":"2021-01-17T03:56:43.336Z","comments":true,"path":"2019/03/15/机器学习/逻辑斯蒂回归/","link":"","permalink":"https://anjhon1994.github.io/2019/03/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%E5%9B%9E%E5%BD%92/","excerpt":"","text":"一: 逻辑斯蒂回归原理(一): 似然函数每个样本的概率:$$P(y|x;\\theta)=(h_{\\theta}(x))^y(1-h_\\theta (x))^{1-y}$$事件的概率(所有样本属于真实标记的概率)$$L(\\theta)= \\prod_{i=1}^nP(y_i|x_i;\\theta)$$ $$L(\\theta)= \\prod_{i=1}^n(h_{\\theta}(x_i))^{y_i}(1-h_\\theta (x_i))^{1-{y_i}}$$ 似然函数解决二分类问题: 当y=1时:$$P(1|x_i;\\theta)=(h_{\\theta}(x_i))^1(1-h_\\theta (x_i))^{1-1}$$ $$P(1|x_i;\\theta)=h_{\\theta}(x_i)$$ 当y=0时:$$P(0|x_i;\\theta)=(h_{\\theta}(x_i))^0(1-h_\\theta (x_i))^{1-0}$$ $$P(0|x_i;\\theta)=1-h_\\theta (x_i)$$ 举个栗子: 假如有一个罐子，里面有黑白两种颜色的球，数目多少不知，两种颜色的比例也不知。我们想知道罐中白球和黑球的比例，但我们不能把罐中的球全部拿出来数。现在我们可以每次任意从已经摇匀的罐中拿一个球出来，记录球的颜色，然后把拿出来的球再放回罐中。这个过程可以重复，我们可以用记录的球的颜色来估计罐中黑白球的比例。假如在前面的一百次重复记录中，有七十次是白球，请问罐中白球所占的比例最有可能是多少？ 解: 设每次取到白球的概率为p, 则取到黑球的概率为(1-p), 则100次中70次取到白球的概率为:$$P=C_{100}^{70}p^{70}(1-p)^{30}$$ $$P’=(p^{70})’(1-p)^{30}+p^{70}((1-p)^{30})’\\times(1-p)’$$ $$P’=70p^{69}(1-p)^{30}-p^{70}30(1-p)^{29}$$ 此时令导数为零求最大值:$$0=70p^{69}(1-p)^{30}-p^{70}30(1-p)^{29}$$化简:$$0=70(1-p)-30p$$ $$100p=70$$ 所以:$$p=70\\div100$$ (二): 逻辑斯蒂回归原理和损失函数分类问题其实都是概率问题, 逻辑斯蒂函数就是概率函数,无论给的值多大多小都会转变到0-1之间进行比较,并得出概率进行分类 sigmoid函数:$$S(t) = \\frac{1}{1+e^{-t}}$$线性回归方程:$$一般模式: f(x) = {\\theta}x+b$$ $$矩阵模式: f(X) = \\sum\\limits _{i=1}^nx_i{\\theta}_i+b$$ 1: 逻辑斯蒂回归原理逻辑斯蒂回归 = 线性回归 + sigmoid 方程结合 - 预测函数:$$一般形式: h_{\\theta}(x)=\\frac{1}{1+e^{-x\\theta}}$$ $$矩阵模式: h_{\\theta}(X)=\\frac{1}{1+e^{-X\\theta}}$$ 2: 最大似然估计法求损失函数最大似然估计公式求对数:$$l(\\theta) = ln(L(\\theta)) =ln[ \\prod_{i=1}^n(h_{\\theta}(x_i))^{y_i}(1-h_\\theta (x_i))^{1-{y_i}}]$$乘积的对数可以转换成加法:$$l(\\theta)= \\sum_{i=1}^n[y_iln(h_{\\theta}(x_i))+(1-{y_i})ln(1-h_\\theta (x_i))]$$最大似然估计就是要求得使 $l(\\theta)$ 取最大值时的 $\\theta$ ，其实这里可以使用梯度上升法求解，求得的 $\\theta$ 就是要求的最佳参数 对似然函数对数化取反的表达式，即损失函数表达式$$J(\\theta) = -l(\\theta) = -\\sum_{i=1}^n[y_iln(h_{\\theta}(x_i))+(1-{y_i})ln(1-h_\\theta (x_i))]$$ 损失函数 $J(\\theta)$ 对 $ \\theta$ 求导: $$J’(\\theta) = \\frac{\\partial J(\\theta)}{\\partial\\theta}$$ $$\\begin{aligned}\\frac{\\partial J(\\theta)}{\\partial\\theta} &amp; = -\\sum_{i=1}^n[y_i\\frac{1}{h_{\\theta}(x_i)}\\frac{\\partial h_\\theta(x_i)}{\\partial\\theta}+(1-{y_i})\\frac{1}{1-h_\\theta (x_i)}\\frac{\\partial (1-h_\\theta(x_i))}{\\partial\\theta}]\\\\&amp; \\\\&amp; 注释: ln(x)’=\\frac{1}{x}\\\\&amp; \\\\&amp; = -\\sum_{i=1}^n[y_i\\frac{1}{h_{\\theta}(x_i)}\\frac{\\partial h_\\theta(x_i)}{\\partial\\theta}-(1-{y_i})\\frac{1}{1-h_\\theta (x_i)}\\frac{\\partial h_\\theta(x_i)}{\\partial\\theta}]\\\\&amp; = -\\sum_{i=1}^n[y_i\\frac{1}{h_{\\theta}(x_i)}-(1-{y_i})\\frac{1}{1-h_\\theta (x_i)}]\\frac{\\partial h_\\theta(x_i)}{\\partial\\theta}\\\\&amp;\\\\&amp; 注释: \\frac{\\partial h_\\theta(x_i)}{\\partial\\theta}的推导过程详见下文\\\\&amp;\\\\&amp; = -\\sum_{i=1}^n[y_i\\frac{1}{h_{\\theta}(x_i)}-(1-{y_i})\\frac{1}{1-h_\\theta (x_i)}]x_ih_\\theta(x_i)(1-h_\\theta(x_i))\\\\&amp; = -\\sum_{i=1}^n[y_i(1-h_\\theta (x_i))-(1-{y_i})h_\\theta (x_i)]x_i\\\\&amp; = -\\sum_{i=1}^n[y_i-h_\\theta (x_i)]x_i\\\\&amp; = \\sum_{i=1}^n[h_\\theta (x_i)-y_i]x_i\\\\\\end{aligned}$$ 推导 $\\frac{\\partial h_\\theta(x_i)}{\\partial\\theta}$ 的过程:$$\\begin{aligned}\\frac{\\partial h_\\theta(x_i)}{\\partial\\theta}&amp; = h’_\\theta(x_i)\\\\&amp; = (\\frac{1}{1+e^{-x_i\\theta}})’\\\\&amp; = (\\frac{1}{1+e^{-\\theta^Tx_i}})’\\\\&amp; = [(1+e^{-\\theta^Tx_i})^{-1}]’\\\\&amp; 注释: (e^x)’ = e^x \\\\&amp; = -(1+e^{-\\theta^Tx_i})^{-2}e^{-\\theta^Tx_i}(-x_i)\\\\&amp; = (1+e^{-\\theta^Tx_i})^{-2}e^{-\\theta^Tx_i}x_i\\\\&amp; = x_i\\frac{e^{-\\theta^Tx_i}}{(1+e^{-\\theta^Tx_i})^2}\\\\&amp; = x_i\\frac{1}{(1+e^{-\\theta^Tx_i})}\\frac{e^{-\\theta^Tx_i}}{(1+e^{-\\theta^Tx_i})}\\\\&amp; = x_ih_\\theta(x_i)\\frac{e^{-\\theta^Tx_i}}{(1+e^{-\\theta^Tx_i})}\\\\&amp; = x_ih_\\theta(x_i)\\frac{1+e^{-\\theta^Tx_i}-1}{(1+e^{-\\theta^Tx_i})}\\\\&amp; = x_ih_\\theta(x_i)[\\frac{1+e^{-\\theta^Tx_i}}{(1+e^{-\\theta^Tx_i})}-\\frac{1}{(1+e^{-\\theta^Tx_i})}]\\\\&amp; = x_ih_\\theta(x_i)[1-\\frac{1}{(1+e^{-\\theta^Tx_i})}]\\\\&amp; = x_ih_\\theta(x_i)(1-h_\\theta(x_i))\\\\\\end{aligned}$$ 此时使用梯度下降优化算法, 其系数的更新规则为:$$\\theta = \\theta - \\epsilon\\frac{\\partial J(\\theta)}{\\partial\\theta}$$ 二: 逻辑斯蒂回归的应用(一): 简单应用 - 鸢尾花分类1234567891011121314151617181920212223242526272829import numpy as npfrom sklearn.linear_model import LogisticRegressionfrom sklearn import datasets, metricsfrom sklearn.model_selection import train_test_split# 鸢尾花数据iris = datasets.load_iris()# 花萼长度, 花萼宽度, 花瓣长度, 花瓣宽度X = iris['data']y = iris['target']# train_test_split随机打乱数据顺序, random_state使得每次随机的数值是一样的X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=512)lr = LogisticRegression(max_iter=1000) # max_iter=1000, 学习次数lr.fit(X_train, y_train)y_ = lr.predict(X_test)print('实际数据:y_test:\\n', y_test)print('预测数据:y_:\\n', y_)'''实际数据:y_test: [0 1 1 1 2 0 0 2 0 2 1 1 1 0 2 0 2 0 1 1 0 1 0 1 0 2 1 1 1 2]预测数据:y_: [0 1 1 2 2 0 0 2 0 2 1 1 1 0 2 0 2 0 1 1 0 1 0 2 0 2 1 1 1 2]''' (二): 二分类问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import numpy as npfrom sklearn.linear_model import LogisticRegressionfrom sklearn import datasetsX,y = datasets.load_iris(True) # True代表只获取数据和目标值cond = y!=0 # 只留下两个类别,将类别0 删除X = X[cond]y = y[cond]lr = LogisticRegression()lr.fit(X,y) # 算法，训练数据，找X和y之间的规律，方程y_ = lr.predict(X) # 规律找到之后，使用规律，进行计算# 将类别减少之后, 分类后的结果和真实值相差很小,说明类别越少,分类的准确度越高(y_ == y).mean() # 计算准确率print(y_)'''array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])'''proba_ = lr.predict_proba(X) # 计算的概率proba_[:10] # 将概率转化成类别'''array([[0.99153216, 0.00846784], [0.9908928 , 0.0091072 ], [0.99355185, 0.00644815], [0.99086387, 0.00913613], [0.99219814, 0.00780186], [0.98268555, 0.01731445], [0.99252002, 0.00747998], [0.9899949 , 0.0100051 ], [0.99259338, 0.00740662], [0.99028393, 0.00971607]])每组数据有两种分类的可能性, 每种可能性对应的概率不同,系统在判别的时候会选择概率较大的那个类别'''proba_.argmax(axis=1)+1 # 将概率转换为类别; .argmax(axis=1)获取同一行中较大的值(概率)的下标;加1是因为之前的类别0已经被删除了,而这里的下标还有可能是0'''array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], dtype=int64)'''# 以上是用算法模型得出的分类结果(y_)和概率手动计算概率(proba_)，现在我们用代码实现以上效果:w_ = lr.coef_b_ = lr.intercept_print('方程系数',lr.coef_)print('方程截距',lr.intercept_)'''方程系数 [[ 0.48498493 -0.34086327 1.8278232 0.83365156]]方程截距 [-8.76905997]'''def fun(X):#线性方程，矩阵，批量计算 return X.dot(w_[0]) + b_[0]def sigmoid(x):#fun就是线性方程的返回值 return 1/(1+np.e**-x)f = fun(X)p_1 = sigmoid(f) # 求出二分类中一类的概率p_0 = 1 - p_1 # 求出二分类中另外一类的概率(二分类中凌总可能性的和为1)p_ = np.c_[p_0,p_1] # 将两个概率连接起来# np.r_：是按列连接两个矩阵，就是把两矩阵上下相加，要求列数相等，类似于pandas中的concat()。# np.c_：是按行连接两个矩阵，就是把两矩阵左右相加，要求行数相等，类似于pandas中的merge()。p_[:10]'''array([[0.99153216, 0.00846784], [0.9908928 , 0.0091072 ], [0.99355185, 0.00644815], [0.99086387, 0.00913613], [0.99219814, 0.00780186], [0.98268555, 0.01731445], [0.99252002, 0.00747998], [0.9899949 , 0.0100051 ], [0.99259338, 0.00740662], [0.99028393, 0.00971607]])'''# 对比发现p_和proba_所得到的结果是一致的; (三): 多分类问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import numpy as npfrom sklearn.linear_model import LogisticRegressionfrom sklearn import datasets, metricsX,y = datasets.load_iris(True)# 打乱顺序index = np.arange(150)np.random.shuffle(index)X = X[index]y = y[index]lr = LogisticRegression(max_iter=200) # 定义模型lr.fit(X,y) # 训练模型# 是3分类问题, 三个方程(每一类对应一个方程),三组斜率,每组斜率有4个属性; 三个截距, w_ = lr.coef_b_ = lr.intercept_print('斜率:\\n',w_)print('截距:\\n',b_)'''斜率: [[-0.42294389 0.9669724 -2.51691851 -1.08061335] [ 0.53406236 -0.32159608 -0.20649198 -0.94361292] [-0.11111847 -0.64537632 2.72341049 2.02422627]]截距: [ 9.84788649 2.2391674 -12.08705389]'''y_ = lr.predict(X)proba_ = lr.predict_proba(X) # 概率print('y_:\\n', y_)print('proba_:\\n', proba_)print(proba_.argmax(axis = 1)) # argmax获取最大值的下标(类别)'''y_: [2 0 1 2 1 1 0 0 2 1 2 2 1 1 1 0 0 0 0 1 2 1 2 2 2 2 2 0 1 0 2 1 1 1 2 0 0 2 0 1 2 1 2 0 1 2 2 0 1 0 0 2 0 2 0 1 1 1 0 0 0 2 1 1 1 0 0 2 0 2 2 2 2 1 0 1 0 1 2 1 0 2 1 1 2 0 2 1 0 2 1 2 0 1 0 0 2 1 2 1 0 1 0 0 0 1 1 2 1 2 1 1 1 2 0 2 0 2 1 0 0 2 0 0 2 1 0 0 2 1 1 2 0 2 2 2 0 1 2 2 0 0 0 2 2 0 1 2 1 2]proba_: [[2.42893049e-04 1.62572543e-01 8.37184564e-01] [9.76236359e-01 2.37636218e-02 1.93734447e-08] [1.02308731e-02 7.50874989e-01 2.38894138e-01] [6.22245105e-07 2.13422648e-02 9.78657113e-01] ...... [9.08742683e-03 9.76589206e-01 1.43233676e-02] [1.06469379e-06 2.91941988e-02 9.70804737e-01] [2.43372229e-01 7.55336793e-01 1.29097800e-03] [2.27109807e-04 2.51919829e-01 7.47853061e-01]] proba_.argmax(axis = 1): array([2, 0, 1, 2, 1, 1, 0, 0, 2, 1, 2, 2, 1, 1, 1, 0, 0, 0, 0, 1, 2, 1, 2, 2, 2, 2, 2, 0, 1, 0, 2, 1, 1, 1, 2, 0, 0, 2, 0, 1, 2, 1, 2, 0, 1, 2, 2, 0, 1, 0, 0, 2, 0, 2, 0, 1, 1, 1, 0, 0, 0, 2, 1, 1, 1, 0, 0, 2, 0, 2, 2, 2, 2, 1, 0, 1, 0, 1, 2, 1, 0, 2, 1, 1, 2, 0, 2, 1, 0, 2, 1, 2, 0, 1, 0, 0, 2, 1, 2, 1, 0, 1, 0, 0, 0, 1, 1, 2, 1, 2, 1, 1, 1, 2, 0, 2, 0, 2, 1, 0, 0, 2, 0, 0, 2, 1, 0, 0, 2, 1, 1, 2, 0, 2, 2, 2, 0, 1, 2, 2, 0, 0, 0, 2, 2, 0, 1, 2, 1, 2], dtype=int64) 以上proba_.argmax(axis = 1)的分类结果和模型预测的结果一致;'''# 手动计算# 定义线性函数def linear(x): y = x.dot(w_.T)+b_ return y# 将的到的目标值转换成概率(同一组目标值内的概率和为1)def softmax(x): # 详细公式见下文 return np.e**x/((np.e**x).sum(axis=1).reshape(-1,1)) # reshape之后分母的形状由单独的一行,变成一列;变成一列之后回根据分子的形状由第一列进行广播(广播出来的列和原来的一列相同,只是为了对应分支的数据形状,方便进行运算) # 如果我只需要特定的行数，列数我无所谓多少，我只需要指定行数，列数用-1代替就行了，计算机帮我算应该有多少列，反之亦然。所以-1在这里应该可以理解为一个正整数通配符，它代替任何正整数。 y_pred = linear(X)y_pred = softmax(y_pred)y_pred[:10]'''array([[2.42893049e-04, 1.62572543e-01, 8.37184564e-01], [9.76236359e-01, 2.37636218e-02, 1.93734447e-08], [1.02308731e-02, 7.50874989e-01, 2.38894138e-01], [6.22245105e-07, 2.13422648e-02, 9.78657113e-01], [8.71627591e-03, 7.74658724e-01, 2.16625000e-01], [5.07829679e-03, 9.20088614e-01, 7.48330891e-02], [9.84437320e-01, 1.55626715e-02, 8.01740090e-09], [9.85693639e-01, 1.43063452e-02, 1.55226004e-08], [9.96558465e-05, 1.20579040e-01, 8.79321304e-01], [2.39486316e-02, 9.59459247e-01, 1.65921216e-02]])'''# 得到的概率和模型计算的概率相同 以上代码段中softmax(x)用到的公式: softmax函数的计算原理 :$$e^{x_i}\\div\\sum_{i=1}^n e^{x_i}$$","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"sklearn","slug":"sklearn","permalink":"https://anjhon1994.github.io/tags/sklearn/"},{"name":"Logistic回归","slug":"Logistic回归","permalink":"https://anjhon1994.github.io/tags/Logistic%E5%9B%9E%E5%BD%92/"}]},{"title":"KNN近邻算法","slug":"机器学习/KNN算法","date":"2019-02-19T16:00:00.000Z","updated":"2021-01-08T14:17:10.865Z","comments":true,"path":"2019/02/20/机器学习/KNN算法/","link":"","permalink":"https://anjhon1994.github.io/2019/02/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/KNN%E7%AE%97%E6%B3%95/","excerpt":"","text":"一: KNN算法概述K nearest neighbors (k邻近算法) KNN是通过测量不同特征值之间的距离进行分类。 KNN做分类预测时，一般是选择多数表决法，即训练集里和预测的样本特征最近的K个样本，预测为里面有最多类别数的类别。而KNN做回归时，一般是选择平均法，即最近的K个样本的样本输出的平均值作为回归预测值。 它的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别; 其中K通常是不大于20的整数。KNN算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。 KNN方法既可以做分类，也可以做回归 举例说明 例- 1 : 图片中分三类$$w_1 红色圆圈，w_2 蓝色三角，w_3 绿色的方块$$，请问数据$$X_u$$属于哪个类别 设置k=5, 4个邻居是红色，1个邻居是绿色的; 所以是红色的概率为80%, 是绿色的概率是20% 例 - 2: 如下图，绿色圆要被决定赋予哪个类，是红色三角形还是蓝色四方形？ 如果K=3，由于红色三角形所占比例为2/3，绿色圆将被赋予红色三角形那个类，如果K=5，由于蓝色四方形比例为3/5，因此绿色圆被赋予蓝色四方形类。 由此也说明了KNN算法的结果很大程度取决于K的选择。 二: KNN算法三要素KNN算法三要素: k值的选取，距离度量的方式和分类决策规则 (一): K值得选取对于k值的选择，没有一个固定的经验，一般根据样本的分布，选择一个较小的值，可以通过交叉验证选择一个合适的k值。 选择较小的k值，就相当于用较小的领域中的训练实例进行预测，训练误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是泛化误差会增大，换句话说，K值的减小就意味着整体模型变得复杂，容易发生过拟合； 选择较大的k值，就相当于用较大领域中的训练实例进行预测，其优点是可以减少泛化误差，但缺点是训练误差会增大。这时候，与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。 一个极端是k等于样本数m，则完全没有分类，此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的类，模型过于简单。 (二): 距离的度量方式(常用欧式距离)欧式距离:$$d(x, y) =\\sqrt{(x_1−y_1)^2+(x_2−y_2)^2+…+(x_n−y_n)^2}=\\sqrt{\\sum\\limits_{i=1}^n(x_i - y_i)^2}$$ 曼哈顿距离:$$d(x, y) = |x_1−y_1|+|x_2−y_2|+…+|x_n−y_n|=\\sum\\limits_{i=1}^n\\vert x_i - y_i\\vert$$ 闵可夫斯基距离:$$d(x,y)= \\sqrt[p]{(|x_1−y_1|)^p+(|x_2−y_2|)^p+…+(|x_n−y_n|)^p}=\\sqrt[p]{\\sum_{i=1}^n(|x_i−y_i|)^p}$$可以看出，欧式距离是闵可夫斯基距离距离在p=2时的特例，而曼哈顿距离是p=1时的特例。 方差和标准差: (三): 分类决策规则一般都是使用前面提到的多数表决法。 三: KNN算法的实现方式(一): 蛮力实现既然我们要找到k个最近的邻居来做预测，那么我们只需要计算预测样本和所有训练集中的样本的距离，然后计算出最小的k个距离即可，接着多数表决，很容易做出预测。这个方法的确简单直接，在样本量少，样本特征少的时候有效。但是在实际运用中很多时候用不上，为什么呢？因为我们经常碰到样本的特征数有上千以上，样本量有几十万以上，如果我们这要去预测少量的测试集样本，算法的时间效率很成问题。因此，这个方法我们一般称之为蛮力实现。比较适合于少量样本的简单模型的时候用。 (二): KD树实现原理KD树算法没有一开始就尝试对测试样本分类，而是先对训练集建模，建立的模型就是KD树，建好了模型再对测试集做预测。所谓的KD树就是K个特征维度的树，注意这里的K和KNN中的K的意思不同。KNN中的K代表最近的K个样本，KD树中的K代表样本特征的维数。为了防止混淆，后面我们称特征维数为n。 KD树算法包括三步，第一步是建树，第二部是搜索最近邻，最后一步是预测。 1: KD树建立我们首先来看建树的方法。KD树建树采用的是从m个样本的n维特征中，分别计算n个特征的取值的方差，用方差最大的第k维特征$n_k$来作为根节点。对于这个特征，我们选择特征$n_k$的取值的中位数$n_{kv}$对应的样本作为划分点，对于所有第k维特征的取值小于$n_{kv}$的样本，我们划入左子树，对于第k维特征的取值大于等于$n_{kv}$的样本，我们划入右子树，对于左子树和右子树，我们采用和刚才同样的办法来找方差最大的特征来做更节点，递归的生成KD树。 比如我们有二维样本6个，{(2,3)，(5,4)，(9,6)，(4,7)，(8,1)，(7,2)}，构建kd树的具体步骤为： 1）找到划分的特征。6个数据点在x，y维度上的数据方差分别为6.97，5.37，所以在x轴上方差更大，用第1维特征建树。 2）确定划分点（7,2）。根据x维上的值将数据排序，6个数据的中值(所谓中值，即中间大小的值)为7，所以划分点的数据是（7,2）。这样，该节点的分割超平面就是通过（7,2）并垂直于：划分点维度的直线x=7； 3）确定左子空间和右子空间。 分割超平面x=7将整个空间分为两部分：x&lt;=7的部分为左子空间，包含3个节点={(2,3),(5,4),(4,7)}；另一部分为右子空间，包含2个节点={(9,6)，(8,1)}。 4）用同样的办法划分左子树的节点{(2,3),(5,4),(4,7)}和右子树的节点{(9,6)，(8,1)}。最终得到KD树。 2: KD树搜索最近邻当我们生成KD树以后，就可以去预测测试集里面的样本目标点了。对于一个目标点，我们首先在KD树里面找到包含目标点的叶子节点。以目标点为圆心，以目标点到叶子节点样本实例的距离为半径，得到一个超球体，最近邻的点一定在这个超球体内部。然后返回叶子节点的父节点，检查另一个子节点包含的超矩形体是否和超球体相交，如果相交就到这个子节点寻找是否有更加近的近邻,有的话就更新最近邻。如果不相交那就简单了，我们直接返回父节点的父节点，在另一个子树继续搜索最近邻。当回溯到根节点时，算法结束，此时保存的最近邻节点就是最终的最近邻。 从上面的描述可以看出，KD树划分后可以大大减少无效的最近邻搜索，很多样本点由于所在的超矩形体和超球体不相交，根本不需要计算距离。大大节省了计算时间。 先进行二叉查找，先从（7,2）查找到（5,4）节点，在进行查找时是由y = 4为分割超平面的，由于查找点为y值为4.5，因此进入右子空间查找到（4,7），形成搜索路径&lt;(7,2)，(5,4)，(4,7)&gt;，但 （4,7）与目标查找点的距离为3.202，而（5,4）与查找点之间的距离为3.041，所以（5,4）为查询点的最近点； 以（2，4.5）为圆心，以3.041为半径作圆，如下图所示。可见该圆和y = 4超平面交割，所以需要进入（5,4）左子空间进行查找，也就是将（2,3）节点加入搜索路径中得&lt;(7,2)，(2,3)&gt;；于是接着搜索至（2,3）叶子节点，（2,3）距离（2,4.5）比（5,4）要近，所以最近邻点更新为（2，3），最近距离更新为1.5；回溯查找至（5,4），直到最后回溯到根结点（7,2）的时候，以（2,4.5）为圆心1.5为半径作圆，并不和x = 7分割超平面交割，如下图所示。至此，搜索路径回溯完，返回最近邻点（2,3），最近距离1.5。 3: KD树预测有了KD树搜索最近邻的办法，KD树的预测就很简单了，在KD树搜索最近邻的基础上，我们选择到了第一个最近邻样本，就把它置为已选。在第二轮中，我们忽略置为已选的样本，重新选择最近邻，这样跑k次，就得到了目标的K个最近邻，然后根据多数表决法，如果是KNN分类，预测为K个最近邻里面有最多类别数的类别。如果是KNN回归，用K个最近邻样本输出的平均值作为回归预测值。 (三): 球树实现原理KD树和球树类似，主要区别在于球树得到的是节点样本组成的最小超球体，而KD得到的是节点样本组成的超矩形体，这个超球体要与对应的KD树的超矩形体小，这样在做最近邻搜索的时候，可以避免一些无谓的搜索。 1: 球树建立1) 先构建一个超球体，这个超球体是可以包含所有样本的最小球体。 2) 从球中选择一个离球的中心最远的点，然后选择第二个点离第一个点最远，将球中所有的点分配到离这两个聚类中心最近的一个上，然后计算每个聚类的中心，以及聚类能够包含它所有数据点所需的最小半径。这样我们得到了两个子超球体，和KD树里面的左右子树对应。 3) 对于这两个子超球体，递归执行步骤2). 最终得到了一个球树。 2: 球树搜索最近邻使用球树找出给定目标点的最近邻方法是首先自上而下贯穿整棵树找出包含目标点所在的叶子，并在这个球里找出与目标点最邻近的点，这将确定出目标点距离它的最近邻点的一个上限值，然后跟KD树查找一样，检查兄弟结点，如果目标点到兄弟结点中心的距离超过兄弟结点的半径与当前的上限值之和，那么兄弟结点里不可能存在一个更近的点；如果上诉描述相反,说明有可能存在,也有可能不存在，必须进一步检查位于兄弟结点以下的子树。 检查完兄弟节点后，我们向父节点回溯，继续搜索最小邻近值。当回溯到根节点时，此时的最小邻近值就是最终的搜索结果。 从上面的描述可以看出，KD树在搜索路径优化时使用的是两点之间的距离来判断，而球树使用的是两边之和大于第三边来判断，相对来说球树的判断更加复杂，但是却避免了更多的搜索，这是一个权衡。 四: KNN算法的思想总结就是在训练集中数据和标签已知的情况下，输入测试数据，将测试数据的特征与训练集中对应的特征进行相互比较，找到训练集中与之最为相似的前K个数据，则该测试数据对应的类别就是K个数据中出现次数最多的那个分类，其算法的描述为： 计算测试数据与各个训练数据之间的距离； 按照距离的递增关系进行排序； 选取距离最小的K个点； 确定前K个点所在类别的出现频率； 返回前K个点中出现频率最高的类别作为测试数据的预测分类。 五: KNN算法应用(一): 分类应用1: KNN算法实现鸢尾花分类123456789101112131415161718192021222324252627282930313233343536import numpy as npfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn import datasetsfrom sklearn.model_selection import train_test_splitfrom sklearn.metrics import accuracy_score # 准确率计算X, y = datasets.load_iris(True) # True表示只获取数据和目标值# 默认划分比例是 4:1X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=1024) # random_state=1024设置固定的随机knn = KNeighborsClassifier(n_neighbors=5) # n_neighbors=5设置k值knn.fit(X_train, y_train)y_ = knn.predict(X_test)print('预测值:\\n', y_)print('实际值:\\n', y_test)print('准确率1:\\n', accuracy_score(y_test, y_))print('准确率2:\\n', knn.score(X_test, y_test))print('人工准确率:\\n', (y_ == y_test).mean())'''预测值: [1 0 2 2 0 0 1 2 1 0 0 0 1 2 2 0 1 0 2 0 2 0 1 0 2 1 2 2 2 2 1 2 2 2 1 2 1 1]实际值: [1 0 2 2 0 0 1 2 1 0 0 0 1 2 1 0 1 0 2 0 2 0 1 0 2 1 2 2 2 2 1 2 2 2 1 1 1 1]准确率1: 0.9473684210526315准确率2: 0.9473684210526315人工准确率: 0.9473684210526315 ''' 2: KNN算法诊断癌症1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import numpy as npimport pandas as pdfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn.model_selection import train_test_splitdata = pd.read_csv('./cancer.csv', sep='\\t') # sep='\\t'分隔符是table键y = data['Diagnosis']X = data.iloc[:, 2:]display(y.head(), X.head()) # 细胞的各项指标X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=1024)# for循环寻找最准确的k值score = []for k in np.arange(2, 16): knn = KNeighborsClassifier(n_neighbors=k, weights='uniform', algorithm='kd_tree') # n_neighbors选取的邻居的数量, 默认为5(一般小于总样本呢量的开平放), 例如 样本数为100, 邻居数量小于10 # weights='distance'各样本权重的不同(最后计算平均值); weights='uniform'各样本的权重统一(默认)(最后计算平均值) # algorithm='kd_tree' 寻找邻居的方式为KD树, algorithm=brute(蛮力-计算所有样本到目标值的距离) knn.fit(X_train, y_train) s = knn.score(X_test, y_test) score.append([k,s])score = pd.DataFrame(score, columns=['k', 'accuracy'])print(score)acc = score['accuracy']index = acc.idxmax() # 获取accuracy最大时对应的k值print('最合适的k数量:', score['k'][index])''' k accuracy0 2 0.9230771 3 0.9160842 4 0.9230773 5 0.9160844 6 0.9370635 7 0.9160846 8 0.9370637 9 0.9370638 10 0.9370639 11 0.93706310 12 0.93706311 13 0.94405612 14 0.93007013 15 0.937063最合适的邻居数量: 13'''当k=13时, 预测诊断的效果最好; (二): 回归应用12345678910111213141516171819import numpy as npimport matplotlib.pyplot as pltfrom sklearn.neighbors import KNeighborsRegressor # 回归# 魔法指令，预加载,显示画图(新版本不需要)%matplotlib inlineX = np.linspace(0,2*np.pi, 60).reshape(-1, 1) # 元数据只是1维的,算法使用的数据的结构必须是二维的X_test = np.linspace(0,2*np.pi, 256).reshape(-1,1)y = np.sin(X)plt.scatter(X,y)knn = KNeighborsRegressor(weights='distance') # distance每个样本的权重不一样, 计算带权重的平均值# uniform每个样本的权重一样, 计算平均值knn.fit(X, y)y_ = knn.predict(X_test)plt.plot(X_test, y_, color='red')plt.scatter(X,y, color='green') (三): 交叉表1pd.crosstab(index = y_test, columns=y_, rownames=['确诊'], colnames=['预测'],margins=True) 六: 数据预处理(一): 数据归一化1: 最大值最小值归一化也称为离差标准化，是对原始数据的线性变换，使结果值映射到[0 - 1]之间。 转换函数如下：$$x_{normalization} = \\frac{x - min}{max-min}$$优化上面癌症诊断的例子: 123456789101112131415161718192021# 方法一: 手写最大值最小值归一化X1 = (X - X.min())/(X.max()-X.min())# 方法二: 直接调用最大值最小值归一化from sklearn.preprocessing import MinMaxScaler # 最小值最大值归一化方法scaler = MinMaxScaler()X1 = scaler.fit_transform(X)# 训练并诊断(1000次取平均)score = 0for i in range(1000): X_train, X_test, y_train, y_test = train_test_split(X1, y) knn = KNeighborsClassifier() knn.fit(X_train, y_train) score += knn.score(X_test, y_test)/1000print(score)'''0.9674265734265755'''可见,诊断准确率明显提高 2: Z-score归一化这种方法给予原始数据的均值（mean）和标准差（standard deviation）进行数据的标准化。经过处理的数据符合标准正态分布，即均值为0，标准差为1 转化函数为：$$x_{normalization} = \\frac{x - \\mu}{\\sigma}$$$\\mu$是平均值 $\\sigma$是标准差 优化上面癌症诊断的例子: 1234567891011121314151617181920# 方法一: 手写Z-score归一化X2 = (X - X.mean())/(X.std()) # std是标准差,求每个属性的平均值X2.std() # Z-score归一化返回的结果的标准差是1# 方法二: 调用Z-score归一化from sklearn.preprocessing import StandardScalerscaler = StandardScaler()X2 = scaler.fit_transform(X)score = 0for i in range(1000): X_train, X_test, y_train, y_test = train_test_split(X2, y) knn = KNeighborsClassifier() knn.fit(X_train, y_train) score += knn.score(X_test, y_test)/1000print(score)'''0.9649860139860167''' 3: sigmoid归一化转换函数:$$x_{normalization} = \\frac{1}{1+e^{-x}}$$代码略 sigmoid函数对本组数据优化效果不好,说明并不适用于本组数据 (二): 3 sigma剔除异常值原理:$$|𝑋−𝜇|&gt;3𝜎$$ $\\mu$是平均值 $\\sigma是标准差$ 满足以上判断条件的值为异常值 代码实现(剔除异常癌症数据): 123456789101112131415161718192021222324252627282930313233343536373839import numpy as npfrom sklearn.model_selection import train_test_splitfrom sklearn.neighbors import KNeighborsClassifier # knnfrom sklearn.preprocessing import StandardScaler, MinMaxScaler # 归一化方法import pandas as pd# 获取数据data = pd.read_csv('./cancer.csv', sep='\\t')X = data.iloc[:, 2:]y = data.iloc[:, 1]# 归一化scaler = StandardScaler()X = scaler.fit_transform(X)# 异常值处理# 正常值cond = np.abs(X-X.mean(axis=0)) &lt; 4*X.std(axis=0) # 根据数据调整sigema的系数cond = cond.all(axis=1) X1 = X[cond]y1 = y[cond]# 异常值cond = np.abs(X-X.mean(axis=0)) &gt; 4*X.std(axis=0)cond = cond.any(axis=1) X2 = X[cond]score = 0for i in range(1000): X_train, X_test, y_train, y_test = train_test_split(X1, y1) knn = KNeighborsClassifier() knn.fit(X_train, y_train) score += knn.score(X_test, y_test)/1000print('数据清洗后的准确率:', score)'''数据清洗后的准确率: 0.964276119402978''' 借鉴文章 - K近邻法(KNN)原理小结 - 刘建平","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"KNN","slug":"KNN","permalink":"https://anjhon1994.github.io/tags/KNN/"},{"name":"算法","slug":"算法","permalink":"https://anjhon1994.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"常用指令集","slug":"后端/Linux和Git命令集","date":"2019-01-19T16:00:00.000Z","updated":"2021-01-07T14:47:24.372Z","comments":true,"path":"2019/01/20/后端/Linux和Git命令集/","link":"","permalink":"https://anjhon1994.github.io/2019/01/20/%E5%90%8E%E7%AB%AF/Linux%E5%92%8CGit%E5%91%BD%E4%BB%A4%E9%9B%86/","excerpt":"","text":"Git对本地实施版本控制并同步到服务器: git init —&gt; 将普通文件夹变成版本仓库 git add . —&gt; 将文件从工作区同步到暂存区 git commit -m ‘项目描述信息’ —&gt; 将文件提交到本地仓库 git status —&gt; 查看当前的执行状态(经常用) git log —&gt; 查看版本 git reflog —&gt; git reset –hard 版本号 —&gt; 去到指定版本 git tag v0.1 —&gt; 添加版本号0.1 git remote add origin —&gt; 绑定远端仓库 git remote -v —&gt; 查看是否已经连接远端仓库 git push -u origin master —&gt; 将本地代码推到服务器仓库(第一次绑定才需要加 -U 为了指定上行流,要把代码推到哪里去) git pull git pull –allow-unrelated-histories origin master —&gt; 当远端和本地版本不同时,将远端的东西pull下来和本地合并 git reset –hard HEAD^ —&gt; 回到上一版本 git clone –depth=1 gitegitee.com:jackfrued/djangocase.git djangocse2 —&gt; 克隆djangocase,只克隆最新版本–depth=1, 重命名为djangocase2, git remote remove origin ： 删除与远端仓库的关联 git revert 版本号 ： 可以修改版本信息 git diff 在空文件夹内加.gitkeep文件,则空文件夹在版本控制时不会被忽略 Linux123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153grep -vE ---&gt; -v表示不搜什么,E表示正则表达式感叹号加历史记录的编号 -&gt; 将历史命令重新执行一遍!v -&gt; 将历史记录中最近的以v开头的命令执行一遍history -c -&gt; 将历史记录全部清除alias 'll=ls -l' -&gt; 命令别名unalias ll -&gt; 取消别名yum update -&gt; 更新库内能更新的包nohup make &gt;&gt; ~/install.log &amp; -&gt; 将程序放到后台运行,并且不接受中断信号chmod u+x,g+x,o+x test.py = chmod 755 test.pyetc目录是专门放配置文件的在.py文件内加入以下代码,写了文件名就能执行文件#!/usr/bin/python3 # -*- coding: utf-8 -*-# 查看当前登录的用户信息who 看所有w 能看到最详细的登录信息who am i 看自己whoami 看自己用户名last 查看最近登录的用户# 关机系列shutdown 关机shutdown now 立即关机shutdown -r 重启shutdown -h 关机后关闭电源halt 关机关电源reboot 重启# 其他logout 登出cal 查看日历date 查看当前时间man 查看命令帮助手册su(switch user) 用户名 切换用户exit 退出当前用户adduser / passwd / userdel 创建用户(-g指定分组) / 修改密码 / 删除用户date / cal 查看时间write / wall / mesg 发消息clear 清屏man / info / --help 参看帮助history 历史命令 -c 清除历史命令# 文件相关命令1. pwd2. cd3. ls -l 长格式查看 -a 所有文件 -R 递归查看 -d 只看文件夹4. cat -n 给文件添加行号查看5. touch 创建空文件6. mkdir 创建文件夹 -p 创建父文件夹7. rm 删除 -f 强制删除 -r 递归删除8. rmdir 删除空文件夹9. wget 通过网络获取文件 - O 下下来重命名 - 例 wget https://www.baidu.com10. gzip / gunzip 压缩 / 解压缩11. xz -z 压缩 -d 解压缩12. tar -xvf 解归档 -cvf 归档13. sort 排序14. uniq 文件去重15. more 分页查看文件16. cpcp 文件名 路径 拷贝文件到路径cp 文件名 路径+文件名 拷贝文件到路径并重命名cp -r 文件夹 路径 拷贝文件夹到路径17. mvmv 文件名 路径 移动文件到路径mv 文件夹 路径 移动文件夹到路径mv 文件名 路径+文件名 移动文件到路径并重命名mv 文件名1 文件名2 重命名| 管道:将多个进程连接起来,将上一个命令的输出作为下一个命令的输入&gt; 重定向&gt;&gt; 追加重定向2&gt; 错误输出重定向2&gt;&gt; 错误追加输出重定向# vim编辑器的使用dd 删除一行100 dd 删除100行:set nu 显示行号:set nonu 不显示行号:set ts=4 设置tabl键为4个空格uu 撤销vim的三种模式:- 命令模式-按键代表命令 ---i或者a---&gt;编辑模式 ---:或者/--&gt;未行模式 ~ G - 光标移到文件末尾 / 500G - 光标移到第500行 / gg-光标移到行首 / hjkL-左下右上（前面可以加数字） ~ CtrL+y / Ctrl+e - 移动一行 ~ CtrL+f / Ctrl+b - 翻一页 ~ 0 - 光标到行首 / $ - 光标到行尾 / w - 光标移到下一个单词 ~ dd - 删除光标所在行 / 100dd - 从光标所在行向下删除100行 ~ yy - 复制光标所在行 / 10yy - 从光标所在行开始复制10行 ~ p - 粘贴 / 5p-粘贴5遍 ~ u - 撤销 / ctrl+r - 恢复- 编辑模式-键入内容 ---Esc---&gt;命令模式- 末行模式-搜索/配置/执行系统命令 ---Enter---&gt;命令模式 ~ set nu-显示行号-set nonu ~ syntax on-显示高亮语法-syntax off ~ set ts=4-修改制表键的空格数 ~ set ruler-显示光标所在的位置-set norulervim配置创建文件 .vimrcset nu 设位置行号syntax on 语法高亮set ts=4 设置制表键为4个空格set expandtab 将制表键转换成空格set autoindent 自动缩进set ruler 显示光标set nohls 设置高亮# 题外话配置python3环境变量1. 注册PATH环境变量cd~vim.bash_profilePATH=...：/usr/Local/python37/bin2. 激活环境变量source.bash_profile3. 测试安装是否成功python3--version## 命令别名alias ll='ls -l' 将ls -l 命名为llunalias ll 取消别名vim宏操作~ 录制宏: qa（a是寄存器的名字）- 在录制宏是左下角会显示 recoding~ 结束录制: q~ 播放宏: @a（a是寄存器的名字）- 前面可以加数值,表示播放几遍 SQL12345678select user,host from mysql.user; ---&gt; 查询所有的用户和登录主机select current_user(); ---&gt; 查询当前用户mysql -u root -p ---&gt; 登录mysql数据库redis-server --requirepass 119148 --port 6379 &gt;&gt; redis.log &amp; ---&gt; 启动redis服务器,设置连接密码,指定redis端口,将日志文件写到redis.log文件,并且后台运行redis-cli ---&gt; 登录redisauth: ---&gt; 输入密码","categories":[{"name":"Linux","slug":"Linux","permalink":"https://anjhon1994.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://anjhon1994.github.io/tags/Linux/"},{"name":"git","slug":"git","permalink":"https://anjhon1994.github.io/tags/git/"},{"name":"配置","slug":"配置","permalink":"https://anjhon1994.github.io/tags/%E9%85%8D%E7%BD%AE/"},{"name":"技术文档","slug":"技术文档","permalink":"https://anjhon1994.github.io/tags/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"}]},{"title":"Linux中python相关软件安装记录","slug":"后端/linux软件安装","date":"2019-01-19T16:00:00.000Z","updated":"2020-07-04T15:39:39.804Z","comments":true,"path":"2019/01/20/后端/linux软件安装/","link":"","permalink":"https://anjhon1994.github.io/2019/01/20/%E5%90%8E%E7%AB%AF/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/","excerpt":"Linux中的Python, MySQL, Redis, Nginx安装,基础环境配置","text":"Linux中的Python, MySQL, Redis, Nginx安装,基础环境配置 Linux基本配置配置vim编辑器123456789cd ~vim .vimrc set nu # 行号 set ts=4 # 设置制表键空格数量 set autoindent # 自动缩进 set expandtab # 制表键自动变空格 set ruler # 显示光标位置 set nohls # 选中的代码不高亮 syntax on # 语法高亮 查看命令别名12cd ~vim .bashrc 修改用户名前的一长串12vim /etc/bashrc41行删除@\\h 后端相关的开发工具安装Linux软件安装方法123456789101112131. 包管理工具 - yum CentOS ~ yum search nginx ---&gt; 查看安装库内是否已经安装nginx ~ yum install nginx ---&gt; 安装 ~ yum erase nginx / yum remove nginx ---&gt; 卸载 ~ yum info nginx ---&gt; 查看软件信息 ~ yum list installed | grep nginx ---&gt; 查看是否已经安装 - rpm Redhat ~ rpm -ivh 下载的rpm包文件名 ~ rpm -e ~ rpm -qa - apt Ubuntu2. 源代码构建安装 Nginx安装123yum install -y nginxsystemctl start nginxsystemctl stop nginx MariaDB安装(MySQL 5.x 的一个分支,和5.x版本基本相同)123yum install -y mariadb mariadb-serversystemctl start mariadbmysql -u root MySQL安装1234567891011121314151617181920212223241. 清除掉所有跟mariadb相关的东西 yum list installed | grep mariadb | awk '&#123;print $1&#125;' | xargs yum erase -y2. 清理之前的数据和日志文件（如果存在） rm -rf /var/lib/mysql rm -f /var/log/mysqld.log3. 下载MySQL官方提供的RPM包并解归档 wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.28-1.el7.x86_64.rpm-bundle.tar tar -xvf mysql-5.7.28-1.el7.x86_64.rpm-bundle.tar4. 安装依赖库 yum install -y libaio5. 使用rpm包管理工具安装MySQL rpm -ivh mysql-community-common-5.7.28-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-5.7.28-1.el7.x86_64.rpm rpm -ivh mysql-community-client-5.7.28-1.el7.x86_64.rpm rpm -ivh mysql-community-server-5.7.28-1.el7.x86_64.rpm6. 启动服务查看随机密码 systemctl start mysqld cat /var/log/mysqld.log | grep password7. 用客户端工具连接MySQL mysql -u root -p8. 修改root用户口令 set global validate_password_policy=0; set global validate_password_length=6; alter user 'root'@'localhost' identified by '123456'; Redis安装123456安装Redis官方最新版wget http://download.redis.io/releases/redis-5.0.7.tar.gzgunzip redis-5.0.7.tar.gztar -xvf redis-5.0.7.tarcd redis-5.0.7make &amp;&amp; make install GIt安装12345678安装Git官方最新版wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.24.1.tar.xzxz -d git-2.24.1.tar.xztar -xf git-2.24.1.tarcd git-2.24.1yum install -y curl libcurl-devel./configure --prefix=/usr/localmake &amp;&amp; make install Python3安装123456789101112131415161. 安装依赖项 yum install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel2. 下载Python3源代码 wget https://www.python.org/ftp/python/3.7.6/Python-3.7.6.tar.xz3. 解压缩和解归档 xz -d Python-3.7.6.tar.xz tar -xvf Python-3.7.6.tar4. 执行安装前的配置 cd Python-3.7.6 ./configure --prefix=/usr/local/python37 --enable-optimizations5. 构建和安装 make &amp;&amp; make install6. 注册环境变量 vim ~/.bash_profile PATH=$PATH:/usr/local/python37/bin export PATH","categories":[{"name":"Linux","slug":"Linux","permalink":"https://anjhon1994.github.io/categories/Linux/"}],"tags":[{"name":"配置","slug":"配置","permalink":"https://anjhon1994.github.io/tags/%E9%85%8D%E7%BD%AE/"},{"name":"技术文档","slug":"技术文档","permalink":"https://anjhon1994.github.io/tags/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"},{"name":"Linux软件","slug":"Linux软件","permalink":"https://anjhon1994.github.io/tags/Linux%E8%BD%AF%E4%BB%B6/"},{"name":"服务器","slug":"服务器","permalink":"https://anjhon1994.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"岭回归(Ridge)和套索回归(Lasso)","slug":"机器学习/岭回归(Ridge)和套索回归(Lasso)","date":"2018-11-29T16:00:00.000Z","updated":"2021-01-08T14:23:53.844Z","comments":true,"path":"2018/11/30/机器学习/岭回归(Ridge)和套索回归(Lasso)/","link":"","permalink":"https://anjhon1994.github.io/2018/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%B2%AD%E5%9B%9E%E5%BD%92(Ridge)%E5%92%8C%E5%A5%97%E7%B4%A2%E5%9B%9E%E5%BD%92(Lasso)/","excerpt":"","text":"一: 拟合(一): 过拟合与欠拟合机器学习中一个重要的话题便是模型的泛化能力，泛化能力强的模型才是好模型，对于训练好的模型，若在训练集表现差，不必说在测试集表现同样会很差，这可能是欠拟合导致；若模型在训练集表现非常好，却在测试集上差强人意，则这便是过拟合导致的; 过拟合与欠拟合也可以用 Bias 与 Variance 的角度来解释，欠拟合会导致高 Bias; 过拟合会导致高 Variance ，所以模型需要在 Bias 与 Variance 之间做出一个权衡 Bias 即为模型的期望输出与其真实输出之间的差异； Variance 刻画了不同训练集得到的模型的输出与这些模型期望输出的差异。 一般在模型效果差的第一个想法是增多数据，其实增多数据并不一定会有更好的结果，因为欠拟合时增多数据往往导致效果更差，而过拟合时增多数据会导致 Gap 的减小，效果不会好太多，所以当模型效果很差时，应该检查模型是否处于欠拟合或者过拟合的状态，而不要一味的增多数据量，关于过拟合与欠拟合，这里给出几个解决方法。 (二): 常用解决办法(1)解决欠拟合的方法： 1、增加新特征，可以考虑加入进特征组合、高次特征，来增大假设空间; 2、尝试非线性模型，比如核SVM 、决策树、DNN等模型; 3、如果有正则项可以调小正则项参数 $\\lambda$; 4、Boosting ,Boosting 往往会有较小的 Bias，比如 Gradient Boosting 等. (2)解决过拟合的方法： 1、交叉检验，通过交叉检验得到较优的模型参数; 2、特征选择，减少特征数或使用较少的特征组合，对于按区间离散化的特征，增大划分的区间; 3、正则化，常用的有 L1、L2 正则。而且 L1正则还可以自动进行特征选择; 4、如果有正则项则可以考虑增大正则项参数 lambda; 5、增加训练数据可以有限的避免过拟合; 6、Bagging ,将多个弱学习器Bagging 一下效果会好很多，比如随机森林等. 二: Ridge回归 - 岭回归1: Ridge回归 - 梯度下降(在线性回归后加上L2正则项-解决过拟合问题)损失函数:$$J(w) = \\min\\limits_w||Xw-y||_2^2 + \\alpha||w||_2^2$$ $$\\frac{1}{m}$$表示m个样本求平均:$$J(w) = \\frac{1}{m}\\sum_{i=1}^m(||X_iw-y_i||_2^2 + \\alpha||w||_2^2)$$ $$J(w) = \\frac{1}{m}[(Xw-y)^T(Xw-y)+\\alpha w^Tw]$$ 求解梯度(导数):$$J’(w) = \\frac{2}{m}[X^T(Xw-y)+\\alpha w]$$ $$\\nabla_wJ(w) = \\frac{2}{m} [X^T(Xw - y) +\\alpha w]$$ 更新w:$$w = w-\\epsilon \\nabla_wJ(w)$$ $$w = w -\\frac{2}{m}\\epsilon[X^T(Xw-y)+\\alpha w]$$ $$w = w -\\frac{2\\epsilon}{m} X^T(Xw-y)-\\frac{2\\alpha\\epsilon}{m} w$$ $$w = [w -\\frac{2\\epsilon}{m} X^T(Xw-y)]-\\frac{2\\alpha\\epsilon}{m} w$$ 如上公式, 中括号内的公式是线性回归的更新规则, 也就是说岭回归就是在 线性回归的基础上多减了一项,$$\\frac{2\\alpha\\epsilon}{m} w$$, 其 中: ​ $$\\alpha &gt;= 0$$缩放强度 ​ $$\\epsilon&gt;=0$$步幅 ​ $$m&gt;0$$样本数量 当w是正数时：$$\\frac{2\\epsilon\\alpha}{m}w$$ 为正数,此时岭回归就相当于在线性回归的基础上减去一个正数, 所以系数w变小 当w是负数时：$$\\frac{2\\epsilon\\alpha}{m}w$$ 为负数,此时岭回归就相当于在线性回归的基础上减去一个负数, 所以系数w的绝对值变小 正则项：w变小的好处：防止过拟合 岭回归适用范围: 方程完全共线性(方程内有方程是其他方程的倍数,相当于重复方程): x+ 2y + 22 = 9 2x +4y + 42 = 18 岭回归适用于数据中存在共线性的情况(非满秩矩阵) 2: Ridge回归正规方程推导:损失函数:$$J(w) = \\min\\limits_w||Xw-y||_2^2 + \\alpha||w||_2^2$$ $$J(w)=(Xw-y)^T(Xw-y)+\\alpha w^Tw$$ 求导:$$\\nabla_wJ(w)=2X^TXw-2X^Ty+2\\alpha w$$令导数为0:$$2X^TXw-2X^Ty+2\\alpha w=0$$ $$X^TXw-X^Ty+\\alpha Iw=0$$ $$(X^TX+\\alpha I)w-X^Ty=0$$ $$(X^TX+\\alpha I)w=X^Ty$$ $$(X^TX+\\alpha I)^{-1}(X^TX+\\alpha I)w=(X^TX+\\alpha I)^{-1}X^Ty$$ 推导得出w:$$w=(X^TX+\\alpha I)^{-1}X^Ty$$ 3: Ridge回归和线性回归对比12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import numpy as npfrom sklearn.linear_model import LinearRegression, Ridge, Lasso# 将数据一分为二from sklearn.model_selection import train_test_split# 均方误差from sklearn.metrics import mean_squared_errorimport pandas as pd# 加载数据# 加载训练数据# train = pd.read_table('./zhengqi_train.txt') 和下面一行的效果相同train = pd.read_csv('./zhengqi_train.txt', sep = '\\t')train# 加载测试数据test = pd.read_table('./zhengqi_test.txt')test# 将训练数据分乘特征值和目标值# 特征, 影响目标值的因素X = train.iloc[:, :-1]# 目标值y = train['target']# 算法评估, 将上面的数据分成两份,一部分用来训练, 一部分用来测试X_train, X_validation, y_train, y_validation = train_test_split(X, y, test_size = 0.2)# 使用普通线性回归模型linear = LinearRegression()linear.fit(X_train, y_train)y_ = linear.predict(X_validation)mean_squared_error(y_validation,y_) # 均方误差'''0.11713370444738197'''# 使用线性模型预测测试数据y_commit = linear.predict(test)# 保存数据到本地s = pd.Series(y_commit)s.to_csv('./linear_result.txt', index=False, header = False)# 使用岭回归模型ridge = Ridge(alpha=256) # alpha值ridge.fit(X_train, y_train)y_ = ridge.predict(X_validation)mean_squared_error(y_validation,y_)'''0.13427749653218798'''y_commit = ridge.predict(test)pd.Series(y_commit).to_csv('./ridge_result.txt', index=False, header = False) 将生成的数据上传到阿里天池,与实际数据对比,计算均方误差时, 使用岭回归模型得到的数据比使用线性回归模型得到的数据的均方误差要小,说明对该组数据,岭回归效果更好 三: lasso回归 - 套索回归1: lasso回归 - 梯度下降(在线性回归后加上L1正则项-解决过拟合问题)罗斯回归方程:$$\\min\\limits_w \\frac{1}{2n_{samples}}||Xw-y||_2^2+\\alpha ||w||_1$$方程转换:$$J(w)=||Xw-y||_2^2+\\alpha ||w||_1$$向量的1范数: 取绝对值的最大值 由于求导时方程中不能有绝对值符号, 所以分情况讨论: w是正数或者为负数 求导:$$\\nabla_wJ(w)=2X^TXw-2X^Ty+\\alpha sgn(w)$$sgn(w)是符号表示函数: sgn(w)代表着w&gt;0那么sgn(w)=+1;如果w&lt;0那么sgn(W)=-1 梯度下降中系数w的更新规则:$$w = w - \\epsilon \\nabla_wJ(w)$$ $$w = w - \\epsilon(X^TXw-X^Ty)-\\epsilon \\alpha sgn(w)$$ $$w = [w - \\epsilon(X^TXw-X^Ty)]-\\epsilon \\alpha sgn(w)$$ 当w为正时候sgn(w) =+1,直接去掉减去入所以正的w变小了 当w为负时候sgn(w)=-1,负号变成了正号加上了入,负数w取向零 Lasso回归系数可以缩减到0,岭回归不可以 系数(权重)变成0了,说明:可有可无,属性不重要 2: lasso回归与岭回归和线性回归对比12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import numpy as npfrom sklearn.linear_model import LinearRegression, Ridge, Lasso# 将数据一分为二from sklearn.model_selection import train_test_split# 均方误差from sklearn.metrics import mean_squared_errorimport pandas as pd# 加载数据# 加载训练数据# train = pd.read_table('./zhengqi_train.txt') 和下面一行的效果相同train = pd.read_csv('./zhengqi_train.txt', sep = '\\t')train# 加载测试数据test = pd.read_table('./zhengqi_test.txt')test# 将训练数据分乘特征值和目标值# 特征, 影响目标值的因素X = train.iloc[:, :-1]# 目标值y = train['target']# 算法评估, 将上面的数据分成两份,一部分用来训练, 一部分用来测试X_train, X_validation, y_train, y_validation = train_test_split(X, y, test_size = 0.2)# 使用普通线性回归模型linear = LinearRegression()linear.fit(X_train, y_train)y_ = linear.predict(X_validation)mean_squared_error(y_validation,y_) # 均方误差'''0.11713370444738197'''# 使用线性模型预测测试数据y_commit = linear.predict(test)# 保存数据到本地s = pd.Series(y_commit)s.to_csv('./linear_result.txt', index=False, header = False)# 使用岭回归模型ridge = Ridge(alpha=256) # alpha值ridge.fit(X_train, y_train)y_ = ridge.predict(X_validation)mean_squared_error(y_validation,y_)'''0.13427749653218798'''y_commit = ridge.predict(test)pd.Series(y_commit).to_csv('./ridge_result.txt', index=False, header = False)# 使用lasso回归模型lasso = Lasso(alpha=256)lasso.fit(X_train, y_train)y_ = lasso.predict(X_validation)mean_squared_error(y_validation,y_)'''0.9351911263395224'''y_commit = lasso.predict(test)pd.Series(y_commit).to_csv('./lasso_result.txt', index=False, header = False) 将生成的数据上传到阿里天池,与实际数据对比,计算均方误差时, 使用lasso回归模型得到的数据比使用岭回归模型和线性回归模型得到的数据的均方误差要小,说明对该组数据,lasso回归效果较好好 套索回归适用于稀松矩阵(大部分系数是0) 四: Elastic-Net - 弹性网络回归弹性网络回归方程:$$\\min_{w} { \\frac{1}{2n_{\\text{samples}}} ||X w - y||_2 ^ 2 + \\alpha \\rho ||w||_1 +\\frac{\\alpha(1-\\rho)}{2} ||w||_2 ^ 2}$$ 使用弹性网络回归预测工业蒸汽量:(在线性回归后加L1, L2正则项来解决过拟合问题) 12345678910111213141516171819202122232425262728293031323334353637383940414243import numpy as np# ElasticNetCV 交叉验证(可以一次传递多个参数, 模型挑选合适的)from sklearn.linear_model import LinearRegression, Ridge, ElasticNet, ElasticNetCV# 将数据一分为二from sklearn.model_selection import train_test_split# 均方误差from sklearn.metrics import mean_squared_errorimport pandas as pd# 加载数据# 加载训练数据# train = pd.read_table('./zhengqi_train.txt') 和下面一行的效果相同train = pd.read_csv('./zhengqi_train.txt', sep = '\\t')train# 加载测试数据test = pd.read_table('./zhengqi_test.txt')test# 将训练数据分乘特征值和目标值# 特征, 影响目标值的因素X = train.iloc[:, :-1]# 目标值y = train['target']# 算法评估, 将上面的数据分成两份,一部分用来训练, 一部分用来测试# random_state = 1024 ; 种子固定,当数值固定时,生成的随机数是固定的X_train, X_validation, y_train, y_validation = train_test_split(X, y, test_size = 0.2, random_state = 1024)# ElasticNetCV可以筛选多个alpha中最好的一个model = ElasticNetCV(l1_ratio=0.05, alphas=[0.1, 0.2, 0.5, 1.0, 2.0, 5.0, 10.0])model.fit(X, y)y_ = model.predict(X_validation)mean_squared_error(y_validation,y_)'''0.10872462328271233'''model.alpha_ # 返回选择的alpha值result = model.predict(test)pd.Series(result).to_csv('./elastic.txt', index=False, header=False)","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"https://anjhon1994.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Lasso回归","slug":"Lasso回归","permalink":"https://anjhon1994.github.io/tags/Lasso%E5%9B%9E%E5%BD%92/"},{"name":"Ridge回归","slug":"Ridge回归","permalink":"https://anjhon1994.github.io/tags/Ridge%E5%9B%9E%E5%BD%92/"}]},{"title":"线性回归","slug":"机器学习/线性回归","date":"2018-10-20T16:00:00.000Z","updated":"2021-01-08T14:22:50.539Z","comments":true,"path":"2018/10/21/机器学习/线性回归/","link":"","permalink":"https://anjhon1994.github.io/2018/10/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/","excerpt":"","text":"一: 线性回归方程​ 线性回归（英语：linear regression）是利用称为线性回归方程的最小二乘函数对一个或多个自变量和因变量 之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。只有一个自变量 的情况称为简单回归，大于一个自变量情况的叫做多元回归 ​ 在线性回归中，数据使用线性预测函数来建模，并且未知的模型参数也是通过数据来估计。这些模型被叫做 线性模型。最常用的线性回归建模是给定X值的y的条件均值是X的仿射函数。不太一般的情况，线性回归模型可以 是一个中位数或一些其他的给定X的条件下y的条件分布的分位数作为X的线性函数表示。像所有形式的回归分析一 样，线性回归也把焦点放在给定X值的y的条件概率分布，而不是X和y的联合概率分布（多元分析领域）。 ​ 线性回归有很多实际用途。分为以下两大类： 如果目标是预测或者映射，线性回归可以用来对观测数据集的和X的值拟合出一个预测模型。当完成这样一个 模型以后，对于一个新增的X值，在没有给定与它相配对的y的情况下，可以用这个拟合过的模型预测出一个y 值。 给定一个变量y和一些变量${\\displaystyle X_{1}}X_1,…,{\\displaystyle X_{p}}X_p$，这些变量有可能与y相关，线性回归分析可以用来量化y与Xj之 间相关性的强度，评估出与y不相关的，${\\displaystyle X_{j}}X_j$并识别出哪些${\\displaystyle X_{j}}X_j$的子集包含了关于y的冗余信息。 使用sklearn线性回归模型(jupyter)这里我们以波士顿的房价数据来进行使用分析 (一): 导入sklearn123456789import numpy as np# 线性回归,拟合方程,求解系数, 一次幂# 线性方程:直来直去,不拐弯from sklearn.linear_model import LinearRegression# 导入数据集from sklearn import datasets# 导入数据分离的方法(获取数据后,一部分数据用来让回归模型学习,另一部分用来预测)from sklearn.model_selection import train_test_split (二): 获取波士顿房价数据1234567891011121314151617# 获取的数据是numpy,ndarray类型data = datasets.load_boston() # 该数据内有完整的影响房价的因素和完整的房价信息,本次实验就是将数据分为两部分, 一部分用来训练模型,另一部分用来预测,最后将预测出来的数据和已有的完整信息进行对比,判断该模型是否适用于这组房价数据data # 查看data的数据结构data.feature_names # 查看影响房价的属性名# x是属性,特征,未知数X = data['data']X.shape # 运行结果是(506, 13), 506表示样本是506个, 每个样本采集了13个属性特征;13个属性,需要构建构建了13元一次方程# y是房价的估值y = data['target']# !!!!!!!!!!# X, y = datasets.load_boston(True) 获取到X, y的值和以上的一样 (三): 使用模型进行预测12345678910111213141516X_train, X_test, y_train, y_test = train_test_split(X, y) # 将数据进行分离(默认是3:1); train_test_split(X, y)函数会随机打乱顺序display(X_train.shape, X_test.shape) # (379, 13) ; (127, 13)# 声明算法linear = LinearRegression()# 训练模型linear.fit(X_train, y_train) # X_train, y_train是之前分离出来用来训练模型的数据# 预测y_ = linear.predict(X_test).round(1) # X_test是影响房价的因素,该预测模型能根据影响房价的因素预测剩余部分的房价# 预估数据和实际数据比较print(y_)print(y_test) 经过估计数据和实际数据对比,说明算法模型适用于数据 (四): 自建方程预测数据 与 使用线性模型得到的数据对比​ 假设波士顿的房价数据符合线性回归的特性,则我们可以通过构建线性方程来预测波士顿剩余部分的房价信息 根据一次线性回归方程: $f(X) = Xw+b$ 可推导得出: $ f(X) = w_1x_1+W_2x_2+…+w_{13}x_{13} +b$ (有13个影响房 价的因素) 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243# 通过训练模型,可从模型中得出系数ww_ = linear.coef_# 通过训练模型,可从模型中得出截距bb_ = linear.intercept_# 自建方程def fun(w_, b_, X): return np.dot(X, w_)+b_# 调用方程得到预估的房价信息fun(w_, b_, X_test).round(1) # round(1)保留一位小数'''array([31.3, 13.4, 28.6, 20.5, 20.4, 19.4, 32.2, 24. , 25.8, 29.5, 24.5, 25.2, 31.9, 8.2, 20.9, 29.3, 22.3, 35.2, 16.4, 18.5, 30.8, 41.1, 16.2, 13.7, 17.7, 23.8, 7.8, 12. , 20.5, 15.3, 29.3, 26.8, 31.8, 26. , 30.4, 39.2, 25.3, 40.7, 11.6, 27.3, 16.7, 18.8, 19.5, 19.9, 20.7, 22.8, 17.4, 21.6, 23.3, 30. , 25.2, 23.7, 34.2, 18.2, 33.5, 16. , 28.3, 14.1, 24.2, 16.2, 16.7, 23.5, 16. , 21.4, 21.8, 28.2, 25.7, 31.2, 18.8, 26.4, 28.3, 21.9, 27.5, 27.1, 27.1, 15. , 26. , 26.3, 13.2, 13.3, 26.1, 20.5, 16.8, 24.3, 36.6, 21.4, 8.3, 27.8, 3.6, 19.2, 27.5, 33.6, 28.4, 34.3, 28.2, 13.3, 18. , 23.5, 30.4, 32.9, 23.7, 30.5, 19.8, 19.5, 18.7, 30.9, 36.3, 8. , 18.2, 13.9, 15. , 26.4, 24. , 30.2, 20. , 5.6, 21.4, 22.9, 17.6, 32.8, 22.1, 32.6, 20.9, 19.3, 23.1, 21. , 21.5])'''# 使用sklesrn中的线性模型得到的预估房价信息linear.predict(X_test).round(1)'''array([31.3, 13.4, 28.6, 20.5, 20.4, 19.4, 32.2, 24. , 25.8, 29.5, 24.5, 25.2, 31.9, 8.2, 20.9, 29.3, 22.3, 35.2, 16.4, 18.5, 30.8, 41.1, 16.2, 13.7, 17.7, 23.8, 7.8, 12. , 20.5, 15.3, 29.3, 26.8, 31.8, 26. , 30.4, 39.2, 25.3, 40.7, 11.6, 27.3, 16.7, 18.8, 19.5, 19.9, 20.7, 22.8, 17.4, 21.6, 23.3, 30. , 25.2, 23.7, 34.2, 18.2, 33.5, 16. , 28.3, 14.1, 24.2, 16.2, 16.7, 23.5, 16. , 21.4, 21.8, 28.2, 25.7, 31.2, 18.8, 26.4, 28.3, 21.9, 27.5, 27.1, 27.1, 15. , 26. , 26.3, 13.2, 13.3, 26.1, 20.5, 16.8, 24.3, 36.6, 21.4, 8.3, 27.8, 3.6, 19.2, 27.5, 33.6, 28.4, 34.3, 28.2, 13.3, 18. , 23.5, 30.4, 32.9, 23.7, 30.5, 19.8, 19.5, 18.7, 30.9, 36.3, 8. , 18.2, 13.9, 15. , 26.4, 24. , 30.2, 20. , 5.6, 21.4, 22.9, 17.6, 32.8, 22.1, 32.6, 20.9, 19.3, 23.1, 21. , 21.5])''' 通过自建模型获取预估数据与使用模型获取预估数据进行比较,两组数据完全一致; (五): 使用线性回归,求解斜率和截距 根据最小二乘法: $\\min_{w}||Xw-y||_2^2$ 推到得出公式: $w = (X^TX)^{-1}X^Ty$ 以上公式只能求出w,我们可以先求出w再计算出b; 但此处我们有更简单的方法: 根据线性回归方程 $ f(x) = w_1x_1+w_2x_2+b$ 我们可以将方程中的b看成是$w_3x_3^0$, 所以可得: $f(x) = w_1x_1^1+w_2x_2^1+w_3x_3^0$ 代码如下: 12345678910111213141516171819202122232425262728293031323334import numpy as npfrom sklearn.linear_model import LinearRegressionfrom sklearn import datasetsX, y = datasets.load_boston(True)linear = LinearRegression()linear.fit(X,y)w_ = linear.coef_b_ = linear.intercept_# 向X中插入一列全是1的数据(任何数的0次方都是1)X = np.concatenate([X, np.ones(shape = (506, 1))], axis=1)# 根据最小二乘法的推导公式:w和b的值为(最后一个值是b)w = ((np.linalg.inv(X.T.dot(X))).dot(X.T)).dot(y)# 以上w的写法过于装逼,所以分解为:# A = X.T.dot(X) 求X和转置后的X的内积(公式中的XTX)# B = np.linalg.inv(A) 求A的逆矩阵(公式中的-1次方)# C = B.dot(X.T) 求以上矩阵和X的转置矩阵的内积(公式中的XT)# w = C.dot(y) 与y求内积,得出w和b'''运行结果:array([-1.08011358e-01, 4.64204584e-02, 2.05586264e-02, 2.68673382e+00, -1.77666112e+01, 3.80986521e+00, 6.92224640e-04, -1.47556685e+00, 3.06049479e-01, -1.23345939e-02, -9.52747232e-01, 9.31168327e-03, -5.24758378e-01, 3.64594884e+01])'''print(b_)'''运行结果:36.45948838509001''' 扩展一: 最小二乘法和向量范数$\\min_{w}||Xw-y||_2^2$ 右上角的2是平方 右下角的2是向量2范数 竖线内的表达式是向量 根据最小二乘法的公式, 推导得出 $$w = (X^TX)^{-1}X^Ty$$ 向量的1-范数(表示各个元素的绝对值的和) $$||X||_1 = \\sum\\limits_{i=1}^n |x_i|$$ 向量的2-范数(表示每个元素的平方和再开平方) $$||X||_2 = \\sqrt{\\sum\\limits_{i=1}^n x_i^2}$$ 向量的无穷范数(所有向量元素绝对值中的最大值) $$||X||_{\\infty} = \\max\\limits_{1 \\geq i \\leq n}|X_i|$$ 扩展二: 导数, 偏导数导数:对函数$f(x) = x^2+3x+8$ 求导得: $f(x)’ = 2x+3$ 求导规则: 参数求导为0 参数乘变量求导为常数 变量的次方求导: $x^y$求导为$yx^{y-1}$ 复合函数求导: $(x^2-x)^2$求导: 先将括号看成一个整体求导, 结果再乘以括号内的求导结果 $2(x^2-x)(2x-1)$ 偏导数:有多个变量得函数求导: 对函数: $f(x, y) = x^2+xy+y^2$ 求导: 求导规则: 多变量函数只能针对某一个变量求导,此时将其他变量看成常数 将x看成常数a: $f_a(y) = a^2+ay+y^2$ 求导得:$f_a’(y) = a+2y$ 故求导得: $\\frac{\\partial f}{\\partial y}(x,y)=x+2y$ 实现线性回归的两种方式: 正规方程 梯度下降 二: 正规方程(一): 损失函数最小二乘法: $$\\min\\limits_{w}||Xw-y||_2^2$$ 当X和y都是常数时,按照向量2范数将上面的最小二乘法解开: $$f(w)=(Xw-y)^2$$ 将X,y替换成常数a,b $$f(w)=(aw-b)^2$$ $$f(w)=a^2w^2 - 2abw + b^2$$ ​ 由于最小二乘法方程的函数值都是大雨或等于0的,所以此时得到一个开口向 上的抛物线(一元二次方程) ​ 此时的$f(w)$就是损失函数,在此时求该函数的导数(抛物线函数顶点的导数为0) 就能得到该函数的最小值,也就是最小损失 $$f’(w)=2a^2w-2ab=0$$ 此时即可算出最小的$w$,即最小损失 (二): 矩阵常用求导公式X的转置矩阵对X矩阵求导, 求解出来是单位矩阵 $$\\frac{dX^T}{dX} = I$$ $$\\frac{dX}{dX^T} = I$$ X的转置矩阵和一个常数矩阵相乘再对X矩阵求导, 求解出来就是改常数矩阵 $$\\frac{dX^TA}{dX} = A$$ $$\\frac{dAX}{dX} = A^T$$ $$\\frac{dXA}{dX} = A^T$$ $$\\frac{dAX}{dX^T} = A$$ (三): 正规方程矩阵推导过程此时X,w,y都是矩阵 1: 公式化简1: 最小二乘法: $$f(w) = ||Xw-y||_2^2$$ 2: 向量2范数: $$||X||2 = \\sqrt{\\sum\\limits{i = 1}^nx_i^2}$$ 3: 将向量2范数的公式带入到最小二乘法中得: $$f(w)=(\\sqrt{(Xw-y)^2})^2$$ 4. 化简: $$f(w)=(Xw-y)^2$$ 由于X, w, y都是矩阵, 运算后还是矩阵; 矩阵得乘法是一个矩阵得行和另一个矩阵得列相乘; 所以矩阵的平方就是该矩阵乘以他本身的转置矩阵 5. 所以: $$f(w)=(Xw-y)^T(Xw-y)$$ 6. 展开: 注意: 整体转置变成每个元素都转置时,若是有乘法, 则相乘的两个矩阵要交换位置; 如下所示!!! $$f(w)=(w^TX^T-y^T)(Xw-y)$$ $$f(w)=w^TX^TXw-w^TX^Ty-y^TXw+y^Ty$$ 注意: 若想交换两个相乘的矩阵再算式中的位置,则交换之后双方都需要转置一次; 如下所示!!! $$f(w)=w^TX^TXw-(X^Ty)^T(w^T)^T-y^TXw+y^Ty$$ $$f(w)=w^TX^TXw-y^TXw-y^TXw+y^Ty$$ $$f(w) = w^TX^TXw - 2y^TXw + y^Ty $$ 2: 求导$$f(w) = w^TX^TXw - 2y^TXw + y^Ty $$ 这里 $y^Ty$ 是常数求导后为0 $2y^TXw$ 求导: $$\\frac{d(2y^TX)w}{dw}=(2y^TX)^T=2X^T(y^T)^T=2X^Ty$$ $w^TX^TXw$求导: $$\\frac{dw^TX^TXw}{dw}=\\frac{d(w^TX^TX)w}{dw}+\\frac{dw^T(X^TXw)}{dw}=(w^TX^TX)^T+X^TXw=X^T(X^T)^T(w^T)^T+X^TXw=2X^TXw$$ 所以: $$f’(w) = 2X^TXw - 2X^Ty$$ 令$f’(w)=0$,则: $$2X^TXw - 2X^Ty = 0$$ $$X^TXw=X^Ty$$ 矩阵运算没有除法,可以用逆矩阵实现除法的效果 等式两边同时乘以$X^TX$的逆矩阵$(X^TX)^{-1}$ $$(X^TX)^{-1}(X^TX)w=(X^TX)^{-1}X^Ty$$ $$Iw=(X^TX)^{-1}X^Ty$$ I是单位矩阵 得到正规方程: $$w=(X^TX)^{-1}X^Ty$$ (四): 数据挖掘实例(预测2020年淘宝双十一交易额)1234567import numpy as npimport matplotlib.pyplot as pltfrom sklearn.linear_model import LinearRegressionX = np.arange(2009, 2020) # 年份X = X -2008 # 年份数值太大,差别不明显y = np.array([0.5, 9.36, 52, 191, 350, 571, 912, 1207, 1682, 2135, 2684]) # 09年到19年的交易额 假设X和y之间是一元三次的关系(按照前几年的数据走势提出的假设) $$f(x)=w_1x+w_2x^2+w_3x^3+b$$ $$f(x)=w_0x^0+w_1x^1+w_2x^2+w_3x^3$$ 12345678910111213141516171819202122232425# X_oo = np.concatenate([a,a]) # 横着级联X_train = np.c_[X**0, X**1, X**2, X**3] # 竖着级联'''array([[ 1, 1, 1, 1], [ 1, 2, 4, 8], [ 1, 3, 9, 27], [ 1, 4, 16, 64], [ 1, 5, 25, 125], [ 1, 6, 36, 216], [ 1, 7, 49, 343], [ 1, 8, 64, 512], [ 1, 9, 81, 729], [ 1, 10, 100, 1000], [ 1, 11, 121, 1331]], dtype=int32)'''linear = LinearRegression(fit_intercept=False) # 声明算法; fit_intercept=False将截距设置为0, w0就是截距linear.fit(X_train, y) # 训练w_ = linear.coef_print(linear.coef_.round(2)) # 获取系数print(linear.intercept_) # 获取截距'''[ 58.77 -84.06 27.95 0.13]0.0''' 可以得到方程: $$f(x)=58.77-84.06x+27.95x^2+0.13x^3$$ 1234567891011X_test = np.linspace(0,12,126) # 线性分割(将0,12之间分成126分)等差数列包含1和12X_test = np.c_[X_test**0, X_test**1, X_test**2, X_test**3] # 和训练数据保持一致y_ = linear.predict(X_test) # 使用模型预测plt.plot(np.linspace(0,12,126), y_, color='g') # 绘制预测方程曲线plt.scatter(np.arange(1,12), y, color='red') # 绘制每年的真实销量# 定义函数fun = lambda x : w_[0] + w_[1]*x + w_[2]*x**2 + w_[-1]*x**3fun(12)'''3294.2775757576132''' 三: 梯度下降​ 梯度下降法的基本思想可以类比为一个下山的过程。假设这样一个场景：一个人被困在山上，需要从山上下 来(i.e. 找到山的最低点，也就是山谷)。但此时山上的浓雾很大，导致可视度很低。因此，下山的路径就无法确 定，他必须利用自己周围的信息去找到下山的路径。这个时候，他就可以利用梯度下降算法来帮助自己下山。具体 来说就是，以他当前的所处的位置为基准，寻找这个位置最陡峭的地方，然后朝着山的高度下降的地方走，同理， 如果我们的目标是上山，也就是爬到山顶，那么此时应该是朝着最陡峭的方向往上走。然后每走一段距离，都反复 采用同一个方法，最后就能成功的抵达山谷。 (一): 梯度下降123456789101112131415161718192021222324import numpy as npimport matplotlib.pyplot as pltf = lambda w : (w -3.5)**2 -4.5*w +10d = lambda w : 2*(w-3.5)-4.5 # 梯度 == 导数step = 0.1 # 梯度下降的步幅,比率,学习率(默认是1)# 求当w(x值)为多少时,得到的函数值最小w = np.random.randint(0,11,size=1)[0] # 随机生成一个初始值数last_w = w + 0.1 # 梯度下降,每走一步,目标值,都会更新precision = 1e-4 # 精确率(误差率,越小越精确,并不是越小越好)print('==============更新前的w:', w)w_ = [w]while True: if np.abs(w - last_w) &lt; precision: # 退出条件 break last_w = w # 更新 w -= step*d(w) # 随机初始值在目标值的左边时, d(w)为负, w = w-step*d(w) 会使得w慢慢变大趋近目标值 # 随机初始值在目标值的右边时, d(w)为正, w = w-step*d(w) 会使得w慢慢变小趋近目标值 w_.append(w) print('==============更新后的w:', w) (二): 梯度下降实现线性回归1. 构造数据1234567891011import numpy as npimport matplotlib.pyplot as pltfrom sklearn.linear_model import LinearRegressionX = np.linspace(-2, 12, 40).reshape(40,1) # reshape(40,1)改变形状; 40这个位置可以写成-1, 此时-1代表40; 当后面的1变为2时,此时-1代表20; 也就是说当后面的数值变化时,系统自动用前面规定的总数计算出相应的结果,而这些结果都可以用-1代替; w = np.random.randint(1,9,size = 1) # 系数b = np.random.randint(-5,5,size = 1) # 截距y = w*X + b + np.random.randn(40,1) * 2 # 增加噪声plt.scatter(X, y) # 绘点 2. 使用sklearn中的回归 - 梯度下降方法计算斜率和截距123456789101112linear = LinearRegression() # 定义算法linear.fit(X, y) # 训练X_test = np.linspace(-2,12,256).reshape(-1, 1) # 预测数据y_ = linear.predict(X_test) # 预测结果print('真实斜率和截距', w, b)print('算法计算的斜率和截距', linear.coef_, linear.intercept_) # 截距和斜率'''真实斜率和截距 [5] [3]算法计算的斜率和截距 [[4.91521288]] [3.06426015]'''plt.plot(X_test, y_, color='g') # 绘制线性回归方程plt.scatter(X, y, color='r') # 绘制实际的点 3.自定义梯度下降的类实现sklearn中的回归 - 梯度功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class LinearModel(object): def __init__(self): # 初始化, 随机给定截距和斜率 self.w = np.random.randn(1)[0] self.b = np.random.randn(1)[0] def model(self, x): return self.w*x + self.b # 一元一次线性方程; 模型 def loss(self,x,y):#损失，最小二乘法 cost = (self.model(x) - y)**2 # 损失函数越小越好 # 求解梯度，两个未知数，所以，偏导 d_w = 2*(self.model(x) - y)*x # 斜率w的偏导 d_b = 2*(self.model(x) - y)*1 # 截距b的偏导 return cost,d_w,d_b def gradient_descent(self, step, d_w, d_b): # 梯度下降 self.w -= step*d_w # 更新斜率 self.b -= step*d_b # 更新截距 def fit(self, X, y): # 训练模型, 将数据给模型,寻找规律 precision = 1e-4 # 精确度 last_w = self.w + 0.01 last_b = self.b + 0.01 print('------------------------初始的截距和斜率:', self.w, self.b) while True: if (np.abs(self.w-last_w) &lt; precision) &amp; (np.abs(self.b-last_b) &lt; precision): break last_w = self.w # 更新之前,先保留记录 last_b = self.b cost_ = 0 dw_ = 0 db_ = 0 for i in range(40): # 计算40个，返回40个偏导数，求平均值 cost,dw,db = self.loss(X[i,0],y[i,0]) cost_ += cost/40 dw_ += dw/40 db_ += db/40 self.gradient_descent(0.01, dw_, db_) print('------------------------更新后的截距和斜率:', self.w, self.b) def predict(self, X): return self.model(X) model = LinearModel() # 定义算法w, b = model.fit(X, y) # 获取斜率和截距y_ = model.predict(X_test) # 用测试数据获取目标值plt.plot(X_test, y_, color='g') # 绘制线性方程plt.scatter(X, y, color='r') # 绘制目标点 (三): 梯度下降(矩阵)12345678910111213141516171819202122232425262728293031323334import numpy as npimport matplotlib.pyplot as plt# 构造数据X = np.linspace(-2, 12, 40).reshape(-1, 1)w = np.random.randint(2, 12, size=1)b = np.random.randint(-10, 10, size=1)y = X*w + b + np.random.randn(40, 1)*2.5plt.scatter(X, y, color='r')X = np.concatenate([X, np.ones(shape=(40, 1))], axis=1) # 将截距b看作一个斜率w, 在下面定义的类中要求输入两组X值, 所以此处将X的数据结构变为(40,2)# 定义梯度下降类def gradient_descent(X,y): theta = np.random.randn(2,1) # theta中既有斜率，又有截距 last_theta = theta + 0.1 precision = 1e-4 epsilon = 0.01 while True: # 当斜率和截距误差小于万分之一时，退出 if (np.abs(theta - last_theta) &lt; precision).all(): break # 更新 last_theta = theta.copy() theta = theta - epsilon*2/40*X.T.dot(X.dot(theta) - y) return theta# 调用w_,b_ = gradient_descent(X,y)j = lambda x : w_*x + b_plt.scatter(X[:,0],y,color = 'red')x_test = np.linspace(-2,12,1024) y_ = j(x_test)plt.plot(x_test,y_,color = 'green') (四): 随机梯度下降(矩阵) - 从所有样本中随机获取指定数量的样本1234567891011121314151617181920212223242526272829303132333435363738394041import numpy as npimport matplotlib.pyplot as plt# 构造数据X = np.linspace(-2,12,40).reshape(-1,1)w = np.random.randint(2,12,size = 1)b = np.random.randint(-10,10,size = 1)y = X*w + b + np.random.randn(40,1)*2.5# 将y.reshape(-1)一维的y = y.reshape(-1)plt.scatter(X,y,color = 'red')# 定义梯度下降类def gradient_descent(X,y): m = 10 # 随机样本数量 theta = np.random.randn(2) # theta中既有斜率，又有截距 last_theta = theta + 0.1 #记录theta更新后，和上一步的误差 precision = 1e-4 #精确度 epsilon = 0.01 #步幅 count= 0 while True: # 当斜率和截距误差小于万分之一时，退出 if (np.abs(theta - last_theta) &lt; precision).all(): break if count &gt; 3000:#死循环执行了3000次 break # 更新 last_theta = theta.copy() # 随机梯度下降，梯度是矩阵计算返回的 index = np.random.choice(np.arange(40),size = m)# index索引，根据随机索引从原数据中取数据 grad = 2/m*X[index].T.dot(X[index].dot(theta) - y[index]) theta -= epsilon*grad count += 1 return thetaw_,b_ = gradient_descent(X_train,y)j = lambda x : w_*x + b_plt.scatter(X[:,0],y,color = 'red')x_test = np.linspace(-2,12,1024) y_ = j(x_test)plt.plot(x_test,y_,color = 'green') 若随机样本的数量为1, 则是完全随机梯度下降 四: 岭回归(一): 岭回归和线性回归的模型对比12345678910111213141516171819202122232425262728293031323334353637import numpy as npfrom sklearn.linear_model import LinearRegression, Ridgefrom sklearn import datasetsX, y = datasets.load_boston(True)# 线性回归linear = LinearRegression()linear.fit(X, y)w_ = linear.coef_b_ = linear.intercept_print('普通线性回归斜率:\\n', w_)print('普通线性回归截距:', b_)'''普通线性回归斜率: [-1.08011358e-01 4.64204584e-02 2.05586264e-02 2.68673382e+00 -1.77666112e+01 3.80986521e+00 6.92224640e-04 -1.47556685e+00 3.06049479e-01 -1.23345939e-02 -9.52747232e-01 9.31168327e-03 -5.24758378e-01]普通线性回归截距: 36.45948838509001'''# 岭回归ridge = Ridge(alpha=10)ridge.fit(X, y)w_ = ridge.coef_b_ = ridge.intercept_print('岭回归斜率:\\n', w_)print('岭回归截距:', b_)'''岭回归斜率: [-0.10143535 0.0495791 -0.0429624 1.95202082 -2.37161896 3.70227207 -0.01070735 -1.24880821 0.2795956 -0.01399313 -0.79794498 0.01003684 -0.55936642]岭回归截距: 27.467884964141252'''","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"https://anjhon1994.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"sklearn","slug":"sklearn","permalink":"https://anjhon1994.github.io/tags/sklearn/"},{"name":"线性回归","slug":"线性回归","permalink":"https://anjhon1994.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"}]},{"title":"Python基础：20:多线程基础","slug":"Python基础/第一章 1.20 多线程基础","date":"2018-08-09T16:00:00.000Z","updated":"2021-01-08T14:31:18.812Z","comments":true,"path":"2018/08/10/Python基础/第一章 1.20 多线程基础/","link":"","permalink":"https://anjhon1994.github.io/2018/08/10/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.20%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/","excerpt":"","text":"一个应用程序在运行时就是一个进程,一个进程默认只有一个主线程,也可以有多个进程,同时执行不同的任务;本次课程主要是实现如何让进程可以进行多线程工作 一个进程就像一个工厂,多个进程就像工厂例的工人,每个工人之间的工作相互之间不影响 让一个进程多线程工作有两种实现方式:①.直接导入treading模块种的Tread类并创建子线程对象②.导入treading模块种的Tread类,创建一个Tread的子类,并用这个子类创建子线程对象 一. 在进程种创建Tread类的对象1. 创建线程对象 - 子线程线程对象 = Thread(target=函数, args=元组)说明:target - 函数，需要在子线程中执行的任务(会在子线程中调用)args - target对应的函数在调用的时候传的参数 2. 让子线程执行子线程中的任务线程对象.start()在子线程中调用target对用的函数，并且将args中的元素作为参数 比如在一个进程中模拟下载电影: 123456789101112131415161718from treading import Treadfrom datetime import datetimeimport timedef download(self, movie_name) print('%s开始下载了,开始时间是%s' % (movie_name, datetime.time())) time.sleep(5) print('%s下载完成了,完成时间是%s' % (movie_name, datetime.time())) # 创建线程对象 - 子线程t1 = Tread(target=download, args=('暮光之城'))t2 = Tread(target=download, args=('两只老虎'))t3 = Tread(target=download, args=('卧虎藏龙'))# 让子线程执行子线程中的任务t1.start()t2.start()t3.start() 二. 在进程种创建Tread类的子类的对象还是下载电影的例子: 1234567891011121314151617181920212223from treading import Treadfrom datetime import datetimeimport timeclass DownloadTread(Tread): # 创建Tread的子类 def __init__(self, mvoie_name) # 创建子类的对象属性 super().__init__() # 继承父类的属性 self.movie_name = movie_name # run方法是在子线程中自动调用的,除了self之外不能有其他的参数 def run(self) -&gt; None: print('%s开始下载,开始时间是:%s' % (self.movie_name, datetime.now())) time.sleep(5) print('%s下载结束,结束时间是:%s' % (self.movie_name, datetime.now())) t1 = DownloadTead('暮光之城')t2 = DownloadTead('两只老虎')t3 = DownloadTead('卧虎藏龙')t1.startt3.startt2.start join的用法线程对象.join()其他代码 这儿的其他代码会在线程对象中的任务执行完后才执行","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]},{"title":"Python基础：19:网络编程基础","slug":"Python基础/第一章 1.19 网络编程基础","date":"2018-08-07T16:00:00.000Z","updated":"2021-01-08T14:30:31.971Z","comments":true,"path":"2018/08/08/Python基础/第一章 1.19 网络编程基础/","link":"","permalink":"https://anjhon1994.github.io/2018/08/08/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.19%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/","excerpt":"","text":"一. socket编程 socket又叫套接字 socket编程其实就是用代码来实现进行网络通信的两个端；套接字就是实现通信的两个程序 实现通信的两个端分为 服务器 和 客户端 两种 python通过 socket模块 来提供socket编程相关的类和方法 二. 服务器端(注:以下操作中服务器端和客户端分两个py文件实现) 1. 创建套接字对象(买电话机)1234socket(family=AF_INET, type=SOCK_STREAM)# family - 设置ip类型; AF_INET对应的是ipv4; AF_INET6对应的是ipv6# type - 设置传输类型; SOCK_STREAM对应的是TCP协议; SOCK_DGRAM对应的是UDP协议 2. 绑定IP和端口(插电话线)12345bind((ip地址, 端口))# ip地址: 找到互联网中唯一的一台计算机; 赋值ip地址对应的字符串# 端口: 区分同一台计算机中不同的服务(程序); 赋整数,值的范围是0~65535, 其中0~1024属于著名，不能随便用。# 同一时间同一个端口只能对应一个服务 3. 开始监听(等电话)123server.listen(N)# N : 表示能同时接通的\"电话\"的数量 4. 接受客户端请求(接电话)123456connection, address = server.accept()# connection : 服务器接收的客户端的分机对象# address : 该客户端的IP地址# 返回为这个客户端创建的独立的套接字对象(分机)和客户端的地址# 当程序运行到这句代码的时候会停下来，直到有请求为止 5. 接收消息(听对方说话)123#分机对象 . recv(一次性能够接收的数据的大小)#返回接收到的数据, 数据类型是二进制 6. 发送消息(说话给别人听)1# 分机对象.send(需要发送的数据) 7. 关闭连接(挂电话)1# 分机对象.close() 一个完整的服务器端 12345678910111213from socket import socketserver = socket()server.bind(('192.168.10.234', 5200)) # ip地址可以用自己电脑的IP, 端口随便,只要不是0-1024server.listen(50) # 表示这个服务器可以同时和50个客户端进行通信while True: # 保证通话一直进行 print('正在监听...') connection, address = server.accept() # 接受客户端请求,并创建分机对象connection, 返回分机地址address recv_data = connection.recv(1024).decode(encoding='utf-8') # 接收客户端发来的数据,并将二进制转换成字符串(.decode方法) print('recv_data') # 打印接收到的数据 massage = input('请输入发送内容:') # 输入要发送的内容 connection.send(massage) # 发送数据 connection.close() # 关闭对话 三. 客户端1. 创建套接字对象(买电话)client = socket() 2. 连接服务器client.connect((‘192.168.10.234’, 5200)) 3. 发送消息client.send() 4. 接收消息client.recv() 5. 断开连接client.close() 一个完整的客户端 123456client = socket()client.connect(('192.168.10.234', 5200))client.send('服务器你好吗？'.encode())re_data = client.recv(1024)print(re_data.decode(encoding='utf-8'))client.close() 四. 其他骚操作1. 一对一持续通信12345678910111213141516171819202122232425262728293031323334353637383940414243\"\"\"服务器端\"\"\"from socket import socketserver = socket()server.bind(('10.7.156.55', 9999))server.listen(20)while True: print('正在监听...') connection, address = server.accept() # 持续通信 while True: re_data = connection.recv(1024) re_massage = re_data.decode(encoding='utf-8') print('client:', re_massage) if re_massage == '再见': connection.close() break massage = input('server:') connection.send(massage.encode()) if massage == '再见': connection.close() break\"\"\"客户端\"\"\"from socket import socketclient = socket()client.connect(('10.7.156.55', 9999))while True: massage = input('client:') # for _ in range(10): client.send(massage.encode()) if massage == '拜拜': client.close() break re_massage = client.recv(1024).decode(encoding='utf-8') print('server:', re_massage) if re_massage == '拜拜': client.close() break 2. 发送图片123456789101112131415161718192021222324252627282930\"\"\"服务器端\"\"\"from socket import socketserver = socket()server.bind(('10.7.156.55', 8000))server.listen(1024)while True: connection, address = server.accept() with open('../code/1024x1024.jpg', 'rb') as f: data = f.read() connection.send(data)\"\"\"客户端\"\"\"from socket import socketclient = socket()client.connect(('10.7.156.55', 8000))# 接收图片长度total_length = int(client.recv(1024).decode())print('第一次:', total_length)sum_data = bytes() # 保存接收到的图片的总数据# 接收图片while True: re_data = client.recv(1024) sum_data += re_data if len(sum_data) == total_length: with open('client/test1.wav', 'wb') as f: f.write(sum_data) break 完结撒花","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]},{"title":"Python基础：18:re模块","slug":"Python基础/第一章 1.18 re模块","date":"2018-08-02T16:00:00.000Z","updated":"2021-01-08T14:30:20.237Z","comments":true,"path":"2018/08/03/Python基础/第一章 1.18 re模块/","link":"","permalink":"https://anjhon1994.github.io/2018/08/03/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.18%20re%E6%A8%A1%E5%9D%97/","excerpt":"","text":"一：方法使用1. compile(正则表达式) - 编译创建正则表达式对象1234re_obj = re.compile(r'\\d&#123;3&#125;')re_obj.fullmatch('234')re.fullmatch(r'\\d&#123;3&#125;', '345') a.获取匹配结果:匹配对象.group() - 获取整个正则表达式匹配到的结果匹配对象.group(N) - 获取第N分组匹配到的结果 b.获取匹配结果在原字符串中的范围匹配对象.span() c.获取原字符串匹配对象.string 12345678print(result.group()) # 234hksjprint(result.group(1)) # 234print(result.group(2)) # hksjprint(result.span()) # (0, 7)print(result.span(2)) # (3, 7)print(result.string) # 234hksj 2. fullmatch(正则表达式, 字符串) - 让正则表达式和整个字符串进行匹配；如果匹配成功返回匹配对象，匹配失败返回None12result = re.fullmatch(r'(\\d&#123;3&#125;)([a-z]&#123;4&#125;)', '234hksj')print(result) 3.match(正则表达式, 字符串) - 让字符串开头和正则表达式进行匹配; 返回值是匹配对象或者None12print(re.match(r'\\d&#123;3&#125;', '789佳的说法0023-==='))print(re.match(r'\\d&#123;3&#125;abc', '345ABC就开始大锅饭', flags=re.I)) 4.search(正则表达式, 字符串) - 在字符串中查找第一个满足正则表达式的子串；返回值是匹配对象或者None1print(re.search(r'\\d&#123;3&#125;', '时代峰峻34890shh==23992课时费')) 5.findall(正则表达式,字符串) - 获取字符串中所有满足正则表达式的子串；返回值是列表，列表中的元素是字符串1print(re.findall(r'\\d+', '安抚348净宽度34920skdsf45烧开后09823hsd3sd89')) 6.finditer(正则表达式,字符串) - 获取字符串中所有满足正则表达式的子串; 返回值是迭代器，迭代器中的元素是匹配对象12result = re.finditer(r'(\\d+)([a-z]&#123;2&#125;)', '安抚348净宽度34920skdsf45烧开后09823hsd3sd89')print(list(result)) 7.split(正则表达式,字符串) - 以正则表达式匹配到的子串作为切割点，对字符串进行切割; 返回值是列表，列表中的元素是字符串12result = re.split(r'\\d+', '暗红色的83大黄金黄色的9罚款0233s闪电发货890')print(result) # ['暗红色的', '大黄金黄色的', '罚款', 's闪电发货', ''] 8.sub(正则表达式,字符串1,字符串2) - 将字符串2中满足正则表达式的子串全部替换成字符串1；返回值是替换后的字符串12result = re.sub(r'\\d+', 'and', '暗红色的83大黄金黄色的9罚款0233s闪电发货890')print(result) 9.参数flags以上所有的函数都有一个参数flags, 可以加re.I表示匹配的时候忽略大小写；加re.S表示单行匹配(默认是多行匹配re.M)多行和单行的主要区别: 多行匹配.不能和\\n进行匹配；单行.可以和\\n进行匹配 12345print(re.fullmatch(r'a.b', 'a\\nb')) # Noneprint(re.fullmatch(r'a.b', 'a\\nb', flags=re.S))print(re.search(r'a.+b', '世纪东方anmb\\n是否b大括号'))print(re.search(r'a.+b', '世纪东方anmb\\n是否b大括号', re.S)) 附上整理的表格","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]},{"title":"Python基础：17:内存管理, 拷贝,正则表达式","slug":"Python基础/第一章 1.17 内存管理, 拷贝,正则表达式","date":"2018-07-24T16:00:00.000Z","updated":"2021-01-08T14:30:07.644Z","comments":true,"path":"2018/07/25/Python基础/第一章 1.17 内存管理, 拷贝,正则表达式/","link":"","permalink":"https://anjhon1994.github.io/2018/07/25/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.17%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86,%20%E6%8B%B7%E8%B4%9D,%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"一. 内存管理1. C语言中内存管理的概念 内存分为堆区间和栈区间 C的栈区间的内存是系统自动申请和释放(自动管理) C的堆区间的内存需要调用malloc函数申请,调用free函数释放 其他高级语言中的垃圾管理机制是针对堆区间的内存进行管理的 2. python的内存管理机制1) 内存的申请python中所有的数据都是存在堆中的，变量是保存在栈区间的，变量中保存的是保存在堆中的数据的地址。 重新给变量赋值，会先在内存开辟新的内存保存新的数据，然后将新的数据的地址重新保存到变量但是如果使用数字或者字符串给变量赋值,不会直接开辟新的内存，而是先检查内存有没有这个数据，如果有直接将原来的数据的地址给变量 2)内存的释放(垃圾回收机制)在python中一个数据对应的内存空间是否释放，就看这个数据的引用计数是否为0；如果引用计数为0，数据对应的内存就会被自动释放循环引用问题: python的垃圾回收机制会自动处理循环引用问题 增加引用计数: 增加数据的引用(让更多的变量来保存数据的地址)减少引用计数: 删除引用，或者让引用去保存新的数据 3)查看引用次数导入sys模块中的getrefcountprint(getrefcount(list2))getrefcount函数在调用时会给形参赋值,所以打印的值会比我们需要的值多1 3.循环引用 堆中的数据相互间的引用,数据计数不为零,不被释放 python的垃圾回收机制会自动解决循环引用的问题 二. 拷贝(需要导入copy模块)1. 直接赋值一个变量给另外一个变量赋值时,两个变量的数据是同一个值 2.浅拷贝拷贝之后产生新的相同的数据,新的地址.但是若数据内有引用其他的数据,则其他数据的地址还是原来的地址,(相当于一个人的类,有一个狗的属性,浅拷贝之后,多个人对象拥有同一条狗(拷贝之后狗对象的地址不变,只是多了几次引用)) 3.深拷贝(多个人都拥有各自的狗) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from copy import copy, deepcopyclass Dog: def __init__(self, name, color='黄色'): self.name = name self.color = color def __repr__(self): return '&lt;%s __id: %s&gt;' % (str(self.__dict__)[1:-1], id(self))class Person: def __init__(self, name, age=10, gender='男', dog=None): self.name = name self.age = age self.gender = gender self.dog = dog def __repr__(self): return '&lt;%s __id: %s&gt;' % (str(self.__dict__)[1:-1], id(self))# 直接赋值print('直接赋值')p1 = Person('小明', dog=Dog('大黄'))p2 = p1 # 赋值后p1和p2指向是同一个Person对象print('p1:', p1)print('p2:', p2)p1.gender = '女'p1.dog.color = '白色'print('p1:', p1)print('p2:', p2)print('=============浅拷贝==============')p1 = Person('小明', dog=Dog('大黄'))p2 = copy(p1)print(p1)print(p2)p1.gender = '女'p1.dog.color = '白色'print('p1:', p1)print('p2:', p2)print('=============深拷贝===========')p1 = Person('小花', dog=Dog('大黄'))p2 = deepcopy(p1)print('p1:', p1)print('p2:', p2)p1.gender = '女'p1.dog.color = '白色'print('p1:', p1)print('p2:', p2) 魔法方法(__repr__):自定义打印结果的显示 def repr(self): return ‘&lt;%s id: %s&gt;’ % (str(self.dict__)[1:-1], id(self)) 三. 正则表达式1.正则表达式用正则符号来描述字符串规则让字符串匹配更简单(计算机语言基本支持正则,python通过re模块支持正则) 2. 正则符号1) 匹配符号1).普通字符:在正则中没有特殊功能和意义的字符 2).特殊字符:①:点(.) - 代表任意字符 1print(re.fullmatch(r'a..b', 'au9b')) ②:(\\w) - ASCII码表中只能匹配字母、数字或者下划线；ASCII码表以外的都可以匹配 1print(re.fullmatch(r'a\\wb', 'a8b')) ③:(\\d) - 匹配任意一个数字字符 1print(re.fullmatch(r'a\\d\\db', 'a33b')) ④:(\\s) - 匹配任意一个空白字符(空格,缩进,换行…) 12print(re.fullmatch(r'a\\sb', 'a\\tb'))print(re.fullmatch(r'a\\sb', 'a\\nb')) ⑤:(\\W \\D \\S) -&gt; 功能和小写的相反 \\W - 匹配ASCII码表任意非字母数字下划线 \\D - 匹配任意非数字字符 \\S - 匹配任意非空白字符 1print(re.fullmatch(r'a\\Db\\Sc\\Wd', 'aZb=c+d')) ⑥:[字符集] - 匹配字符集中的任意一个字符(一个中括号只能匹配一个字符集)注意:前一个字符的编码值一定要比后一个字符的编码值要大当字符集中有减号时,减号不能放中间 &emsp;[1-9] - 匹配123456789中的任意一个字符 &emsp;[0-9] - \\d &emsp;[a-z] - 匹配任意一个小写字母 &emsp;[A-Z] - 匹配任意一个大写字母 &emsp;[a-zA-Z] - 匹配任意一个字母 &emsp;[\\u4e00-\\u9fa5] - 匹配任意一个中文字符 &emsp;[1-9abc] - 匹配1~9或者abc中的任意一个字符 &emsp;[a-zA-Z0-9_] - 匹配字母数字下划线 &emsp;[\\dxyz] - 任意数字或者x、y、z 123456789print(re.fullmatch(r'a[xyz89?]b', 'azb'))print(re.fullmatch(r'a[xyz]b', 'anb'))print(re.fullmatch(r'a[23456789]b', r'a7b'))print(re.fullmatch(r'a[1-9abc]b', 'aab'))print(re.fullmatch(r'a[abc1-9]b', 'aab'))print(re.fullmatch(r'a[ac1-9b]b', 'aab'))print(re.fullmatch(r'a[+*-]b', 'a-b'))print(re.fullmatch(r'a[\\dxyz]b', 'axb'))print(re.fullmatch(r'a[\\\\dxyz]b', 'a\\\\b')) ⑦:[^字符集] - 匹配除了字符集以外的其他任意字符注意:符号^只能放在最前面! 1print(re.fullmatch(r'a[xyz^]b', 'a^b')) 2 检测符号①: \\b - 检测是否是单词结尾单词结尾-所有可以区分出两个不同单词的符号都是单词结尾，其中字符串开头和字符串结尾用法：检测\\b所在的位置是否是单词结尾；不影响匹配的时候的字符串长度 12re_str = r'a\\db\\b'print(re.fullmatch(re_str, 'a7b')) ②:^ - 检测是否是字符开头 123re_str = r'^\\d\\d\\d'print(re.fullmatch(re_str, '123'))print(re.search(re_str, 'k898ahs237khhj')) ③:$ - 检测是否是字符结尾 12re_str = r'\\d\\d\\d$'print(re.search(re_str, '123k898ahs237khhj990')) 3 匹配次数①:? - 匹配0次或1次 例: x? - x出现0次或1次 \\d? - 数字出现0次或1次 ②:* - 任意次数,0次也可以 ③:+ - 1次或多次 123print(re.fullmatch(r'ax?b', 'axb'))print(re.fullmatch(r'a\\d*b', 'a12b'))print(re.fullmatch(r'a\\d+b', 'a1272937928329b')) ④:{}a: {N} - 匹配N次b: {M,N} - 匹配M到N次b: {M,} - 至少匹配M次b: {,N} - 最多匹配N次 1234re_str = r'a\\d&#123;3,5&#125;b'print(re.fullmatch(re_str, 'a78988b'))print(re.fullmatch(re_str, 'a7898b'))print(re.fullmatch(re_str, 'a789880b')) # None 练习123# 练习: 写一个正则表达式判断输入的内容是否是整数# 123 -&gt; 成功! 123a -&gt; 失败! -123 -&gt; 成功! --123 -&gt; 失败! +123 -&gt; 成功re_str = r'[+-]?[1-9]\\d*' 贪婪和非贪婪 匹配次数不确定的时候有贪婪和非贪婪状态? * + {M,} {M,N} {,N} 默认贪婪在能匹配成功的前提下，尽可能多的匹配?? *? +? {M,}? {M,N}? {,N}? 非贪婪在能匹配成功的前提下，尽可能少的匹配 3. 分支和分组1).分支正则1 | 正则2 - 先让正则1匹配,再让正则2匹配;只要有一个匹配就能成功 123# 匹配一个字符串: abc前是3个数字或者3个字母# 123abc, uJhabcre_str = r'\\d&#123;3&#125;abc|[a-zA-Z]&#123;3&#125;abc' 2).分组①:整体控制次数: ()匹配次数②:将正则表达式作为一个整体操作 重复：带分组的正则表达式\\M - 在\\M的位置重前面第M个分组匹配到的内容 12345# 匹配一个字符串: abc前是3个数字或者3个字母re_str = r'(\\d&#123;3&#125;|[a-z]&#123;3&#125;)abc'print(re.fullmatch(re_str, 'mskabc'))re_str = r'(\\d+)([a-z]+)=\\2'print(re.fullmatch(re_str, '6kh=kh'))","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]},{"title":"Python基础：16:类和对象(进阶)","slug":"Python基础/第一章 1.16 类和对象(进阶)","date":"2018-07-19T16:00:00.000Z","updated":"2021-01-08T14:29:54.234Z","comments":true,"path":"2018/07/20/Python基础/第一章 1.16 类和对象(进阶)/","link":"","permalink":"https://anjhon1994.github.io/2018/07/20/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.16%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1(%E8%BF%9B%E9%98%B6)/","excerpt":"","text":"一. 类的继承继承是让子类直接拥有父类的属性和方法 1. 用法 class 类名(父类1,父类2,…)&emsp;&emsp;类的内容 12345678910111213141516171819202122class Person: num = 70 def __init__(self): self.name = '小明' self.age = 18 @staticmethod def func1(): print('静态方法')class Student(Person): pass# 子类直接使用父类的属性和方法stu1 = Student.numprint(stu1)stu2 = Student()print(stu2.name, stu2.age) 2. 子类中添加属性和方法1). 添加方法和字段在子类中直接声明新的字段和方法,若字段和方法与父类的重名,则父类的会被覆盖(重写) 2). 添加对象属性用__initial__方法添加新的属性,并且通过 super().__init__ 方法继承父类的对象属性 可以在类的任何一个对象方法或者类方法中去通过super()调用父类的的对象方法或者类方法 super(类1,类1的对象).方法() -&gt; 调用类1的父类中的方法super().方法() &lt;==&gt; super(当前类,当前类的对象) super(type, obj) -&gt; 要求obj必须是type的对象或者是type的子类对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Animal: num = 100 def __init__(self): self.age = 10 self.gender = '雌' def func1(self): print('动物类中的对象方法') @classmethod def func2(cls): print('动物类中的类方法') @staticmethod def func3(): print('动物类中的静态方法')class Cat(Animal): voice = '喵~' def __init__(self): super().__init__() # 调用当前类的父类的__init__方法 self.color = '白' self.breed = '加菲猫' def func4(self): super().func1() # 用super实现 子类Cat中的函数(方法)内调用父类Animal的方法 print('猫类中的对象方法') @classmethod def func5(cls): super().func2() # 用super实现 子类Cat中的函数(方法)内调用父类Animal的方法 print('猫类中的类方法') @staticmethod def func6(): print('猫类中的静态方法')# 子类Cat继承父类Animal的属性和方法# (父类的类方法和静态方法只能用子类的类调用,对象方法只能用对象调用)cat1 = Cat()print(cat1.color, cat1.breed, cat1.age, cat1.gender)cat1.func1()Cat.func2()Cat.func3()# 用super实现 子类Cat中的函数(方法)内调用父类Animal的方法cat1.func4()Cat.func5()Cat.func6() 以上代码的执行结果:白 加菲猫 10 雌动物类中的对象方法动物类中的类方法动物类中的静态方法动物类中的对象方法猫类中的对象方法动物类中的类方法猫类中的类方法猫类中的静态方法 3. 多继承 子类在继承多个父类时,对象属性只能继承第一个父类的对象属性 1234567891011121314151617181920212223242526272829303132333435363738class Animal: num = 100 def __init__(self, age=0, gender='雄'): self.age = age self.gender = gender def a_func1(self): print('动物的对象方法') def massage(self): print('this is Animal')class Fly: flag = '飞行' def __init__(self, height=1000, time=3): self.height = height self.time = time @classmethod def f_func1(cls): print('飞行的类方法')class Bird(Animal, Fly): passb1 = Bird()print(Bird.num, Bird.flag)b1.a_func1()Bird.f_func1()print(b1.age, b1.gender)print(b1.height, b1.time) # 第二个父类的属性不能继承,本行代码会报错 4. 多继承的执行顺序例: 123456789101112131415161718192021222324class A: def massage(self): print('this is A')class B(A): def massage(self): super().massage() print('this is B')class C(A): def massage(self): super().massage() print('this is C')class D(B, C): def massage(self): super().massage() print('this is D')D().massage() 代码执行结果:this is Athis is Cthis is Bthis is D 说明:我也说不清,别喷我😭 二. 私有化1. 访问权限公开的(public):类的里面,外面都能用,也可以被继承保护的(protect):类的里面可以用,也可以被继承私有的(private):类的里面可以用,不能被继承 2. python中的权限python类中的内容只有公开的,私有化是假的私有化 3.python私有化在方法名前或属性名前加两个下划线__只是在 __方法名 前加了下划线类名(_类名),在外部加_类名可以调用 1234567891011121314151617181920212223242526272829class Person: num = 61 __num2 = 100 def __init__(self, name, age=18): self.name = name self.age = age self.gender = '男' self.__gender = '男' def func1(self): print('%s今年%d岁' % (self.name, self.age), self.__gender) self.__func11() def __func11(self): print('私有的对象方法') @staticmethod def func2(): print('我是静态方法1') @staticmethod def __func22(): print('我是静态方法1') @classmethod def func3(cls): print(cls.num) print(cls.__num2) 3. getter和setter1. 什么时候用如果希望在对象属性赋值前做点儿别的什么事情就给这个属性添加setter如果希望在获取属性值之前做点儿别的什么事情就给这个属性添加getter 2. 怎么用getter：a. 将需要添加getter的属性名前加 _b. 声明函数：声明前加@property； 函数名不带_的属性名； 函数需要一个返回值，返回值就是获取这个属性能够得到的值c.在外面使用属性的时候不带下划线 setter:注意: 如果想要给属性添加setter必须先添加gettera. 声明函数: 声明前加@getter名.setter; 函数名不带_的属性名； 函数不需要返回值，但是需要一个参数，这个参数就是给属性赋的值b.在外面给属性赋值的时候不带下划线 12345678910111213141516171819202122232425class Circle: pi = 3.1415926 def __init__(self, r): self.r = r self._area = 0 @property def area(self): return Circle.pi * self.r * self.r @area.setter def area(self, value): print('给area属性赋值:', value) raise ValueErrorc1 = Circle(1)print(c1.area) # 本质是在调用area函数: c1.area()c1.r = 10print(c1.area) # 本质是在调用area函数: c1.area()c1.r = 3print(c1.area) # 本质是在调用getter的area函数: c1.area()","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]},{"title":"Python基础：15:类和对象(基础)","slug":"Python基础/第一章 1.15 类和对象(基础)","date":"2018-07-14T16:00:00.000Z","updated":"2021-01-08T14:29:44.919Z","comments":true,"path":"2018/07/15/Python基础/第一章 1.15 类和对象(基础)/","link":"","permalink":"https://anjhon1994.github.io/2018/07/15/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.15%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1(%E5%9F%BA%E7%A1%80)/","excerpt":"","text":"一. 类和对象1. 先来两句废话 类就是拥有相同功能和相同属性的对象的集合 对象就是类的实例 2. 类的声明1).语法123class 类名: 类的说明文档 类的内容 2).说明12345class - 声明类的关键字类名 - 和变量的声明要求相同; 规范:见名知义;首字母大写;驼峰式命名类的说明文档 - 用三个双引号引起来类的内容 - 描述声明的类的功能和属性 函数(功能)和变量(属性) 3. 创建对象对象 = 类名( ) 二. 类的方法对象方法, 类方法, 静态方法 1. 对象方法 1).声明: 在类里面直接声明函数 2).调用: 用对象来调用,以’对象.对象方法()’的形式来调用 3).特点: 有个默认参数self, 通过对象调用时不用传参(系统自动传参,将当前调用函数的对象传给self) 4).使用条件:在实现函数功能时需要用到对象属性时使用对象方法 123456789class Dog: def eat(self, food = '骨头'): print('狗吃' + food) def run(self): print('狗跑步')dog1 = Dog()dog1.eat() 2. 类方法 1).声明: 在声明前加@classmethod 2).调用: 通过类来调用 ‘类.类方法’ 3).特点: 自带参数cls,不需要传参,系统会自动将当前类(class)传给cls 4).使用条件:在实现函数功能时不需要用到对象属性的前提下,需要用到类方法 3. 静态方法 1).声明: 在声明前加@classmethod 2).调用: 通过类来调用 ‘类.静态方法’ 3).特点: 没有自带参数 4).使用条件:在实现函数功能时不需要用到对象属性也不需要用到类 123456789101112131415161718192021222324252627class Student: def __init__(self, name, tel, age=18): self.name = name self.age = age self.tel = tel def study(self): print('%s在学习' % self.name) # 类方法 @classmethod def func1(cls): print('类方法') stu2 = cls('小花', '1234') # 静态方法 @staticmethod def func2(): print('类方法')stu = Student('小明', 2341)stu.study()Student.func1()Student.func2() 注意1).用类调用对象方法时,对象方法中的self就不会自动传参,失去对象方法的意义2).类方法可以通过对象调用,但是要有对象 扩展 1) 构造函数:声明类的时候,系统会声明一个和类同名的函数(构造函数);构造函数可以用来创建当前类的对象在创建对象时,系统会调用类中的init方法来初始化对象2) __init__是魔法方法,也是对象方法. 在类里面声明的时候函数名必须是__init__,并保证它是对象方法 若__init__函数需要传参,则可以通过构造函数传参 123456789101112131415&gt;class Dog: def __init__(self): print('init魔法')&gt;dog1 = Dog()&gt;print(dog1)&gt;class Student: def __init__(self, name, age): print('学生:', name, age)&gt;stu = Student('小明', '20') 三. 类中的属性1. 字段属性1).声明:直接声明在类里面,函数外面的变量就是字段2).使用:通过类使用 ‘类.变量’3).使用时机:属性值不会因对象不同而改变的属性就是字段属性 12345class Dog: a = 20print(Dog.a) 2. 对象属性1).声明:声明在 init方法中, 以’self.属性名=值’的形式声明2).使用:通过对象以’对象.属性’来用3).使用时机:属性值会因对象不同而不一样的属性就是对象属性(例如,人的名字会因为人不一样而不同) 12345678class Dog: def __init__(self, variety, age): self.name = variety self.age = agedog1 = Dog('柯基', 2)print(dog1.name, dog1.age) 练习 : 声明一个狗的类:品种,名字,颜色,年龄,性别;吃(xxx吃xxx) 1234567891011121314151617class Dog: def __init__(self, variety, name, color, age, gender): self.variety = variety self.name = name self.color = color self.age = age self.gender = gender def eat(self, food): print('😆%s吃了%s😆' % (self.name, food))dog1 = Dog('长白山吊睛白额虎', '旺财', '花', 3, '公')dog1.eat('一只老虎')dog2 = Dog('蝙蝠侠的耳朵', '鸡翅膀', '油', 2.5, '不明')dog2.eat('美国队长的盾牌🛡') 3. 对象属性的增删改查123456789101112131415161718192021222324252627282930313233343536373839class Dog: def __init__(self, name, age, gender): self.name = name self.age = age self.gender = genderdog1 = Dog('大黄', 2, '公')dog2 = Dog('小黄', 3, '母')# 查\"\"\"1).对象.属性2).getattr(对象, 属性名:str) getattr(对象, 属性名:str, 默认值)\"\"\"print(dog1.name) # (不可以将属性赋值给一个变量,再将变量作为属性名)print(getattr(dog1, 'name'))print(getattr(dog1, 'name', '没有这条狗')) # (没有该属性的时候不会报错,可以将属性赋值给一个变量,再将变量作为属性名)# 增\"\"\"1).对象.属性 = 值 属性存在就修改,不存在就增加2)setattr(对象, 属性名:str, 值) 属性存在就修改,不存在就增加\"\"\"dog1.name = '老黄'print(dog1.name)setattr(dog1, 'name', '老老黄')print(dog1.name)# 删\"\"\"1).del 对象.属性 删除对象中指定的属性2).delattr(对象, 属性名) 删除对象中指定的属性\"\"\"del dog1.name# print(dog1.name) # 报错delattr(dog2, 'name')# print(dog2.name) # 报错 四. 内置属性举例说明! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Dog: \"\"\"狗类\"\"\" num = 100 # __slots__ = ('name', 'age', 'gender', 'height') # 限制对象的属性 def __init__(self, name, age, gender): self.name = name self.age = age self.gender = gender def func1(self): print('对象方法', self.name) @classmethod def func2(cls): print('类方法') @staticmethod def func3(): print('静态方法')dog1 = Dog('大黄', 2, '公')# 1. 类.__name__ --&gt; 获取类名print(Dog.__name__)# 2. 对象.__class__ --&gt; 获取对象对应的类(type(对象)功能一样)print(type(Dog))print(dog1.__class__)# 3. 类.__doc__ --&gt; 获取类的说明文档print(Dog.__doc__)# 4. __dict__# 1) 类.__dict__ --&gt; 获取类中所有的字段和字段对应的值,以字典的形式返回print(Dog.__dict__)# 2) 对象.__dict__ --&gt; 获取对象中所有的属性和属性对应的值,以字典的形式返回(不能和__slots__并用)print(dog1.__dict__)# 5. 类.__module__ --&gt; 获取类所在得模块print(Dog.__module__)# 6. 类.__bases__ --&gt; 获取当前类得父类# object 是python中所有类得基类print(Dog.__bases__)","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]},{"title":"Python基础：14:异常捕获","slug":"Python基础/第一章 1.14 异常捕获","date":"2018-07-13T16:00:00.000Z","updated":"2021-01-08T14:29:29.543Z","comments":true,"path":"2018/07/14/Python基础/第一章 1.14 异常捕获/","link":"","permalink":"https://anjhon1994.github.io/2018/07/14/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.14%20%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/","excerpt":"","text":"一. 异常程序在运行过程中的报错就叫异常 二. 异常捕获1. 使用异常捕获的场景在知道某个位置可能会出现异常,但开发者无法控制时使用 2. 捕获异常①:捕获任何异常 123456789\"\"\"try: 代码块一(可能出现异常的代码)except: 代码块二(对异常进行处理)finally: 代码块三其他语句\"\"\" 先执行代码块1,如果异常,直接执行代码块2,依次往后执行;若代码块1没有异常,不执行代码块2,往后执行 ②:捕获针对异常 1234567\"\"\"try: 代码块一(可能出现异常的代码)except 异常类型: 代码块二(对异常进行处理)其他语句\"\"\" 先执行代码块1,如果异常,检查该异常是否和except后的异常类型是否一致若一致,执行代码块2,依次往后执行;若不一致,程序崩溃. ③:捕获多个异常一(相同处理) 1234567\"\"\"try: 代码块一(可能出现异常的代码)except (异常类型1, 异常类型2...): 代码块二(对异常进行处理)其他语句\"\"\" ④:捕获多个异常一(不同处理) 123456789101112\"\"\"try: 代码块一(可能出现异常的代码)except (异常类型1): 代码块二(对异常进行处理)except (异常类型2): 代码块三(对异常进行处理)except (异常类型3): 代码块四(对异常进行处理) ... 其他代码\"\"\" 三. 关键字finally在以上四个捕获异常的方法中都可以在最后加上finally关键字,它的作用是:不管try中的代码出现任何情况,finally后的代码都会执行 12345678try: print(&#123;'name': 'an', 'age': 29&#125;['gender']) print('hello'[19]) print(max([10, 'asd', True]))except IndexError: print('出现异常')finally: print('写遗书') 四. 抛出异常raise 异常类型","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]},{"title":"Python基础：13:文件操作","slug":"Python基础/第一章 1.13 文件操作","date":"2018-07-10T16:00:00.000Z","updated":"2021-01-08T14:29:18.355Z","comments":true,"path":"2018/07/11/Python基础/第一章 1.13 文件操作/","link":"","permalink":"https://anjhon1994.github.io/2018/07/11/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.13%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"","text":"一 . 文件操作1. 数据的存储1).数据存储计算机存储分为运行内存和硬盘存储运行内存是用来存储程序运行过程中产生的数据,程序结束,数据销毁硬盘存储的文件则一直存在 2).常用的文件文本文件: txt, json(前后端), plist(页面), 数据库文件二进制文件: 图片文件: png, jpg… ;音频文件: mp3, wav…; exe文件等 2. 文件操作文件内容操作基本步骤 : 打开文件 -&gt; 操作文件(读, 写) -&gt; 关闭文件 1) . 打开文件open(file, mode=’r’, encoding=None) open(文件地址, 读写方式, 文本编码方式) - 以指定方式打开指定文件返回文件对象 说明:file ——&gt; 文件路径(相对路径或绝对路径)相对路径: ./ - 表示当前目录&emsp;&emsp;&emsp;&emsp;../ - 表示当前目录的上层目录 mode ——&gt; 文件打开方式,决定打开文件后的操作权限(读-r , 写-w)操作文件的数据类型(文本-t, 二进制-b)文本文件在读取的时候可以用rt, rb,但是二进制文件只能用rb读取a - 只写(a和w的区别就是,a打开文件不会删除源文件,w会)&gt;&gt;&gt; a和w打开文件的时候,若文件不存在,会创建新文件r打开文件时,若文件不存在,报错 encoding - 文本文件编码方式,只能用t打开文本文件的时候才能赋值一般采用’utf-8’的编码方式编码,保证同一文件读和写的编码方式一样 2).文件操作a.读操作文件对象.read() - 读指定文件,返回文件中的内容(所有文件)文件对象.readline() - 读指定文件的1行内容(只支持文本文件)文件对象.close() - 关闭操作好的文件 文件读完之后,光标会停在最后读取的位置,再继续读取的话接着上次的位置继续b.写操作文件对象.write(内容) - 将指定的功能写入到指定的文件中 123456o3 = open(r'../test/诗.txt', 'r', encoding='utf-8')while True: line = o3.readline() if not line: break print(line) 二 . 数据持久化1. 数据持久化1).需要持久化的数据要存到文件中2).需要数据的时候不直接赋值,从文件中读取数据3).若数据的值发生改变,则将新数据更新到文件中 1234567891011# 在程序中用一个变量来记录当前程序启动的次数# countf = open(r'../test/num.txt', 'r', encoding='utf-8')count = int(f.read())print(count)count += 1f = open(r'../test/num.txt', 'w', encoding='utf-8')f.write(str(count))f.close() 2. 文件域with open(文件路径,打开方式,编码方式) as 文件对象文件路径可以是绝对路径也可以是行对路径相对路径中 ./ 代表当前目录 ; ../ 代表当前目录的上层目录,依次类推 3.容器字符串的转换:eval当一个字符串内是一个完整的其他容器(列表,字典,集合,元组)时,eval(字符串)可将字符串转换成相应的容器 1234567str1 = '[1, 2, 3, 4]'re1 = eval(str1)print(re1, type(re1))str2 = \"&#123;'name': 2, 'age': 4&#125;\"re2 = eval(str2)print(re2, type(re2)) 三 . jsonjson模块是python中专门用来支持json数据的模块 1.jsonjson是一种数据格式,专门用来解决各个计算机语言间数据不能互通的问题 1).一个json只有一个数据2).唯一的这个数据必须是json支持的数据类型json支持的数据类型: a.数字类型(number) ——&gt; 所有数字,支持科学计数法,直接写 b.字符串(string) ——&gt; 文本数据,只能用双引号引起来,并且支持转义字符&quot;abc&quot;, &quot;sadhuwe&quot;, ... c.布尔值(boolean) ——&gt; true/false(直接写) d.空值 ——&gt; null(直接写) e.数组(array) ——&gt; [元素1, 元素2, 元素3,…] 元素可以是json支持的任何数据类型 f.字典(dictionary) ——&gt; {key1:value, key2:value, key3:value, …} key必须是字符串,value可以是json支持的任何类型 2.json转python1).转换规律json ——&gt; python数据 ——&gt; int/float字符串 ——&gt; 字符串;双引号可能变为单引号布尔 ——&gt; 布尔:True/Falsenull ——&gt; None数组 ——&gt; 列表字典 ——&gt; 字典 2).转换方法json.loads(字符串) ——&gt; 将json字符串转换成python的字符串 注意:要求字符串内的内容必须是json格式的数据 12345678result = json.loads('1')print(result, type(result))result = json.loads('[123, \"ads\", true]')print(result, type(result))result = json.loads('&#123;\"name\": \"an\", \"age\": 20&#125;')print(result, type(result)) 3.python转json1).转换规律python ——&gt; jsonint/float ——&gt; 数字字符串 ——&gt; 字符串;单引号变成双引号布尔值 ——&gt; 布尔值;true/falseNone ——&gt; null列表/元组 ——&gt; 数组字典 ——&gt; 字典 2).方法json.dumps(数据) ——&gt; 将python数据转换成json类型的python字符串 12345result = json.dumps(100)print([result])result = json.dumps((10, 'ahs', False))print(result)","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]},{"title":"Python基础：12:生成器和模块","slug":"Python基础/第一章 1.12 生成器和模块","date":"2018-07-07T16:00:00.000Z","updated":"2021-01-08T14:28:58.319Z","comments":true,"path":"2018/07/08/Python基础/第一章 1.12 生成器和模块/","link":"","permalink":"https://anjhon1994.github.io/2018/07/08/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.12%20%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E6%A8%A1%E5%9D%97/","excerpt":"","text":"一. 生成器1.生成器 生成器也是迭代器的一种; 生成器作为容器它保存的不是数据,而是产生数据的算法 2.创建生成器 调用带有yield关键字的函数,就可以得到一个生成器 注:函数中只要有yield,不管会不会遇到(执行),则调用该函数,函数体都不会执行,并且得到一个生成器 3.生成器产生数据 一个生成器能产生多少数据和什么数据,看执行完生成器关联的函数在执行完会遇到几次yield, 能遇到几次yield就产生几个数据;每次遇到yield,后面的数据就是对应的元素 4.生成器产生数据的规律 获取第一个元素的时候,从函数的第一条语句开始执行,遇到第一个yield停止,并且将yield后面的值作为当前获取到的元素; 获取下一个元素的时候,接着上一个结束的地方执行,遇到下一个yield停止,并且将yield后面的值作为当前获取到的元素; 以此类推… 当函数体后面没有yield时,说明该生成器的数据已经被取完了,再次运行将会报错 12345678910111213141516171819202122232425# 例:def func3(): print('======') yield 1 print('++++++') yield 10 print('******') yield 100gen2 = func3()print(next(gen2))print(next(gen2))print(next(gen2))print(next(gen2)) # 元素取完后报错# 练习:写一个生成器能产生一个班所有学生的学号def students_num(n): length = len(str(n)) for num in range(1,n+1): yield str(num).zfill(length)nums = students_num(50)for num1 in nums: print(num1) 5.生成式1) 生成式就是生成器;就像函数和匿名函数,只是写法简洁1234567891011121314151617181920212223242526272829303132333435\"\"\"1)语法①:生成器 = (表达式 for 变量 in 序列) 展开: def 函数名(): for 变量 in 序列: yield 表达式生成器 = 函数名() 语法②: 生成器 = (表达式 for 变量 in 序列 if 条件语句) 展开: def 函数名(): for 变量 in 序列: if 条件语句: yield 表达式生成器 = 函数名()语法③: 生成器 = (表达式 for 变量1 in 序列1 for 变量2 in 序列2) 展开: def 函数名(): for 变量1 in 序列1: for 变量2 in 序列2: yield 表达式生成器 = 函数名()\"\"\"# 例:gen1 = (num for num in range(1, 11))gen4 = (x for x in range(10) if x % 2) 2) 列表生成式 将上面语法中所有的小括号编程中括号,结果就会变成列表 二. 模块1.模块(python中,一个py文件就是一个模块)2.模块间的相互引用(导入模块)若要使用另外一个模块的内容,需要在当前模块中导入相应的模块 1) 模块导入方法:(导入模块的代码一般放在文件最顶部, 系统文件放最前面,第三方在中间,自己写的放最后)①:import 模块名 - 导入后可以使用被导入模块的所有全局变量 - 以 ‘模块名.变量名’ 的方式使用相应模块 ②:from 模块名 import 变量名1, 变量名2,… - 导入后可以使用import后指定的变量 - 使用时直接使用 ③:from 模块名 import * - 导入后可以使用被导入模块的所有全局变量 - 使用时直接使用 2) 对模块重命名 import 模块名 as 新模块名——&gt;有时候导入的模块名或函数名会与本模块内的一些参数名相同,则在模块中通过新名字来使用导入的模块 也可以通过这种方式对模块中的变量进行重命名 3) 阻止导入 当执行导入模块的代码时,系统会执行被导入模块的所有代码,为了防止执行所有代码造成的不必要消耗,需要用到阻止导入 阻止导入:将被导入模块内不需要被调用的代码放到 if name__ == ‘main__‘ 语句中即可;在该if 语句中的代码不能被其他模块引用,但在本模块内可以运行. 阻止原理:模块在创建的时候,系统会为模块添加 __name__ 属性,用来保存该模块的名字; __name__ 默认是该文件的文件名,当直接运行该模块时, __name__ 会变成 __main__,此时if语句成立,执行后面的代码 三. 包(包是用来管理模块的)包是包含 __init__.py文件的文件夹 1 导入包内的模块①:import 包.模块 (可用as重命名) 包.模块.调用的代码名 ②:from 包 import 模块1, 模块2, … 模块.调用的代码名 ③:from 包.模块 import 调用的代码名④:from 包.模块 import 变量 2.init文件 导入包后,原始状态的包只会执行 __init__ 文件,需要在 __init__ 文件内导入包内的其他模块. 四. hashlib模块1.hashlib hashlib是python提供的用哈希算法进行加密的库 哈希算法又叫离散算法,主要包含MD5,sha两类算法 2.哈希算法加密特点1).加密后的的密文(摘要)是不可逆的2).相同的数据通过通过相同的算法加密后的密文是相同的3).不同长度的数据通过相同的算法加密后的密文长度是相同的 3.产生密文(摘要)的过程 (如何加密)1).创建hashlib对象: hashlib.算法名()2).添加需要加密的数据: 哈希对象.update(数据(必须是二进制数据))3).生成密文(摘要): 哈希对象.hexdigest() 12345hash = hashlib.md5()pw = '123456'hash.update(pw.encode())result = hash.hexdigest()print(result) &gt;&gt;&gt;&gt;&gt;&gt;&gt; 知识扩展 bytes是二进制的数据类型1.字符串转二进制①:bytes(字符串, encoding=’utf-8’)②:字符串.encode() 2.二进制转字符串①:str(二进制,encoding=’utf-8’)②:二进制.decode(encoding=’utf-8’)","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]},{"title":"Python基础：11:高阶函数","slug":"Python基础/第一章 1.11 高阶函数","date":"2018-06-25T16:00:00.000Z","updated":"2021-01-08T14:28:46.305Z","comments":true,"path":"2018/06/26/Python基础/第一章 1.11 高阶函数/","link":"","permalink":"https://anjhon1994.github.io/2018/06/26/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.11%20%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/","excerpt":"","text":"一.实参高阶函数1.函数作为变量使用python中声明函数就是声明一个类型是function的变量,变量名就是函数名普通变量能做的函数都能做: 1).一个变量可以给另一个变量赋值,函数也可以赋值给一个变量 2).变量的值可以修改,函数作为变量并被赋值后,函数原本的功能就消失了 3).变量作为序列中的元素,函数也行 4).变量作为函数的参数,函数也行 将函数作为另一个函数的参数,这就是实参高阶函数 2.系统的实参高阶函数列表.sort(); sorted(); max(); min() -&gt; 都有一个参数key,要求是一个函数 例:列表.sort()排序函数 sort()括号里面有key函数和revers,key函数确定了排序的规则,revers=True时倒序,revers=False时正序 1).排序函数;参数key要求是一个函数,作用是用来定制拍寻的规则key的要求:①:key是一个函数②:函数中有且只有一个参数,这个参数指向的是序列中的每个元素③:函数需要一个返回值,这个返回值就是排序的时候比较大小的对象 2).最大值函数:12345678910111213141516171819# 练习:进下面的列表按个位数的大小排序nums = [100, 39, 51, 62, 58]nums.sort(key=lambda item: item % 10)print(nums)print(max(nums, key = lambda item: item % 10))# 练习:将学生按成绩排序students = [ &#123;'name': '小明', 'age': 18, 'grade': 90&#125;, &#123;'name': '小花', 'age': 28, 'grade': 59&#125;, &#123;'name': '狗子', 'age': 8, 'grade': 87&#125;, &#123;'name': '大黄', 'age': 45, 'grade': 98&#125;]students.sort(revers=True, key=lambda item: item['grade']print(students)print(max(students, key = lambda item: item['grade']# 按学生年龄和分数的和排序students.sort(key = lambda itme: item['age'] + item['grade']print(students)print(max(students,key = lambda item: item['age'] + item['grade'] 二.返回值高阶函数1.函数作为函数的返回值 - 返回值高阶函数 12345#func1就是一个返回值高阶函数def func1(): def func2(): print('函数2') return func2 2.闭包 - 函数1中声明了函数2 ,函数2 中使用了函数1中的数据,则函数1就是一个闭包特点:闭包函数中的数据不会因为函数调用结束而销毁 123456789def func3(): a = 10 print(id(a)) def func4(): print(a) print(id(a)) return func4 面试题练习:1234567891011121314#不执行以下代码,问以下代码的执行结果list1 = []for i in range(5): list1.append(lambda x: x*i)print(list1[1](2), list1[2](2), list1[3](2))def func2(seq=[]): seq.append(10) return seqprint(func2())print(func2()) 三.装饰器1.什么是装饰器装饰器本质就是一个函数 装饰器 = 返回值高阶函数+实参高阶函数+糖语法 装饰器是python的三大神器之一：装饰器、迭代器、生成器 装饰器的作用:给已经写好的函数添加新的功能 2.用函数给函数添加功能的方法方法一 123456789101112131415161718192021222324252627282930313233# ①:给不需要参数的函数添加功能def add_time(fn): star = time.time() fn end = time.time() print('函数执行时间:%fs' % (end - star))# ②:给需要参数的函数添加功能def add_time2(fn, *args, **kwargs): star = time.time() fn(*args, **kwargs) end = time.time() print('函数执行时间:%fs' % (end - star))def func1(): print('======') print('++++++')def func2(): print('你好,python') print('你不好,python')def func3(x, y): print('%d+%d=%d' % (x, y, x+y))print(add_time(func1()))print(add_time(func2()))print(add_time2(func3, 10, 20)) 方法二(装饰器) 无参装饰器函数:def 函数名1(参数1):&emsp;def 函数名2(*args, **kwargs):&emsp;&emsp;参数1(*args, **kwargs)&emsp;新功能对应的代码&emsp;return 函数名2 说明:函数名1 - 装饰器的名称;需要添加的共嗯名称参数1 - 需要添加功能的函数,一般命名为fn函数名2 - 随便命名, 123456789101112131415161718192021222324252627# 添加统计函数执行时间的装饰器def add_time3(fn): def test(*args, **kwargs): star = time.time() re =fn(*args, **kwargs) end = time.time() print(end - star) return re return test# 练习&gt;&gt;&gt;&gt;&gt;&gt;&gt;def exchange_hex(fn): def test(*args, **kwargs): re = fn(*args, **kwargs) if type(re) == int: return hex(re) return re return test@exchange_hexdef diy_sum(x, y): return x+yprint(diy_sum(10, 20)) 四.迭代器1.什么是迭代器(iter)迭代器也是python提供的容器型数据类型迭代器存储数据的特点: ①:一个迭代器能存多个数据 ②:若要获取或查看数据必须要从迭代器中取出 ③:取出来的数据不能再添加到迭代器 2.将数据存入迭代器①:将其他序列转换成迭代器②:创建一个生成器 3.获取迭代器中的元素迭代器中的元素只要取出(任何方式)那这个元素在迭代器中就不存在了 1).获取单个元素next(迭代器) - 取出迭代器中最上面的元素print(next(iter1))print(next(iter1))print(next(iter1)) 2).遍历12for x in iter2: print('x:', x)","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]},{"title":"Python基础：10:函数进阶","slug":"Python基础/第一章 1.10 函数进阶","date":"2018-06-19T16:00:00.000Z","updated":"2021-01-08T14:28:34.561Z","comments":true,"path":"2018/06/20/Python基础/第一章 1.10 函数进阶/","link":"","permalink":"https://anjhon1994.github.io/2018/06/20/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.10%20%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/","excerpt":"","text":"一.函数返回值 1.返回值的作用:将函数里面的数据传到函数外(在函数里的打印只能看不能操作) 2.怎么确定需不需要返回值:看函数的功能完成后会不会产生新的数据 3.怎么确定函数的返回值:函数声明的时候return后面的值就是函数的返回值;如果没有return,函数的返回值就是None return是关键字;只能出现在函数体中&emsp;作用:①.确定函数的返回值&emsp;&emsp;&emsp;②.结束函数(执行函数体的时候若遇到return函数直接结束,同时将return后面的值作为函数的额返回值) 4.怎么获取函数的返回值:函数调用表达式就是函数的返回值函数调用表达式:函数调用语句(普通数据能做的事,它都能做) 二.函数的调用1.函数调用过程:①.回到函数声明的位置②.传参 - 保证每个参数都有值③.执行函数体④.执行完函数体确认返回值:若遇到return,return后面的值就是返回值;若没有遇到,返回值就是None⑤.回到函数调用的位置(函数表达式的值就是返回值) 2.内存的变化:函数的调用过程事一个压栈的过程(系统会自动在栈区间开辟一个专用的内存区域,专门用来保存在函数内声明的变量和产生的数据(形参也是函数内的)) 当函数调用结束的时候,这个内存区域会自动销毁(销毁前会将返回值送出) 三.变量的作用域1).全局变量没有生命在函数中或者类中的变量都是全局变量作用域:全局变量从声明开始到文件结束任何地方都可以用 2).局部变量在函数内声明的变量就是局部变量;作用域:从声明开始到函数结束可以使用(形参是声明在函数中的局部变量) 12345678910111213#a是全局变量a = 10# 循环内声明的变量也是全局变量(b和c)for b in range(5): c = 100 pass# 在循环内部可以用for x in range(3): print(a)# 在函数中可以用def func1(): print('函数中:', a) 1.global若要在函数内改变全局变量的值,要先用global进行说明在函数中若要声明一个全局变量,也要在变量前加global语法:global 变量名 2.nonlocal使用方法:在函数中给变量赋值前加:nonlocal 变量名作用:在局部的局部中修改局部变量的值 四.匿名函数匿名函数还是函数,除了声明的语法和类型说明以外,其他语法基本都适用匿名函数 1.声明匿名函数变量(函数名) = lambda 参数列表:返回值&emsp;def (参数列表):&emsp;return 返回值 2.说明:lambda - 关键字,固定写法参数列表 - 形参:参数名1,参数名2,…:(冒号) - 固定写法返回值 - 相当于普通函数中函数体中的return语句 12345# 用匿名函数求两个数的和func1 = lambda num1, num2: num1 + num2# 练习:写一个函数判断指定的年是否是闰年diy_year = lambda year: year % 400 == 0 or (year % 4 == 0 and year % 100 != 0)print(diy_year(2008)) 五.递归函数1.什么是递归函数声明函数的时候调用函数本身递归可以实现循环效果,除了死循环,其他的循环递归都可以实现 2.递归怎么用使用递归的方法:1).设置临界值 - 循环结束的条件(保证函数结束)2).找关系 - 找f(n)和f(n-1)的关系(上一次循环和下一次循环的关系)3).假设函数的功能已经实现,通过f(n-1)去实现f(n)的功能 1234567891011121314151617181920212223242526272829303132333435# 写一个递归函数,计算1+2+3+...+ndef diy_sum(n): if n == 1: return 1return diy_sum(n-1) + nprint(diy_sum(10))# 写一个递归函数,计算斐波那契额数列的第n个数def diy_series(n): if n == 1 or n == 2: return 1 return diy_series(n-1) + diy_series(n-2)print(diy_series(5))# 练习:'''n = 4**********n = 3******'''def diy_p(n): if n == 1: print('*') return diy_p(n-1) print(n * '*')","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]},{"title":"Python基础：9:函数基础","slug":"Python基础/第一章 1.9 函数基础","date":"2018-06-16T16:00:00.000Z","updated":"2021-01-08T14:28:18.303Z","comments":true,"path":"2018/06/17/Python基础/第一章 1.9 函数基础/","link":"","permalink":"https://anjhon1994.github.io/2018/06/17/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.9%20%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/","excerpt":"","text":"一、认识函数1、什么是函数1）、函数的定义：函数就是对实现某一特定功能的代码的封装2）、函数的分类： ①、系统函数 - 语言系统自带的，可以直接调用的函数：print、len、chr、ord、input… ②、自定义函数 - 开发者自己声明的函数 二、函数的声明1、语法：def 函数名(参数列表)：&emsp;函数说明文档&emsp;函数体 2、说明： def———-&gt;关键字，固定写法 函数名———-&gt;和变量名的要求一样 ():———-&gt;固定写法 参数列表———-&gt;又叫形参；（参数名1，参数名2，参数名3…）参数名就是变量名；将函数外面的数据传到函数里面 函数说明文档 ———-&gt;本质就是一段注释（要求：①必须在第一行有效代码的前面；②需要使用三个双引号引起来的注释) 函数体———-&gt;和def保持一个缩进的一条或多条的代码；也是实现函数功能的代码。 3、声明函数的步骤（重要）①、确定函数的功能②、函数名 见名知义③、确定参数（形参），看实现函数的功能需不需要额外的数据，需要几个就设置几个形参④、实现函数的功能⑤、写说明文档 注意：声明函数的时候不会执行函数体 1234567891011121314151617181920# 声明一个函数，打印两个数的和def diy_sum(num1, num2): \"\"\" (函数功能说明区)求两个数的和 \"\"\" print(num1 + num2)diy_sum(10, 20)# 声明一个函数求阶乘N!def diy_factorial(n): pro = 1 for x in range(1, n+1): pro *= x print('%d的阶乘是：%d' % (n, pro))diy_factorial(5) 三、函数的调用1、语法：函数（实参列表） 2、说明 函数———-&gt;已经声明的函数 ()———-&gt;固定写法 实参列表———-&gt;需要传递到函数中使用的具体数据，用来给形参赋值的；写法：多个数据用逗号隔开； 3、函数的调用过程(重要)①：回到函数声明的位置②：传参—用实参给形参赋值(必须保证每个形参都有之，不能多也不能少)③：执行函数体④：确定返回值⑤：回到函数调用的位置接着往后执行代码 四、参数1、参数赋值1）、位置参数———-&gt;让实参的值和形参的位置一一对应2）、关键字参数———-&gt;调用函数的时候以‘形参名1=值1，形参名2=值2…’3）、位置参数和关键字参数混用———-&gt;混用的时候必须保证位置参数在关键字参数的前面，同时保证每个参数必须有值2、参数默认值 声明函数的时候，可以通过’参数名=值’的形式给参数默认值；有默认值的参数在调用时可以不赋值 关键参数的使用场景：想要跳过前面有默认值的参数给后面的参数赋值时只能用关键字参数 有默认值的参数必须放在没有默认值的参数的后面 3、参数类型说明1）、给参数赋默认值，默认值是什么类型，就默认参数是什么类型2）、在形参后面加冒号加类型名，形参:类型名3）、在形参括号后面加类型名，表示返回值的类型： # def diy_print2(a=1, b=5, c=30) -&gt; str: 4、不定长参数声明函数的时候参数个数不确定 ①、声明函数时在参数名称前加星号*，这个参数就会变成一个元素，元组内的元素就是对应的实参； 注意：a.只能使用位置参数赋值&emsp;&emsp;&emsp;b.不定长参数后面如果有其他的定长参数，那么后面的参数必须使用位置参数赋值def func(*x): def func(name, *grade): def func(name, *grade, tel): ②、声明函数时在参数名称前加两个星号**，这个参数就会变成一个字典(关键字:实参值)注意：a.只能使用关键字参数赋值&emsp;&emsp;&emsp;b.*和**同时使用还是不定长参数，可以同时使用位置参数和关键字参数；(*要放到**前面) ③、一个星和两个星一起用： def func(*args, **kwargs):","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]},{"title":"Python基础：8:数据类型之字符串","slug":"Python基础/第一章 1.8 数据类型之字符串","date":"2018-06-05T16:00:00.000Z","updated":"2021-01-08T14:28:02.555Z","comments":true,"path":"2018/06/06/Python基础/第一章 1.8 数据类型之字符串/","link":"","permalink":"https://anjhon1994.github.io/2018/06/06/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.8%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"一、字符串 字符串(str)是容器型数据类型，他是将单引号(‘’)、双引号(“”)、三个单引号或三个双引号(‘’’ ‘’’/“”” “””)作为容器标志 字符串有不可变性（不支持增删改）、有序性（支持下标操作） 1、字符串的元素 —字符python中只有字符概念，没有字符类型。引号中只有一个元素的字符串可以看成一个字符；字符串又叫字符集。 1）、字符原则上任何可以通过键盘输入或者从其他地方复制粘贴的所有符号都可以作为字符 2）、普通字符在字符串中能够代表符号本身的字符（没有特殊意义和特殊功能的符号） 3）、转义字符在字符串中有特殊意义和特殊功能的字符的组合，一般是以斜杠\\开头的常见的转义字符：\\n ——&gt; 表示换行\\t ——&gt; 表示一个缩进（Tab）\\\\ ——&gt; 表示斜杠本身&#39; ——&gt; 表示单引号&quot; ——&gt; 表示双引号\\u四位16进制数 ——&gt; 编码字符（获取四位16进制数作为编码值对应的值） 所有的转义字符长度都是1 4）、阻止转义在字符串最前面加r或R可以让当前字符串中所有的转义字符失效（所有的符号在字符串中都表示这个符号本身） 12str6 = '\\tsd\\n\\'ds123'str7 = r'\\tsd\\n\\'ds123' 2、字符编码1）、计算机不能直接存储符号，只能存储数字，为了能够存储字符，把每个字符关联了一个固定的数字（这个固定的数字就是对应字符的编码）2）、ASCII表在计算机中采用一个字节保存一个字符（128个字符），字符包含了所有的字母、数字和英文常用符号&emsp; 0-9：编码值依次增加 ； 0对应48&emsp; A-Z：编码值以此增加 ； A对应65&emsp; a-z：编码值依次增加 ； a对应97 3）、Unicode编码表是ASCII表的扩展，包含了世界上所有国家所有语言对应的符号（总共有65536个符号）&emsp; ASCII表范围：0 - 127&emsp; 中文的编码范围：4e00 - 9fa5 方法：①：编码字符：\\u4位16进制数②：chr(编码值(可以是任何进制)) - 获取编码值对应的字符③：ord(字符) - 获取指定字符对应的编码值 123456#获取所有的中文字符num = 0for x in range(0x4e00, 0x9fa5): print(chr(x)) if num % 35 == 0: print() 二、字符串的查（字符串有不可变性（不支持增删改））1、获取单个字符：字符串[下标]一个空格是一个字符；tab键是4个字符；\\t是一个字符 2、获取多个字符：切片—字符串[开始下标：结束下标：步长]3、遍历：遍历元素，遍历下标12345str1 = 'hello python'print(str1[-4])print(str1[5])print(str1[2:])print(str1[:-2:]) 三、字符串的运算和函数1、运算符1）、加 +, 乘 *2）、等 ==, 不等 !=3）、&gt;, &lt;, &gt;=, &lt;=字符串比较大小是比较编码值的大小，一个字符一个字符的比较判断字符是否是小写字母：’a’&lt;= char &lt;=’z’判断字符是否是大写字母：’A’&lt;= char &lt;=’Z’判断字符是否是字母：’A’&lt;= char &lt;=’Z’ or ‘a’&lt;= char &lt;=’z’判断字符是否是中文：’\\u4e00’ &lt;= char &lt;= ‘\\u9fa5’判断字符是否是数字：’0’ &lt;= char &lt;= ‘9’ 12345678# 练习：输入一个字符串，判断这个字符串是否是中文字符串（全是中文）value = input('请输入：')for char in value: if not '\\u4e00 &lt;= char &lt;=\\u9fa5': print('不是中文字符串') breakelse: print('是中文字符串') 2、in 和 not in字符串1 in 字符串2 -&gt; 判断字符串2中是否包含字符串1print(‘a’ in ‘abcdf’)print(‘abc’ in ‘abcdf’) 子串必须是连续的 3、相关函数①、len(字符串)print(len(‘\\tsdse\\ndsdwds\\u4e00’))②、str(数据)print(list(str([10,20,30])))③、sorted(字符串) 从小到大排序str1 = ‘python’print(sorted(str1))④、reversed(字符串)倒序 四、格式字符串1、格式占位符1）、语法：包含格式占位符的字符串 % （值1，值2，值3，…）2）、说明：% - 固定写法() - 若值只有一个，可省略值 - 任何有结果的表达式，值得个数和类型要与前面的占位符的个数和类型相同 格式占位符 - 格式占位符使用的时候和字符串中变化的数据类型相关 &emsp;%s - 字符串（任何类型都可以） &emsp;%d - 整型； &emsp;%-Nd - 整型；N约束数字的长度，如果不够，空格来凑（后面）。如果超了，不能约束 &emsp;%-Nd - 整型；N约束数字的长度，如果不够，空格来凑（前面）。如果超了，不能约束 &emsp;%f - 浮点数；小数点后保留6位 &emsp;%.Nf - 浮点数；N约束小数点的位数 1234name = input('请输入姓名：')age = int(input('请输入年纪：'))print('你好，我是'+ name +'今年',str(age)+'岁')print('你好，我是%s，今年%d，工资%s' % (name, age, 200)) 2、format1）、语法：一个带有{}的字符串.format(值1，值2，…)2）、用法：①、大括号的个数和后面的数值个数一样print(‘我是{}，今年{}岁’.format(‘安’, 20)) ②、{N} - N从0开始以此增加、分别表示format中第0个值，第一个值。。。print(‘我是{0}，年纪是{1}，今年{1}岁’.format(‘安’, 20))print(‘数据1：{1}，数据2：{0}，数据3：{1}，’.format(10, 20)) ③、[key]‘{key1},{key1}’.format(key1=值1，key2=值2)print(‘我是{name}，年纪是{age}，今年{age}岁’.format(name=’安’, age=20)) ④、用列表给占位符赋值list1 = [10, 20, 30, 40]print(‘{0[3]}, {0[2]}, {0[1]}’.format(list1)) ⑤、用字典给占位符赋值student = {‘name’: ‘小明’, ‘age’:20, ‘id’: ‘001’, ‘score’:100}print(‘{name}今年{age}岁，学号:{id},考了{score}’.format(student)) ⑥、其他写法print(‘圆周率:{:.2f}’.format(3.141592654)) - 约束宽度print(‘整数:{:0&gt;4d}’.format(25))print(‘整数:{:+&gt;4d}’.format(26))print(‘整数:{:-&lt;4d}’.format(27)) - 数字分隔print(‘大整数:{:,}’.format(10000000000)) - 百分比print(‘百分比:{:.1%}’.format(0.2)) 五、字符串的相关操作1、字符串.capitalize() - 将字符串的首字母变成大写字母2、center / ljust / rjust / zfill字符串.center(宽度，填充字符)print(‘abc’.center(5,’*‘)) 字符串.ljust(宽度，填充字符)print(‘abc’.ljust(5,’*‘)) 字符串.rjust(宽度，填充字符)print(‘abc’.rjust(5,’*‘)) 字符串.zfill(宽度) == 字符串.zfill(宽度,’0’)print(‘abc’.zfill(5)) 3、统计1）、字符串1.count(字符串2)2）、字符串1.count(字符串2,开始下标,结束下标) - 统计开始到结束范围内字符串2出现的次数1234str2 = 'how are you? i am fine! thank you!'print(str2.count('you'))print(str2.count('a'))print(str2.count('you', 0, 15)) 4、判断str2是否以str1结尾print(str2[-len(str1):] == str1) 5、字符串查找获取一个字符串在另一个字符串中第一次出现的位置 123str2 = 'how are you? i am fine! thank you!'print(str2.index('you'))print(str2.find('you')) 当字符串不存在的时候：index报错，find返回-1 6、join字符串.join(序列) - 将序列中的元素用字符串连接在一起，产生新的字符串 123456str3 = '+'.join('abc')print(str3)str4 = ''.join('234cc')print(str4)str5 = ''.join(&#123;'a': 1, 'b': 2&#125;)print(str5) 7、字符串替换字符串1.replace(字符串2，字符串3)——将字符串1中所有的字符串2都替换成字符串3 12str2 = 'how are you? i am fine! thank you!'str2.replace('you', 'me') 字符串1.maketrans(字符串2，字符串3)——创建字符串2和字符串3—一对应的映射表字符串1.translate(替换映射表) ——将字符串1中所有的字符串2都替换成字符串3 123table = str.maketrans('a','b')new_str2 = str2.translate(table)print(new_str2) 8、切割字符串1.split(字符串2)——将字符串1中所有的字符串2作为切割点切成多分,切割点会被去掉并返回一个列表 12str2 = 'how are you? i am fine! thank you!'print(str2.split(' '))","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]},{"title":"Python基础：7:数据类型之集合","slug":"Python基础/第一章 1.7 数据类型之集合","date":"2018-05-22T16:00:00.000Z","updated":"2021-01-08T14:27:42.460Z","comments":true,"path":"2018/05/23/Python基础/第一章 1.7 数据类型之集合/","link":"","permalink":"https://anjhon1994.github.io/2018/05/23/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.7%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%9B%86%E5%90%88/","excerpt":"","text":"一、什么是集合 集合是容器型数据类型，将大括号{}作为容器标志，元素之间用逗号隔开 {元素1，元素2，元素3…} 集合有可变性（支持增删改），无序性（不支持下标操作） 集合中的元素：元素不可变性，元素唯一性（自带去重） 1、空集合x = {} —（如果这样写，系统会默认为空字典而不是空集合）空集合的正确写法：set1 = set() 2、集合中的元素集合里的元素具有不可变性和唯一性 3、集合的基本操作(1、查 — 只能遍历，不能单取或切片(2、增a.添加单个元素：集合.add(元素) - 在集合中添加指定元素b.集合.update(序列) - 将序列中所有的元素都添加到集合中去 (3、删a.集合.remove(元素)—元素不存在报错b.集合.discard(序列)—元素不存在不报错 4、其他(1、in / not in(2、len、setset(序列) - 所有的序列都可以转换成集合（元素不可变），自动去重 二、集合运算并集（+），交集（&amp;），差集（-），对称差集（^），&gt; / &lt;（包含关系） 1、并集：集合1 | 集合2 -&gt; 将两个集合合并在一起产生一个新的集合print(set1 | set2) 2、交集：集合1 &amp; 集合2 -&gt; 获取两个集合的公共部分产生一个辛几何print(set1 &amp; set2) 3、差集：集合1 - 集合2 -&gt; 获取集合1中去掉集合2剩下的部分print(set1 - set2)print(set2 - set1) 4、对称差集：集合1 ^ 集合2 -&gt; 获取集合1和集合2合并后去掉公共部分剩下的部分print(set1 ^ set2) 5、集合1 &gt; 集合2 -&gt; 判断集合1是否包含集合2&emsp; 集合2 &gt; 集合1 -&gt; 判断集合2是否包含集合1","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]},{"title":"Python基础：6:数据类型之字典","slug":"Python基础/第一章 1.6 数据类型之字典","date":"2018-05-14T16:00:00.000Z","updated":"2021-01-08T14:27:30.224Z","comments":true,"path":"2018/05/15/Python基础/第一章 1.6 数据类型之字典/","link":"","permalink":"https://anjhon1994.github.io/2018/05/15/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.6%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E5%85%B8/","excerpt":"","text":"一、字典1、什么是字典1）、字典： 字典是容器型数据类型，将大括号{}作为容器的标志，里面多个元素用逗号隔开，字典中的元素只能是键值对：{键1:值1, 键2:值2, 键3:值3,…} 字典的可变性(支持增删改)，无序性(不支持下标操作) 2）、键值对 字典中所有元素都必须是键值对，键和值必须成对出现 字典存数据存的是值，键只是用来区分不同的值的 键 - 理论上是任何不可变的数据都可以，实际开发的时候一般将字符串作为键（key），在同一字典中键是唯一的 值 - 可以是任何类型的数据12dict1 = &#123;'dfg':34, 'a':True, 'o':[1,2], 'c':&#123;'name':'小明'&#125;&#125; # 值可以是任何数据dict2 = &#123;10:34, 'a':True, [1,2]:&#123;'name':'小明'&#125;&#125; # 键只能是不可变数据：数字，元组，字符串 二、字典的基本操作（增删改查）1、查 — 获取字典的值1)、获取单个值字典[key]——&gt;获取字典中指定key对应的值，若key值不存在，报错字典.get(key)——&gt;获取字典中指定key对应的值，若key值不存在，不报错，返回None字典.get(key，默认值)——&gt;获取字典中指定key对应的值，若key值不存在，不报错，返回指定的默认值 123person = &#123;'name':'小明', 'age':'18', 'tel':'13888888888'&#125;print(person['age'])print(person.get('age')) 2)、遍历for key in 字典:&emsp;循环体 其他遍历方法（效率较低）for key,value in person.items():&emsp;print(key, value) 2、增 / 改字典[key] = 值 若key在字典内存在，修改 若key不在字典内，增加 ‘key’:’值’1234person = &#123;'name':'小明', 'age':'18', 'tel':'13888888888'&#125;person['name'] = '小花'person['分数'] = 89print(person) 3、删 — 删除键对1）、del 字典[key] - 删除字典中指定key对应的键值对12del person['age']print(person) 2）、字典.pop(key) - 取出字典中指定key对应的值（key对应的键值对会从字典消失）12person.pop('name')print(person) 练习12345678910111213141516171819202122232425# 练习，保存一个班的学生信息：姓名，学号，年龄，成绩，电话）一个班五个人all_student = [ &#123;'name':'tom', 'age':20, 'score':80, 'tel':'13888888888'&#125;, &#123;'name':'tony', 'age':13, 'score':90, 'tel':'13888888883'&#125;, &#123;'name':'john', 'age':45, 'score':49, 'tel':'13888888884'&#125;, &#123;'name':'tom2', 'age':35, 'score':73, 'tel':'13888888885'&#125;, &#123;'name':'tom3', 'age':10, 'score':99, 'tel':'13888888886'&#125;]# 1）统计以上学生中不及格学生的人数n = 0for student in all_student: if student[score] &lt; 60: n += 1print(n)# 2）将打印所有未成年人学生的姓名for student in all_student: if student[age] &lt; 18: print(student[name])# 3）将年龄为25岁以上的学生的电话号码设置为’保密’for student in all_student: if student[age] &gt; 25: student[tel] = '保密'print(all_student) 三、字典的其他操作1、运算符：== !=（不支持：+ * &lt; &gt; &lt;= &gt;=运算）2、in / not inkey in 字典 / key not in 字典 - 判断key是否存在于字典中 3、len , dictlen(字典)——&gt;字典的长度，键值对的个数dict(数据)——&gt;将指定的数据转换成字典； 数据的要求： 1).数据本身是序列； 2).序列中的元素也是序列; 3).小序列中的元素智能有两个，第一个元素不可变 字典转换成列表 — 将字典所有的key取出来作为列表的元素 4、字典.clear() - 清空字典5、字典.copy() - 拷贝字典，返回新字典(相互不影响)6、dict.fromkeys(序列，值) - 创建新的字典，将序列中的元素作为key，指定的值作为每个key的值，创建新字典7、字典.items(),字典.values(),字典.keys()1）、字典.key() -&gt; 获取字典所有的key并且返回，返回的数据类型是序列但是不是列表2）、字典.values() -&gt; 获取字典所有的value并且返回，返回的数据类型是序列但是不是列表3）、字典.items() -&gt; 同时获取字典所有的key和value，返回一个序列，序列中元素是有两个元素的元祖，这两个元素分别是key和值8、字典.setdefault(key, value) - 字典中添加键值对（key值存在时不会修改）9、字典1.update(字典2) - 将字典2中的键值对添加到字典1中（不存在的就添加，存在的就覆盖）练习1234567891011121314# 练习2：设计数据保存一个班的信息：# 名字：python1906；# 所有老师（名字，性别，联系方式，职位）：# 所有学生（姓名，毕业学校，电话，性别，年龄，紧急联系人（姓名，电话，关系））class_1906 = &#123; 'class_name' : 'python_1906', 'all_teacher' : [ &#123;'name' : '张老师', 'gender' : '女', '职位' : '班主任', '联系方式' : '123451'&#125;, &#123;'name' : '余老师', 'gender' : '女', '职位' : '讲师', '联系方式' : '123452'&#125; ] 'all_student' : [ &#123;'name' : '张三', 'gender' : '男', '年龄' : '25', '联系方式' : '123453', '紧急联系人' : &#123;'name' : '李四', '关系' : '父子', '联系方式' : '12345678'&#125;&#125;,&#125;print(class_1906[all_student][-1]['紧急联系人'])","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]},{"title":"Python基础：5:数据类型之元组","slug":"Python基础/第一章 1.5 数据类型之元组","date":"2018-05-06T16:00:00.000Z","updated":"2021-01-08T14:27:15.238Z","comments":true,"path":"2018/05/07/Python基础/第一章 1.5 数据类型之元组/","link":"","permalink":"https://anjhon1994.github.io/2018/05/07/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.5%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%85%83%E7%BB%84/","excerpt":"","text":"一、什么是元组 元组就是不可变的列表 元组是将小括号 () 作为容器的标志；(元素1，元素2，…) 元组不可变性，不能增、删、改， 元组有序性，支持下标操作 元组元素可以是任何类型的数据 二、元组的操作。(元组的操作和列表的相似度很大，有一些独特的操作已单独列出）1、查 （元组的查和列表的基本相同；但元组不支持增、删、改）1234tuple1 = (2,5,8,1,8)print(tuple1[0])print(tuple1[3])print(tuple1[2:4:2]) 2、元组和列表相同的操作+&emsp;、\\&emsp; == &emsp;!=&emsp; is&emsp; in &emsp; not in &emsp; len &emsp;max &emsp;min&emsp; sum &emsp;sorted* 三、元组的独特操作1、单个元素的元组(单个元素后面要加一个逗号,不然打印不出类型)1234list1 = [10]print(list1, type(list1)) # [10] &lt;class 'list'&gt;tuple1 = (10,)print(tuple1,type(tuple1)) 2、单独使用的元组的值， 括号（）可以省略；直接多个数据用逗号隔开表示的还是一个元组1tuple2 = 10,20,30 3、可以通过让变量的个数和元组中元素的个数保持一致来分别获取元组中的元素（列表也适用此方法）123tuple3 = (10,20)x,y = tuple3print(x,y) # 10 20 4、同时申明多个变量获取元组元素，变量的个数可以比元组中元素的个数少，但是多个变量中的某一个变量前必须加星号*；带星号的变量可以获取不带星号的变量获取完剩下的部分。（列表也适用此方法）123tuple4 = (1,3,5,0,3,8)x1 ,*x2 ,x3 = tuple4print(x1,x2,x3)","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]},{"title":"Python基础：4:数据类型之列表","slug":"Python基础/第一章 1.4 数据类型之列表","date":"2018-04-30T16:00:00.000Z","updated":"2021-01-08T14:26:54.258Z","comments":true,"path":"2018/05/01/Python基础/第一章 1.4 数据类型之列表/","link":"","permalink":"https://anjhon1994.github.io/2018/05/01/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.4%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%88%97%E8%A1%A8/","excerpt":"","text":"一、什么是列表1、列表列表是python提供的容器型数据类型；以中括号[]作为容器标志；里面多个元素用逗号隔开：[1,2,3,4,5,6],元素的个数就是列表的长度列表是可变的、 有序的 ； 可变性：（元素的个数，元素的值，元素的顺序）-元素支持增、删、改操作； 有序性：支持下标操作 2、列表元素：列表中的元素可以是任何类型的数据(赋值语句除外)同一个列表中的元素的类型可以不一样例：[123,12.4,True,’sdf’,[1,4,5],(10,19),{‘name’:100},{1,2}] 二、列表的相关操作1、查 ——&gt; 获取列表中的元素1）、获取单个元素①：语法：列表 [ 下标 ] ②：说明：列表———–&gt;可以是列表值、保存列表的变量、结果是列表的表达式中括号[ ]——&gt;固定写法下标————&gt;列表中的每个元素都会对应一个下标，来表示元素在列表中的位置 下标范围：&emsp;0到列表长度减一 - 从前往后以此增加，0表示第一个元素&emsp;-1到负列表长度 - 从后往前依次递减，-1表示最后一个元素 IndexError：list index out of range - 下标越界报错 2）、获取部分元素（切片） - 切片的结果还是列表①：语法：列表 [ 开始下标：结束下标：步长 ] 列表[m:n:step] - 获取range(m,n,step)产生的数字序列作为下标去列表里取元素 ②：其他用法： 省略步长(默认步长是1)：列表[开始下标：结束下标];[m:n] 省略开始下标/步长：列表[：结束下标：步长];[:n:step]/列表[：结束下标][:n]&emsp;如果步长为正，从前往后取；如果步长为负，从后往前取 省略结束下标/步长：列表[开始下标：：步长];[m::step]/列表[开始下标：][m:]&emsp;从开始下标取到最后一个 省略开始和结束下标：列表[：：步长];[::step]/列表[：] ③：遍历列表： 直接遍历： for 变量 in 列表：&emsp;&emsp;循环体 通过下标遍历 length = len（列表）&emsp;for 变量 in range（length）：&emsp;&emsp;元素 = 列表[变量] 例：1234567list = [1, 30, 69, 6, 58, 77, 106]print(list[4]) # 58print(list[2:5]) # [69, 6, 58]print(list[2:5:2]) # [69, 58]print(list[:4])prine(list[3:])print(list[:]) 2、增 ——&gt; 添加元素1）、列表.append [ 元素 ] ——&gt; 在列表的最后添加元素2）、列表.insert [ 下标 ，元素 ] ——&gt; 在列表指定下标位置添加元素123list = ['肖申克的救赎', '功夫', '霸王别姬', '卧虎藏龙', '天方异谭', '恐怖游轮']print(list.append['我不是药神'])print(list.insert[-3, '大圣归来']) 3、删 ——&gt; 删除列表元素1）、del列表[下标]——&gt;删除指定下标的元素2）、列表.remove(元素)——&gt;删除列表中指定的元素&emsp;注：若列表中没有指定的元素，报错&emsp;&emsp;&emsp;若列表中有多个相同的指定元素，删除第一个 3）、列表.pop（）——&gt;取出列表中最后一个元素&emsp;&emsp;&emsp;列表.pop（下标）——&gt;取出列表中指定下标的元素注：pop()中，元素是被取出，并没有被删除；只是对列表来说，元素减少了，如果将pop取出的值用变量保存并打印出来，能得到该元素 123num = [2, 50, 8, 9, 43]prunt(num.pop(2)) # 8print(num) # [2, 50, 9, 43] 练习 123456789101112131415161718192021# 练习下面这个列表中小于60的元素# 答案：[89, 90, 78, 60, 87]方法一、scores = [89, 45, 56, 20, 90, 78, 60, 23, 87, 20, 50]for num in scores[:]: # 如果在原列表中删除，那么原列表的元素下标会不断变化，#最后程序虽然不报错，但是结果不准确 if num &lt; 60: scores.remove(num)print(scores)方法二、scores = [89, 45, 56, 20, 90, 78, 60, 23, 87, 20, 50]scores2 = scores[:]length = len(scores2)t = 0for x in range(length): if scores2[x] &lt; 60: scores.remove(scores[x]) else: t += 1print(scores) 4、改——&gt;修改列表中的元素列表[下标] = 值——&gt;修改列表中指定的元素 1234567练习：将下列表中小于60的分数换成不及格scores = [89, 45, 56, 20, 90, 78, 60, 23, 87, 20, 50]length = len(scores)for x in range(length): if scores[x] &lt; 60: scores[x] = '不及格'print(scores) 三、列表运算1、数学运算1）、加法 新列表中的元素是两个列表中元素的合并 2）、乘法 列表中的元素重复N次，产生一个新的列表1234list1 = [1, 2, 3, 4]list2 = ['王二', '张三', '李四']print(list1 + list2)print(list1 * 3) 2、比较运算符 等于和不等 == 、!=元素的内容，个数，顺序都一样才相等 大于、小于 &gt; &gt;= &lt; &lt;=两个列表的比较：先比较第一队元素的数值大小，第一队数值的大小就是列表的大小，如果第一队数值相等或者比较不了大小，比较第二队1234li1 = [1,2]li2 = [1,2]print(li1 == li2)print(li1 == li2) # print(id(li1) == id(li2)) 3、is / in / not in is 判断两个列表的地址是否相等 元素 in 列表——&gt;判断列表中是否存在指定元素 元素 not in 列表——&gt;判断列表中是否不存在指定元素 123names = ['小红', '小强', '小明']print('小明' in names)print('李四' in names) 4、列表相关函数len / max / min / list / sum 1）、len(序列)——&gt;获取序列的长度（元素的个数）2）、max(序列)\\min(序列)——&gt;获取序列中最大值和最小值对序列的要求：&emsp;&emsp;1.序列中所有元素的类型一致（数字看成一个类型）&emsp;&emsp;2.元素本身支持比较大小 3）、sum(数字序列)——&gt;求序列中所有元素的和（要求序列中的元素全是数字） 4）、list(序列)——&gt;将其他类型的序列转换成列表；序列是容器型数据 四、列表的其他操作1、列表.count（元素）——&gt;统计列表中指定元素的个数2、列表.extend（序列）——&gt;将其他序列的元素全部添加到列表中3、列表.index（元素）——&gt;获取指定元素在列表中的下标 a.若元素不存在，报错 b.若元素有多个 4、列表.revers（）——&gt;将原来的列表倒序（反过来）5、列表.clear（）——&gt;清空列表 清空列表用clear函数，不直接赋值为[]。 6、列表.copy()——&gt;复制列表中的元素，产生一个新的列表,赋值后两个相互不影响7、列表.sort()——&gt;将列表中的元素从小到大排序（直接修改列表中元素的顺序，不产生新列表） 列表.sort(revers=True) —– 将列表中的元素从大到小排序 列表.sort(revers=True) 相当于 列表.sort() ；列表.revers() 8、sorted(序列)——&gt;不修改原序列，排序后产生一个新的列表（从小到大） sorted(序列，reverse=True) 从大到小","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]},{"title":"Python基础：3:循环结构与分支结构","slug":"Python基础/第一章 1.3 分支结构和循环结构","date":"2018-04-17T16:00:00.000Z","updated":"2021-01-08T14:26:38.939Z","comments":true,"path":"2018/04/18/Python基础/第一章 1.3 分支结构和循环结构/","link":"","permalink":"https://anjhon1994.github.io/2018/04/18/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.3%20%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/","excerpt":"","text":"一、分支结构1、if 结构 （满足条件就执行某个操作，不满足就不执行。）1）、语法结构if 条件语句：&emsp;代码段 2）、说明 if——&gt;关键字，固定写法 条件语句——&gt;任何有结果的表达式都可以：数据，已经声明过的变量，运算表达式；不能是赋值 :（冒号） ——&gt;固定写法，（一般出现冒号的位置，后面一般都会产生缩进） 代码段——&gt;和if保持一个缩进的一条或多条语句；需要满足条件才执行的代码 3)执行过程先判断条件语句的结果是否为True（如果条件语句的结果不是布尔值，就先转换成布尔值）如果为True就执行代码段，否则代码段不执行 123num = 11if num &amp; 1 == 0: print('偶数') 2、if - else 结构（满足条件执行操作，不满足条件执行另外一个操作）1）、语法结构if 条件语句：&emsp;代码段1 （满足条件执行）else：&emsp;代码段2 （不满足条件执行） 2）、说明先判断条件语句的结果是否为True（如果条件语句的结果不是布尔值，就先转换成布尔值）如果为True就执行代码段1，否则执行代码段2 12345age = 20if age &gt;= 18: print('已成年')else: print('未成年') 3、if - elif - else 结构1）、语法结构if 条件语句：&emsp;代码段1elif 条件语句：&emsp;代码段2&emsp;&emsp;.&emsp;&emsp;.&emsp;&emsp;.else:&emsp;代码段N其他代码 2）、执行过程先判断田间语句1 是否为True，为True就执行代码段1，然后整个if-elif-else结构结束如果为False，就判断条件语句2是否为True，为True就执行代码段2，然后整个if-elif-else结构结束以此类推如果所有条件语句都不成立，执行else后面的代码段 1234567891011121314# 根据年龄范围打印：少年(14以下)、青年(14~25)、壮年(26~35)、中年(36~50)、老年(50以上)age = int(input('请输入你的年龄：'))if age &lt; 0 or age &gt;150: print('年龄不合法')elif age &lt; 14: print('少年')elif 14 &lt; age &lt;= 25: print('青年')elif 26 &lt; age &lt;= 35: print('壮年')elif 36 &lt; age &lt;= 50: print('中年')else: print('老年') 4、if 的嵌套if结构中的代码段中可以再出现其他的if语句 12345678910# 判断一个数是否是偶数，并且再判断这个数是否是4的倍数，并打出结论num = 9if num % 2 == 0: # if num &amp; 1 == 0: print('偶数') if num % 4 == 0: print('是4的倍数')else: print('奇数') if num % 10 == 3: print('个位数是3') 二、循环结构1、for 循环1）、语法结构for 变量 in 序列：&emsp;循环体 2）、说明 for——&gt;关键字，固定写法 变量名——&gt;标识符，声明变量的要求一样（当这个变量在循环中用不到时可以用下划线命名） in——&gt;关键字，固定写法 序列——&gt;结果是容器型数据；字符串，列表，字典，元组，集合，迭代器，生成器，range ：（冒号）——&gt;固定写法 循环体——&gt;和for保持一个缩进的一条或者多条语句：需要重复执行的语句 3）、执行过程让变量取序列中取值，每取一个值，执行一次循环体(for循环可以通过控制序列中元素的数量来控制循环的次数) 12for x in 'abcd': print('===') 注意：在for循环中，如果变量取出来的值用不到，则可以用下划线（_）给变量命名 2、range 函数 （控制for循环的次数）1）、range函数的作用 1、产生指定的数字序列 2、控制循环次数 2）、range 函数的用法&emsp;N 是正整数 1、range(N) - 产生0~N-1的数字序列range(4) -&gt; 0,1,2,312for x in range(4): print(x) 2、range(M,N) - 产生M~N-1的数字序列range(3,10) -&gt; 3,4,5,6,7,8,912for x in range(3,10): print(x) 3、range(M,N,step) - 从M开始每隔step产生下一个数字，到N前一个数为止range(0,10,2) -&gt; 0,2,4,6,812for x in range(0,10,2): print(x) 练习：123456789101112131415161718192021# 练习1，打印0-100中所有能被3整除的数# 方法1：for x in range(101): if x % 3 == 0: print(x)# 方法2：for x in range(0,101,3): print(x)# 练习2，统计1-100中能被4整除并且个位数是2的数字的个数num = 0for x in range(1,101): if x % 4 == 0 and x % 10 == 2: num += 1print(num)# 练习3.计算1+2+3+...+100sum = 0for x in range(1,101): sum += xprint(sum) 3、while 循环1）、语法结构while 条件语句：&emsp;循环体 2）、说明 while——&gt;关键字，固定写法 条件语句——&gt;任何有结果的表达式：数据，声明过的变量，运算表达式等（不能是赋值语句） ：(冒号)——&gt;固定写法 循环体——&gt;和while保持一个缩进的一条或者多条语句；（需要重复执行的额语句） 3）、执行过程先判断条件语句是否为True，如果为True就执行循环体，执行完循环体再判断条件语句是否为True为True又执行循环体，以此类推，直到循环体的结果是Fals循环结束 1234num = 0while num &lt; 5: print('我爱你') num += 1 思考：什么时候用 for ，什么时候用 while ？ 用 for 循环的情况：当循环次数确定遍历元素的时候 用 while 循环的情况死循环循环次数不确定 练习：猜数字1234567891011from random import randintnum1 = randint(100)num2 = int(input('请输入数字'))while num1 != num2: if num1 &gt; num2: print('这个数小了') else: print('这个数大了') num2 = int(input('请输入数字'))print('恭喜你答对了') 4、循环结构中的关键字1）、continue当执行循环体的时候，如果遇到continue那么此循环直接结束，直接进入下次循环的判断 12345for x in range(3): print('x') print('我是循环结果1') continue print('我是循环结果2' 2）、break当执行循环体时，如果遇到break，那么整个循环直接结束，执行循环后的其他代码 123456789sum = 0while True: x = int(input('请输入数字')) if x == 0: break if x &amp; 1 == 0 continue sum += xprint(sum) 3）、else 1）、完整的for循环 for 变量 in 序列：&emsp;循环体else：&emsp;代码段 2）、完整的while循环 while 条件语句：&emsp;循环体else：&emsp;代码段 else中的代码段：当循环自然死亡（for后的变量数据取完了，while后的条件为False）else后面的代码会在循环结束后执行,如果循环是在遇到break后结束的，那么else后的代码段就不会执行 else的意义：可以通过判断else中的代码有没有执行来判断循环有没有遇到break 4）、while死循环的用法：while True:&emsp;需要执行的代码&emsp;if 退出循环的条件：&emsp;&emsp;break 5、循环嵌套练习：计算：1！+2！+3！+…+10！12345678910111213141516#方法1sum = 0for x1 in range(1,11): pro = 1 for x2 in range(1,x1 + 1): pro *= x2 sum += proprint(sum)#方法2sum = 0pro = 1for x in range(1,11) pro *= x sum += proprint(sum)","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]},{"title":"Python基础：2:变量和运算符","slug":"Python基础/第一章 1.2 变量和运算符","date":"2018-04-04T16:00:00.000Z","updated":"2021-01-08T14:26:23.072Z","comments":true,"path":"2018/04/05/Python基础/第一章 1.2 变量和运算符/","link":"","permalink":"https://anjhon1994.github.io/2018/04/05/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.2%20%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"一、变量1、变量 变量是用来申请空间保存数据的变量的公式：变量名 = 值 2、说明 变量名：自由命名，但要遵循一下要求和规范要求:是标识符（1.由数字、字母和下划线组成；2.数字不能开头），不能是关键字规范:1.见名知义：看到变量名，知道变量里存的什么数据2.满足PEP8命名规范：变量名内所有字母都小写，如果由多个单词组成变量名，则多个单词之间用下划线隔开 3.不能用系统提供的函数名、类名、库名等系统相关的名来给变量命名 值：可以是任何有结果的表达式；例如：数据，已经赋值过的比那辆、运算表达式等 3、变量的使用使用变量就是在使用变量里面的值;变量中的值可以修改大小和类型 4、同时声明多个变量 同时声明多个变量赋相同的值变量1 = 变量2 = 变量3 = … = 值 同时声明多个变量赋不同的值变量1，变量2，变量3，…=值1，值2，值3… 5、python声明变量的原理根据变量的大小申请的相应大小的内存，将变量名和数据对应的内存空间关联在一起；在python中用一个变量给另外一个变量赋值的时候是将原来的变量的地址赋给另外一个变量，赋值完成后，数据只有一份。 变量三要素：1.类型 - 给变量复制的数据的类型 - type（变量）2.地址 - 给变量复制的数据在内存中的地址，也是正真存储的东西 - id（变量）3.值 - 给变量复制的数据 二、运算符(一)、数学运算符1、加减乘除：+&emsp; -&emsp; *&emsp; /1234print(10 + 3)print(10 - 3)print(10 * 3)print(10 / 3) 2、取余/取模/求余数：%123num = 123print(num % 10) #取个位print(num % 100) #取个位和十位 应用：1、判断正数的奇偶性 - 判断该数对2取余结果是否为02、判断是否能整除3、取低位数 3、整除：//（商只取整数部分）应用：取高位 1print(num // 100) #取高位1 注：负数的整除，取了结果之后减1 1print(-9 // 2) = -5 4、幂运算：** （x**y – x的y次方）123print(2 ** 3)print(16 ** (1/2)) #开方print(8 ** (1/3)) #开方 （二）、比较运算符所有的比较运算符的运算结果都是布尔值1、大于、小于、大于等于、小于等于：&gt; &lt; &gt;= &lt;= 12print(30 &gt;= 20)print(30 &gt;= 30) 2、等于、不等于：== != – 判断两个值是否相等 12print(10 == 10)print(10 != 10) 3、python可以用连续的比较运算符表示范围 12age = 30print(28 &lt; age &lt; 40) （三）、逻辑运算符逻辑运算的对象和结果都是布尔值1、and (逻辑与)1）、运算规则：两个都是True结果才是True，只要有一个是False结果就是False2）、使用场景：需要多个条件同时满足 12345# 判断一个数是否能同时被3和7整除num = input('请输入数值：')rem1 = int(num) % 3rem2 = int(num) % 7print('是否能同时被3和7整除：',rem1 == 0 and rem2 == 0) 2、or (逻辑或)1）、运算规则：两个都是False结果才是False，只要有一个是True结果就是True2）、使用场景：多个条件中有一个田间满足就行 12345# 判断一个数是否能被3或被7整除num = input('请输入数值：')rem1 = int(num) % 3rem2 = int(num) % 7print('是否能被3或被7整除：',rem1 == 0 or rem2 == 0) 3、not (逻辑非)1）、运算规则：True变False，False变True2）、使用场景：对一个条件进行否定 12345# 一个数不能同时被3和7整除的条件num = input('请输入数值：')rem1 = int(num) % 3rem2 = int(num) % 7print('不能同时被3和7整除：',not (rem1 == 0 and rem2 == 0)) （四）、赋值运算符= ， += ，-= ，= ，/= ，%= ，//= ，*=所有赋值运算符的左边必须是变量，组合赋值运算符的左边除了是变量，这个变量还必须是已经声明过的。1)、 变量 = 值 -&gt; 将右边的值赋给左边的变量2)、 组合赋值运算符已经声明过的变量 += 值 -&gt; 变量 = 变量 + 值 运算符优先级： 数学运算符 &gt; 比较运算符 &gt; 逻辑运算符 &gt; 赋值运算符 数学运算符优先级： ** &gt; *,/,//,%(优先级相同) &gt; + ,- 如果有括号则先算括号 （五）、位运算所有的位运算都是针对数字的补码进行操作的位运算符：&amp;(与)、|(或)、~(取反)、^(异或)、&lt;&lt;(左移)、&gt;&gt;(右移)1、&amp;(按位与)1）、运算规则：补码每一位上的数都是1结果就是1，如果有一个0结果就是0例：1110 &amp; 0111 = 01102）、运用：高效判断数字的奇偶性&emsp;将数字和1进行按位与运算，判断结果是0（偶数）还是1（奇数） 12print(3 &amp; 1, 7 &amp; 1,19 &amp; 1)print(4 &amp; 1, 128 &amp; 1,800 &amp; 1) 2、| (按位或)1）、运算规则：补码每一位上的数都是0结果就是0，如果有一个1结果就是1例：1110 | 0111 = 11113、~ (按位取反)、单目运算例：~1101 = 00104、^ (异或)运算规则：每一位上的数相同为0，不同为1例：1110 ^ 0111 = 10015、&lt;&lt; (左移)数字 &lt;&lt; N &emsp;指定的数字的补码整体向左移动N位；计算：数字*2**N6、&gt;&gt; (右移)数字 &gt;&gt; N &emsp;指定的数字的补码整体向右移动N位；计算：数字//2**N","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]},{"title":"Python基础：1:基础","slug":"Python基础/第一章 1.1 计算机和Python基础","date":"2018-04-01T16:00:00.000Z","updated":"2021-01-08T14:25:59.459Z","comments":true,"path":"2018/04/02/Python基础/第一章 1.1 计算机和Python基础/","link":"","permalink":"https://anjhon1994.github.io/2018/04/02/Python%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%201.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%92%8CPython%E5%9F%BA%E7%A1%80/","excerpt":"","text":"一、计算机基础1.1、进制计算机中的数字有四种存在形式，分别是：十进制、二进制、八进制和十六进制 1.1.1、十进制1.基数：0-92.进位：逢10进13.位权：例：123 = 3*10^0 + 2*10^1 +1*10^2，其中10^x就是这个十进制数的权位4.在Python中的表示方式：十进制数在Python中可直接书写5.将其他进制的数字转换为十进制的方法：直接用输出函数：print()例： 1.1.2、二进制1.基数：0-12.进位：逢2进13.位权：例：1001011 = 1*2^0 + 1*2^1 + 0*2^2 + 1*2^3 + 0*2^4 + 0*2^5 + 1*2^6，其中2^x就是该数的权位4.在Python中的表示方式：在二进制前加 0b / 0B ；例：0b1001/0B10015.将其他进制的数字转换为二进制的方法：bin(其他进制的数值)例： 1.1.3、八进制1.基数：0-72.进位：逢8进13.位权：例：167 = 7*8^0 + 6*8^1 + 1*8^2 ，其中8^x就是该数的权位4.在Python中的表示方式：在八进制前加 0o / 0O ；例：0o123/0O1235.将其他进制的数字转换为八进制的方法：oct(其他进制的数值)例： 1.1.4、十六进制1.基数：0，1，2，3，4，5，6，7，8，9，a(10)，b(11)，c(12)，d(13)，e(14)，f(15)2.进位：逢16进13.位权：例：ef3d = d*16^0 + 3*16^1 + f*16^2 + e*16^3，其中16^x就是该数的权位4.在Python中的表示方式：在十六进制前加 0x / 0X ；例：0xef3d / 0Xef3d5.将其他进制的数字转换为十六进制的方法：hex(其他进制的数值)例 1.1.5、进制之间的手动转换1、十进制和其他进制①：十进制转其他进制辗转取余法：不断除2/8/16取余，然后从下往上将余数写出来。②：其他进制转换成十进制基数与权位的乘积求和。 2、二进制和其他进制①：二转八：将二进制数从低位到高位每三位分开，将每三位转换成十进制，最后得到的既是一个八进制数；例：0b1 011 011 -&gt; 0o133②：二转十六：将二进制数从低位到高位每四位分开，将每四位转换成十进制，如果数值大于10，则用a-f代替相应数值，最后得到的既是一个十六进制数；例：0b101 1011 -&gt; 0x5b 3、八转二、十六转二①：八转二：将每一位八进制的数转换为三位的二进制数，最后得到相应的二进制数；②：十六转二：将每一位十六进制的数转换为四位的二进制数，最后得到相应的二进制数。 1.2、计算机存储1.2.1、存储单位 在计算机内最小的存储单位是 ： bit（位） 在计算机内使用内存的最小单位是：bytes（字节） 其中：1bytes = 8bit 其他单位换算：1KB = 1024 bytes1MB = 1024KB1GB = 1024MB1TB = 1024GB1PB = 1024TB 1.2.2、计算机存储原理 在计算机中，数据有原码，反码，补码三种形态。而数据的存储都是以补码的方式进行存储的，原因是计算机只有加法器，负数在进行运算时不能得出正确的结果，所以只能通过存储补码的方式解决这个问题。 1.2.2.1、原码 原码 = 符号位 + 数字对应的二进制 符号位（只有一位）：0代表正数，1代表负数例：12的二进制：1100 -&gt; 00001100(原)，其中最高位的0是符号位，代表正数。 12的原码是：10001100，其中最高位的1是符号位，代表负数。 注：由于计算机中使用内存时调用的最小存储单位是一个字节，8位，所以原码、反码和补码的位数都是8的倍数。 1.2.2.2、反码 原码的符号位不变，其余位全部取反，其结果就是原码的反码例：-12 -&gt; 10001100（原码） -&gt; 11110011（反码） 1.2.2.3、补码 补码 = 反码 + 1例：-12 -&gt; 10001100（原码） -&gt; 11110011（反码） -&gt; 11110100（补码） 注：正数的原码、反码和补码相同 二、Python基础2.1、Python编程中常用的快捷键 序号 快捷键 功能 1 Ctrl+/ 添加注释或取消注释 2 Ctrl+S 保存 3 Ctrl+C 复制 4 Ctrl+V 粘贴 5 Ctrl+Z 撤销 6 Ctrl+X 剪切 7 Ctrl+F 查找 8 Ctrl+Shift+Z 反撤销 9 Ctrl+R 替换 10 Ctrl+D 复制整行到下一行 11 Ctrl+A 全选 其他快捷操作：①：选区多行代码：先用鼠标点击选区开头，找到选区结尾，按住Shift键再点击选区结尾；②：同时操作多行代码：按住Alt键，用鼠标点击多行代码需要操作的位置即可。 2.2、Python基础语法（一）、注释 注释是在编程中不参与编译执行的文字，用来对代码进行解释说明1.单行整行注释：在该行代码的开头加 # 即可2.单行部分注释：在需要注释部分的代码前加 # 即可3.多行注释：在多行注释前后加三个单引号或者三个双引号即可（注：单引号或双引号都是输入法为英文状态时的符号） （二）、语句 一条语句占一行，一条语句结束后可以不加分号，如果多条语句在同一行，则语句之间必须加分号例：123print('helllo world')print('你好')print('helllo world');print('你好') （三）、缩进 一条语句开头不能随便缩进或空格，需要缩进的地方则必须缩进 小提示：IndentationError &gt;&gt;&gt; 缩进错误 （四）、标识符 标识符是专门用来给函数、类和变量命名的 标识符的基本要求： 1、标识符由数字、字母和下划线组成 2、数字不能开头 （五）、关键字 有特殊功能或者特殊意义的标识符就是关键字，又叫保留字 常见关键字：[‘False’, ‘None’, ‘True’, ‘and’, ‘as’, ‘assert’, ‘async’, ‘await’, break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘nonlocal’, ‘not’,’or’, ‘pass’, ‘raise’, ‘return’, ‘try’,’while’, ‘with’, ‘yield’] （六）、常用数据1.数字数据：用来表示大小，在程序中直接写例： 12print(100)print(2+5j) 2.文本数据：文本信息对应的数据，在程序中需要用双引号或者单引号引起来&emsp;电话号，身份证号，门牌号等是文本信息例： 12print('木_Python')print('13888888888') 3.布尔数据：用True表示真/肯定，用False表示假/否定，程序中只有True和False两种所有类型的数据都能转换成布尔值，所有为数字如果为0，所有序列如果为空则都会转换成False，其他都为True 12345678print(True)print(False)print(bool(0), bool(0.0), bool(''), bool([]), bool(()), bool(None))list1 = [1,2]if list1: print('===')elif not list1: print('+++') （七）、常见数据类型1.数字类型：整型（int）、浮点型（float）、复数2.文本类型：字符串（str）3.布尔类型（bool）：True和False4.其他：列表（list）、字典（dict）、元组（tuple）、集合（set）、迭代器（iter）、生成器、函数（function）&emsp;type（数据） - 获取数据类型 1print(type(100)) （八）、输入和输出1.输出：printprint(数据) - 在控制台直接打印数据 12print(10)print('aed') print(表达式) - 打印表达式的结果 1print(10+10) print(表达式1，表达式2，表达式3，…) - 在一行打印多个表达式的结果 1print('你好',123,'1+2') 1.定制换行: 12print('hello world',end= '你好,世界')print('啥') 2.定制分隔: 1print(1,2,3,4,sep='+') 2.输入：inputinput(提示输入信息) 12age = input('请输入年龄：')print('输入的年纪是：',age,type(age))","categories":[{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]}],"categories":[{"name":"NLP","slug":"NLP","permalink":"https://anjhon1994.github.io/categories/NLP/"},{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Django","slug":"Django","permalink":"https://anjhon1994.github.io/categories/Django/"},{"name":"数据库","slug":"数据库","permalink":"https://anjhon1994.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Linux","slug":"Linux","permalink":"https://anjhon1994.github.io/categories/Linux/"},{"name":"Git & Shell","slug":"Git-Shell","permalink":"https://anjhon1994.github.io/categories/Git-Shell/"},{"name":"Python学录","slug":"Python学录","permalink":"https://anjhon1994.github.io/categories/Python%E5%AD%A6%E5%BD%95/"}],"tags":[{"name":"词性标注","slug":"词性标注","permalink":"https://anjhon1994.github.io/tags/%E8%AF%8D%E6%80%A7%E6%A0%87%E6%B3%A8/"},{"name":"自然语言处理","slug":"自然语言处理","permalink":"https://anjhon1994.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"},{"name":"NLP","slug":"NLP","permalink":"https://anjhon1994.github.io/tags/NLP/"},{"name":"viterbi","slug":"viterbi","permalink":"https://anjhon1994.github.io/tags/viterbi/"},{"name":"机器学习","slug":"机器学习","permalink":"https://anjhon1994.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"https://anjhon1994.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"集成算法","slug":"集成算法","permalink":"https://anjhon1994.github.io/tags/%E9%9B%86%E6%88%90%E7%AE%97%E6%B3%95/"},{"name":"Bagging","slug":"Bagging","permalink":"https://anjhon1994.github.io/tags/Bagging/"},{"name":"随机森林","slug":"随机森林","permalink":"https://anjhon1994.github.io/tags/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"},{"name":"Boosting","slug":"Boosting","permalink":"https://anjhon1994.github.io/tags/Boosting/"},{"name":"AdaBoost","slug":"AdaBoost","permalink":"https://anjhon1994.github.io/tags/AdaBoost/"},{"name":"GBDT","slug":"GBDT","permalink":"https://anjhon1994.github.io/tags/GBDT/"},{"name":"聚类","slug":"聚类","permalink":"https://anjhon1994.github.io/tags/%E8%81%9A%E7%B1%BB/"},{"name":"决策树","slug":"决策树","permalink":"https://anjhon1994.github.io/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"},{"name":"支持向量机","slug":"支持向量机","permalink":"https://anjhon1994.github.io/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"name":"SVM","slug":"SVM","permalink":"https://anjhon1994.github.io/tags/SVM/"},{"name":"框架","slug":"框架","permalink":"https://anjhon1994.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"后端","slug":"后端","permalink":"https://anjhon1994.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Django","slug":"Django","permalink":"https://anjhon1994.github.io/tags/Django/"},{"name":"MySQL","slug":"MySQL","permalink":"https://anjhon1994.github.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://anjhon1994.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","permalink":"https://anjhon1994.github.io/tags/Redis/"},{"name":"基础","slug":"基础","permalink":"https://anjhon1994.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"redis","slug":"redis","permalink":"https://anjhon1994.github.io/tags/redis/"},{"name":"Linux","slug":"Linux","permalink":"https://anjhon1994.github.io/tags/Linux/"},{"name":"vim","slug":"vim","permalink":"https://anjhon1994.github.io/tags/vim/"},{"name":"shell","slug":"shell","permalink":"https://anjhon1994.github.io/tags/shell/"},{"name":"脚本","slug":"脚本","permalink":"https://anjhon1994.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"编程语言","slug":"编程语言","permalink":"https://anjhon1994.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"指令","slug":"指令","permalink":"https://anjhon1994.github.io/tags/%E6%8C%87%E4%BB%A4/"},{"name":"git","slug":"git","permalink":"https://anjhon1994.github.io/tags/git/"},{"name":"技术文档","slug":"技术文档","permalink":"https://anjhon1994.github.io/tags/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"},{"name":"朴素贝叶斯","slug":"朴素贝叶斯","permalink":"https://anjhon1994.github.io/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"},{"name":"sklearn","slug":"sklearn","permalink":"https://anjhon1994.github.io/tags/sklearn/"},{"name":"Logistic回归","slug":"Logistic回归","permalink":"https://anjhon1994.github.io/tags/Logistic%E5%9B%9E%E5%BD%92/"},{"name":"KNN","slug":"KNN","permalink":"https://anjhon1994.github.io/tags/KNN/"},{"name":"配置","slug":"配置","permalink":"https://anjhon1994.github.io/tags/%E9%85%8D%E7%BD%AE/"},{"name":"Linux软件","slug":"Linux软件","permalink":"https://anjhon1994.github.io/tags/Linux%E8%BD%AF%E4%BB%B6/"},{"name":"服务器","slug":"服务器","permalink":"https://anjhon1994.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Lasso回归","slug":"Lasso回归","permalink":"https://anjhon1994.github.io/tags/Lasso%E5%9B%9E%E5%BD%92/"},{"name":"Ridge回归","slug":"Ridge回归","permalink":"https://anjhon1994.github.io/tags/Ridge%E5%9B%9E%E5%BD%92/"},{"name":"线性回归","slug":"线性回归","permalink":"https://anjhon1994.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"name":"python","slug":"python","permalink":"https://anjhon1994.github.io/tags/python/"}]}